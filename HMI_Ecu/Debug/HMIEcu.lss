
HMIEcu.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006110  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000134  00800060  00006110  000061a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000005fa  00800194  00800194  000062d8  2**0
                  ALLOC
  3 .debug_aranges 00000640  00000000  00000000  000062d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000bb7  00000000  00000000  00006918  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000055c9  00000000  00000000  000074cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001cf9  00000000  00000000  0000ca98  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00006478  00000000  00000000  0000e791  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000009e0  00000000  00000000  00014c0c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001a33  00000000  00000000  000155ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000007ce  00000000  00000000  0001701f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macinfo 0005d808  00000000  00000000  000177ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004f0  00000000  00000000  00074ff5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 84 11 	jmp	0x2308	; 0x2308 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 f2 07 	jmp	0xfe4	; 0xfe4 <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e1       	ldi	r30, 0x10	; 16
      68:	f1 e6       	ldi	r31, 0x61	; 97
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 39       	cpi	r26, 0x94	; 148
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a4 e9       	ldi	r26, 0x94	; 148
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 38       	cpi	r26, 0x8E	; 142
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7f 2f 	call	0x5efe	; 0x5efe <main>
      8a:	0c 94 86 30 	jmp	0x610c	; 0x610c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 02 30 	jmp	0x6004	; 0x6004 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a3 e7       	ldi	r26, 0x73	; 115
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 1e 30 	jmp	0x603c	; 0x603c <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 0e 30 	jmp	0x601c	; 0x601c <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 2a 30 	jmp	0x6054	; 0x6054 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 0e 30 	jmp	0x601c	; 0x601c <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 2a 30 	jmp	0x6054	; 0x6054 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 02 30 	jmp	0x6004	; 0x6004 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	83 e7       	ldi	r24, 0x73	; 115
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 1e 30 	jmp	0x603c	; 0x603c <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 0e 30 	jmp	0x601c	; 0x601c <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 2a 30 	jmp	0x6054	; 0x6054 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 0e 30 	jmp	0x601c	; 0x601c <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 2a 30 	jmp	0x6054	; 0x6054 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 0e 30 	jmp	0x601c	; 0x601c <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 2a 30 	jmp	0x6054	; 0x6054 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 12 30 	jmp	0x6024	; 0x6024 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 2e 30 	jmp	0x605c	; 0x605c <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <USART_init>:
 * character size, parity, stop bits, and interrupt settings. It disables the
 * USART during configuration and enables it after setup.
 *
 * @param usart Pointer to the USART configuration structure.
 */
void USART_init(USART_t *usart) {
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	2b 97       	sbiw	r28, 0x0b	; 11
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	de bf       	out	0x3e, r29	; 62
     b56:	0f be       	out	0x3f, r0	; 63
     b58:	cd bf       	out	0x3d, r28	; 61
     b5a:	9f 83       	std	Y+7, r25	; 0x07
     b5c:	8e 83       	std	Y+6, r24	; 0x06
	uint8 modeFlag = 0; /* Async */
     b5e:	1d 82       	std	Y+5, r1	; 0x05

	/* Disable module */
	CLEAR_BIT(UCSRB, RXEN);
     b60:	aa e2       	ldi	r26, 0x2A	; 42
     b62:	b0 e0       	ldi	r27, 0x00	; 0
     b64:	ea e2       	ldi	r30, 0x2A	; 42
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	80 81       	ld	r24, Z
     b6a:	8f 7e       	andi	r24, 0xEF	; 239
     b6c:	8c 93       	st	X, r24
	CLEAR_BIT(UCSRB, TXEN);
     b6e:	aa e2       	ldi	r26, 0x2A	; 42
     b70:	b0 e0       	ldi	r27, 0x00	; 0
     b72:	ea e2       	ldi	r30, 0x2A	; 42
     b74:	f0 e0       	ldi	r31, 0x00	; 0
     b76:	80 81       	ld	r24, Z
     b78:	87 7f       	andi	r24, 0xF7	; 247
     b7a:	8c 93       	st	X, r24

	uint32 ubrrTemp = F_CPU / (2 * (usart->baudRate));
     b7c:	ee 81       	ldd	r30, Y+6	; 0x06
     b7e:	ff 81       	ldd	r31, Y+7	; 0x07
     b80:	80 81       	ld	r24, Z
     b82:	91 81       	ldd	r25, Z+1	; 0x01
     b84:	88 0f       	add	r24, r24
     b86:	99 1f       	adc	r25, r25
     b88:	9c 01       	movw	r18, r24
     b8a:	40 e0       	ldi	r20, 0x00	; 0
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	80 e0       	ldi	r24, 0x00	; 0
     b90:	92 e1       	ldi	r25, 0x12	; 18
     b92:	aa e7       	ldi	r26, 0x7A	; 122
     b94:	b0 e0       	ldi	r27, 0x00	; 0
     b96:	bc 01       	movw	r22, r24
     b98:	cd 01       	movw	r24, r26
     b9a:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <__udivmodsi4>
     b9e:	da 01       	movw	r26, r20
     ba0:	c9 01       	movw	r24, r18
     ba2:	89 83       	std	Y+1, r24	; 0x01
     ba4:	9a 83       	std	Y+2, r25	; 0x02
     ba6:	ab 83       	std	Y+3, r26	; 0x03
     ba8:	bc 83       	std	Y+4, r27	; 0x04

	/* Set Mode */
	/* Set Speed & BaudRate */
	switch (usart->mode) {
     baa:	ee 81       	ldd	r30, Y+6	; 0x06
     bac:	ff 81       	ldd	r31, Y+7	; 0x07
     bae:	82 81       	ldd	r24, Z+2	; 0x02
     bb0:	83 70       	andi	r24, 0x03	; 3
     bb2:	28 2f       	mov	r18, r24
     bb4:	30 e0       	ldi	r19, 0x00	; 0
     bb6:	3b 87       	std	Y+11, r19	; 0x0b
     bb8:	2a 87       	std	Y+10, r18	; 0x0a
     bba:	8a 85       	ldd	r24, Y+10	; 0x0a
     bbc:	9b 85       	ldd	r25, Y+11	; 0x0b
     bbe:	81 30       	cpi	r24, 0x01	; 1
     bc0:	91 05       	cpc	r25, r1
     bc2:	09 f4       	brne	.+2      	; 0xbc6 <USART_init+0x80>
     bc4:	4f c0       	rjmp	.+158    	; 0xc64 <USART_init+0x11e>
     bc6:	2a 85       	ldd	r18, Y+10	; 0x0a
     bc8:	3b 85       	ldd	r19, Y+11	; 0x0b
     bca:	22 30       	cpi	r18, 0x02	; 2
     bcc:	31 05       	cpc	r19, r1
     bce:	09 f4       	brne	.+2      	; 0xbd2 <USART_init+0x8c>
     bd0:	58 c0       	rjmp	.+176    	; 0xc82 <USART_init+0x13c>
     bd2:	8a 85       	ldd	r24, Y+10	; 0x0a
     bd4:	9b 85       	ldd	r25, Y+11	; 0x0b
     bd6:	00 97       	sbiw	r24, 0x00	; 0
     bd8:	09 f0       	breq	.+2      	; 0xbdc <USART_init+0x96>
     bda:	61 c0       	rjmp	.+194    	; 0xc9e <USART_init+0x158>
	case USART_MODE_ASYNC:
		CLEAR_BIT(UCSRA, MPCM);
     bdc:	ab e2       	ldi	r26, 0x2B	; 43
     bde:	b0 e0       	ldi	r27, 0x00	; 0
     be0:	eb e2       	ldi	r30, 0x2B	; 43
     be2:	f0 e0       	ldi	r31, 0x00	; 0
     be4:	80 81       	ld	r24, Z
     be6:	8e 7f       	andi	r24, 0xFE	; 254
     be8:	8c 93       	st	X, r24
		switch (usart->asyncSpeed) {
     bea:	ee 81       	ldd	r30, Y+6	; 0x06
     bec:	ff 81       	ldd	r31, Y+7	; 0x07
     bee:	82 81       	ldd	r24, Z+2	; 0x02
     bf0:	82 95       	swap	r24
     bf2:	8f 70       	andi	r24, 0x0F	; 15
     bf4:	81 70       	andi	r24, 0x01	; 1
     bf6:	28 2f       	mov	r18, r24
     bf8:	30 e0       	ldi	r19, 0x00	; 0
     bfa:	39 87       	std	Y+9, r19	; 0x09
     bfc:	28 87       	std	Y+8, r18	; 0x08
     bfe:	88 85       	ldd	r24, Y+8	; 0x08
     c00:	99 85       	ldd	r25, Y+9	; 0x09
     c02:	00 97       	sbiw	r24, 0x00	; 0
     c04:	31 f0       	breq	.+12     	; 0xc12 <USART_init+0xcc>
     c06:	28 85       	ldd	r18, Y+8	; 0x08
     c08:	39 85       	ldd	r19, Y+9	; 0x09
     c0a:	21 30       	cpi	r18, 0x01	; 1
     c0c:	31 05       	cpc	r19, r1
     c0e:	91 f0       	breq	.+36     	; 0xc34 <USART_init+0xee>
     c10:	46 c0       	rjmp	.+140    	; 0xc9e <USART_init+0x158>
		case USART_ASYNC_SPEED_NORMAL:
			ubrrTemp /= 8; /* Divide by 8 for normal speed */
     c12:	89 81       	ldd	r24, Y+1	; 0x01
     c14:	9a 81       	ldd	r25, Y+2	; 0x02
     c16:	ab 81       	ldd	r26, Y+3	; 0x03
     c18:	bc 81       	ldd	r27, Y+4	; 0x04
     c1a:	68 94       	set
     c1c:	12 f8       	bld	r1, 2
     c1e:	b6 95       	lsr	r27
     c20:	a7 95       	ror	r26
     c22:	97 95       	ror	r25
     c24:	87 95       	ror	r24
     c26:	16 94       	lsr	r1
     c28:	d1 f7       	brne	.-12     	; 0xc1e <USART_init+0xd8>
     c2a:	89 83       	std	Y+1, r24	; 0x01
     c2c:	9a 83       	std	Y+2, r25	; 0x02
     c2e:	ab 83       	std	Y+3, r26	; 0x03
     c30:	bc 83       	std	Y+4, r27	; 0x04
     c32:	35 c0       	rjmp	.+106    	; 0xc9e <USART_init+0x158>
			break;
		case USART_ASYNC_SPEED_DOUBLE_NORMAL:
			SET_BIT(UCSRA, U2X);
     c34:	ab e2       	ldi	r26, 0x2B	; 43
     c36:	b0 e0       	ldi	r27, 0x00	; 0
     c38:	eb e2       	ldi	r30, 0x2B	; 43
     c3a:	f0 e0       	ldi	r31, 0x00	; 0
     c3c:	80 81       	ld	r24, Z
     c3e:	82 60       	ori	r24, 0x02	; 2
     c40:	8c 93       	st	X, r24
			ubrrTemp /= 4; /* Divide by 4 for double speed */
     c42:	89 81       	ldd	r24, Y+1	; 0x01
     c44:	9a 81       	ldd	r25, Y+2	; 0x02
     c46:	ab 81       	ldd	r26, Y+3	; 0x03
     c48:	bc 81       	ldd	r27, Y+4	; 0x04
     c4a:	b6 95       	lsr	r27
     c4c:	a7 95       	ror	r26
     c4e:	97 95       	ror	r25
     c50:	87 95       	ror	r24
     c52:	b6 95       	lsr	r27
     c54:	a7 95       	ror	r26
     c56:	97 95       	ror	r25
     c58:	87 95       	ror	r24
     c5a:	89 83       	std	Y+1, r24	; 0x01
     c5c:	9a 83       	std	Y+2, r25	; 0x02
     c5e:	ab 83       	std	Y+3, r26	; 0x03
     c60:	bc 83       	std	Y+4, r27	; 0x04
     c62:	1d c0       	rjmp	.+58     	; 0xc9e <USART_init+0x158>
			break;
		}
		break;
	case USART_MODE_SYNC_MASTER:
		CLEAR_BIT(UCSRA, MPCM);
     c64:	ab e2       	ldi	r26, 0x2B	; 43
     c66:	b0 e0       	ldi	r27, 0x00	; 0
     c68:	eb e2       	ldi	r30, 0x2B	; 43
     c6a:	f0 e0       	ldi	r31, 0x00	; 0
     c6c:	80 81       	ld	r24, Z
     c6e:	8e 7f       	andi	r24, 0xFE	; 254
     c70:	8c 93       	st	X, r24
		modeFlag = 1;
     c72:	81 e0       	ldi	r24, 0x01	; 1
     c74:	8d 83       	std	Y+5, r24	; 0x05

		/* Configure pin for Sync Master */
		GPIO_setupPinDirection(PORTB_ID, PIN0_ID, PIN_OUTPUT);
     c76:	81 e0       	ldi	r24, 0x01	; 1
     c78:	60 e0       	ldi	r22, 0x00	; 0
     c7a:	41 e0       	ldi	r20, 0x01	; 1
     c7c:	0e 94 25 08 	call	0x104a	; 0x104a <GPIO_setupPinDirection>
     c80:	0e c0       	rjmp	.+28     	; 0xc9e <USART_init+0x158>
		break;
	case USART_MODE_SYNC_SLAVE:
		SET_BIT(UCSRA, MPCM);
     c82:	ab e2       	ldi	r26, 0x2B	; 43
     c84:	b0 e0       	ldi	r27, 0x00	; 0
     c86:	eb e2       	ldi	r30, 0x2B	; 43
     c88:	f0 e0       	ldi	r31, 0x00	; 0
     c8a:	80 81       	ld	r24, Z
     c8c:	81 60       	ori	r24, 0x01	; 1
     c8e:	8c 93       	st	X, r24
		modeFlag = 1;
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	8d 83       	std	Y+5, r24	; 0x05

		/* Configure pin for Sync Slave */
		GPIO_setupPinDirection(PORTB_ID, PIN0_ID, PIN_INPUT);
     c94:	81 e0       	ldi	r24, 0x01	; 1
     c96:	60 e0       	ldi	r22, 0x00	; 0
     c98:	40 e0       	ldi	r20, 0x00	; 0
     c9a:	0e 94 25 08 	call	0x104a	; 0x104a <GPIO_setupPinDirection>
		break;
	}

	ubrrTemp--;
     c9e:	89 81       	ldd	r24, Y+1	; 0x01
     ca0:	9a 81       	ldd	r25, Y+2	; 0x02
     ca2:	ab 81       	ldd	r26, Y+3	; 0x03
     ca4:	bc 81       	ldd	r27, Y+4	; 0x04
     ca6:	01 97       	sbiw	r24, 0x01	; 1
     ca8:	a1 09       	sbc	r26, r1
     caa:	b1 09       	sbc	r27, r1
     cac:	89 83       	std	Y+1, r24	; 0x01
     cae:	9a 83       	std	Y+2, r25	; 0x02
     cb0:	ab 83       	std	Y+3, r26	; 0x03
     cb2:	bc 83       	std	Y+4, r27	; 0x04

	/* Set baud rate */
	UBRRH = (uint8) (ubrrTemp >> 8) & 0x0F;
     cb4:	e0 e4       	ldi	r30, 0x40	; 64
     cb6:	f0 e0       	ldi	r31, 0x00	; 0
     cb8:	89 81       	ldd	r24, Y+1	; 0x01
     cba:	9a 81       	ldd	r25, Y+2	; 0x02
     cbc:	ab 81       	ldd	r26, Y+3	; 0x03
     cbe:	bc 81       	ldd	r27, Y+4	; 0x04
     cc0:	89 2f       	mov	r24, r25
     cc2:	9a 2f       	mov	r25, r26
     cc4:	ab 2f       	mov	r26, r27
     cc6:	bb 27       	eor	r27, r27
     cc8:	8f 70       	andi	r24, 0x0F	; 15
     cca:	80 83       	st	Z, r24
	UBRRL = (uint8) ubrrTemp;
     ccc:	e9 e2       	ldi	r30, 0x29	; 41
     cce:	f0 e0       	ldi	r31, 0x00	; 0
     cd0:	89 81       	ldd	r24, Y+1	; 0x01
     cd2:	80 83       	st	Z, r24

	/* Set interrupts */
#ifdef USART_RX_COMPLETE_INTERRUPT_ENABLE
	SET_BIT(UCSRB, RXCIE); /* Enable RX Complete Interrupt */
     cd4:	aa e2       	ldi	r26, 0x2A	; 42
     cd6:	b0 e0       	ldi	r27, 0x00	; 0
     cd8:	ea e2       	ldi	r30, 0x2A	; 42
     cda:	f0 e0       	ldi	r31, 0x00	; 0
     cdc:	80 81       	ld	r24, Z
     cde:	80 68       	ori	r24, 0x80	; 128
     ce0:	8c 93       	st	X, r24
#ifdef USART_EMPTY_REGISTER_INTERRUPT_ENABLE
	SET_BIT(UCSRB, UDRIE); /* Enable Data Register Empty Interrupt */
#endif

	/* Set Char Size */
	UCSRBbits.ucsz2 = usart->charSize >> 2;
     ce2:	aa e2       	ldi	r26, 0x2A	; 42
     ce4:	b0 e0       	ldi	r27, 0x00	; 0
     ce6:	ee 81       	ldd	r30, Y+6	; 0x06
     ce8:	ff 81       	ldd	r31, Y+7	; 0x07
     cea:	83 81       	ldd	r24, Z+3	; 0x03
     cec:	86 95       	lsr	r24
     cee:	87 70       	andi	r24, 0x07	; 7
     cf0:	88 2f       	mov	r24, r24
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	95 95       	asr	r25
     cf6:	87 95       	ror	r24
     cf8:	95 95       	asr	r25
     cfa:	87 95       	ror	r24
     cfc:	81 70       	andi	r24, 0x01	; 1
     cfe:	81 70       	andi	r24, 0x01	; 1
     d00:	98 2f       	mov	r25, r24
     d02:	99 0f       	add	r25, r25
     d04:	99 0f       	add	r25, r25
     d06:	8c 91       	ld	r24, X
     d08:	8b 7f       	andi	r24, 0xFB	; 251
     d0a:	89 2b       	or	r24, r25
     d0c:	8c 93       	st	X, r24

	UCSRC = (1 << URSEL) | (usart->parityMode << UPM0) | /* Select Parity */
     d0e:	a0 e4       	ldi	r26, 0x40	; 64
     d10:	b0 e0       	ldi	r27, 0x00	; 0
     d12:	ee 81       	ldd	r30, Y+6	; 0x06
     d14:	ff 81       	ldd	r31, Y+7	; 0x07
     d16:	82 81       	ldd	r24, Z+2	; 0x02
     d18:	86 95       	lsr	r24
     d1a:	86 95       	lsr	r24
     d1c:	83 70       	andi	r24, 0x03	; 3
     d1e:	88 2f       	mov	r24, r24
     d20:	90 e0       	ldi	r25, 0x00	; 0
     d22:	82 95       	swap	r24
     d24:	92 95       	swap	r25
     d26:	90 7f       	andi	r25, 0xF0	; 240
     d28:	98 27       	eor	r25, r24
     d2a:	80 7f       	andi	r24, 0xF0	; 240
     d2c:	98 27       	eor	r25, r24
     d2e:	28 2f       	mov	r18, r24
     d30:	20 68       	ori	r18, 0x80	; 128
     d32:	ee 81       	ldd	r30, Y+6	; 0x06
     d34:	ff 81       	ldd	r31, Y+7	; 0x07
     d36:	82 81       	ldd	r24, Z+2	; 0x02
     d38:	82 95       	swap	r24
     d3a:	86 95       	lsr	r24
     d3c:	87 70       	andi	r24, 0x07	; 7
     d3e:	81 70       	andi	r24, 0x01	; 1
     d40:	88 2f       	mov	r24, r24
     d42:	90 e0       	ldi	r25, 0x00	; 0
     d44:	88 0f       	add	r24, r24
     d46:	99 1f       	adc	r25, r25
     d48:	88 0f       	add	r24, r24
     d4a:	99 1f       	adc	r25, r25
     d4c:	88 0f       	add	r24, r24
     d4e:	99 1f       	adc	r25, r25
     d50:	28 2b       	or	r18, r24
     d52:	ee 81       	ldd	r30, Y+6	; 0x06
     d54:	ff 81       	ldd	r31, Y+7	; 0x07
     d56:	83 81       	ldd	r24, Z+3	; 0x03
     d58:	86 95       	lsr	r24
     d5a:	87 70       	andi	r24, 0x07	; 7
     d5c:	88 2f       	mov	r24, r24
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	83 70       	andi	r24, 0x03	; 3
     d62:	90 70       	andi	r25, 0x00	; 0
     d64:	88 0f       	add	r24, r24
     d66:	99 1f       	adc	r25, r25
     d68:	92 2f       	mov	r25, r18
     d6a:	98 2b       	or	r25, r24
     d6c:	ee 81       	ldd	r30, Y+6	; 0x06
     d6e:	ff 81       	ldd	r31, Y+7	; 0x07
     d70:	82 81       	ldd	r24, Z+2	; 0x02
     d72:	82 95       	swap	r24
     d74:	86 95       	lsr	r24
     d76:	86 95       	lsr	r24
     d78:	83 70       	andi	r24, 0x03	; 3
     d7a:	81 70       	andi	r24, 0x01	; 1
     d7c:	89 2b       	or	r24, r25
     d7e:	8c 93       	st	X, r24
	(usart->stopBits << USBS) | /* Select Stop */
	((usart->charSize & 3) << UCSZ0) | /* Set Char Size ucsz0 & ucsz1 */
	(usart->clockPolarity << UCPOL); /* Select Clock polarity */

	/* Enable module */
	UCSRBbits.rxen = usart->rxEnable; /* Enable receiver */
     d80:	aa e2       	ldi	r26, 0x2A	; 42
     d82:	b0 e0       	ldi	r27, 0x00	; 0
     d84:	ee 81       	ldd	r30, Y+6	; 0x06
     d86:	ff 81       	ldd	r31, Y+7	; 0x07
     d88:	83 81       	ldd	r24, Z+3	; 0x03
     d8a:	81 70       	andi	r24, 0x01	; 1
     d8c:	81 70       	andi	r24, 0x01	; 1
     d8e:	98 2f       	mov	r25, r24
     d90:	92 95       	swap	r25
     d92:	90 7f       	andi	r25, 0xF0	; 240
     d94:	8c 91       	ld	r24, X
     d96:	8f 7e       	andi	r24, 0xEF	; 239
     d98:	89 2b       	or	r24, r25
     d9a:	8c 93       	st	X, r24
	UCSRBbits.txen = usart->txEnable; /* Enable transmitter */
     d9c:	aa e2       	ldi	r26, 0x2A	; 42
     d9e:	b0 e0       	ldi	r27, 0x00	; 0
     da0:	ee 81       	ldd	r30, Y+6	; 0x06
     da2:	ff 81       	ldd	r31, Y+7	; 0x07
     da4:	82 81       	ldd	r24, Z+2	; 0x02
     da6:	88 1f       	adc	r24, r24
     da8:	88 27       	eor	r24, r24
     daa:	88 1f       	adc	r24, r24
     dac:	81 70       	andi	r24, 0x01	; 1
     dae:	98 2f       	mov	r25, r24
     db0:	99 0f       	add	r25, r25
     db2:	99 0f       	add	r25, r25
     db4:	99 0f       	add	r25, r25
     db6:	8c 91       	ld	r24, X
     db8:	87 7f       	andi	r24, 0xF7	; 247
     dba:	89 2b       	or	r24, r25
     dbc:	8c 93       	st	X, r24
}
     dbe:	2b 96       	adiw	r28, 0x0b	; 11
     dc0:	0f b6       	in	r0, 0x3f	; 63
     dc2:	f8 94       	cli
     dc4:	de bf       	out	0x3e, r29	; 62
     dc6:	0f be       	out	0x3f, r0	; 63
     dc8:	cd bf       	out	0x3d, r28	; 61
     dca:	cf 91       	pop	r28
     dcc:	df 91       	pop	r29
     dce:	08 95       	ret

00000dd0 <USART_isInit>:

uint8 USART_isInit() {
     dd0:	df 93       	push	r29
     dd2:	cf 93       	push	r28
     dd4:	cd b7       	in	r28, 0x3d	; 61
     dd6:	de b7       	in	r29, 0x3e	; 62
	return UCSRBbits.txen | UCSRBbits.rxen;
     dd8:	ea e2       	ldi	r30, 0x2A	; 42
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	80 81       	ld	r24, Z
     dde:	86 95       	lsr	r24
     de0:	86 95       	lsr	r24
     de2:	86 95       	lsr	r24
     de4:	81 70       	andi	r24, 0x01	; 1
     de6:	98 2f       	mov	r25, r24
     de8:	ea e2       	ldi	r30, 0x2A	; 42
     dea:	f0 e0       	ldi	r31, 0x00	; 0
     dec:	80 81       	ld	r24, Z
     dee:	82 95       	swap	r24
     df0:	8f 70       	andi	r24, 0x0F	; 15
     df2:	81 70       	andi	r24, 0x01	; 1
     df4:	89 2b       	or	r24, r25
}
     df6:	cf 91       	pop	r28
     df8:	df 91       	pop	r29
     dfa:	08 95       	ret

00000dfc <USART_deInit>:
 * @brief Deinitializes the USART module.
 *
 * This function resets the USART registers to their default values and
 * disables all interrupts related to USART.
 */
void USART_deInit(void) {
     dfc:	df 93       	push	r29
     dfe:	cf 93       	push	r28
     e00:	cd b7       	in	r28, 0x3d	; 61
     e02:	de b7       	in	r29, 0x3e	; 62
	UCSRA = UCSRB = UBRRL = UBRRH = 0; /* Reset registers */
     e04:	4b e2       	ldi	r20, 0x2B	; 43
     e06:	50 e0       	ldi	r21, 0x00	; 0
     e08:	2a e2       	ldi	r18, 0x2A	; 42
     e0a:	30 e0       	ldi	r19, 0x00	; 0
     e0c:	a9 e2       	ldi	r26, 0x29	; 41
     e0e:	b0 e0       	ldi	r27, 0x00	; 0
     e10:	e0 e4       	ldi	r30, 0x40	; 64
     e12:	f0 e0       	ldi	r31, 0x00	; 0
     e14:	10 82       	st	Z, r1
     e16:	80 81       	ld	r24, Z
     e18:	8c 93       	st	X, r24
     e1a:	8c 91       	ld	r24, X
     e1c:	f9 01       	movw	r30, r18
     e1e:	80 83       	st	Z, r24
     e20:	f9 01       	movw	r30, r18
     e22:	80 81       	ld	r24, Z
     e24:	fa 01       	movw	r30, r20
     e26:	80 83       	st	Z, r24
	UCSRC = (1 << URSEL); /* Reset UCSRC register */
     e28:	e0 e4       	ldi	r30, 0x40	; 64
     e2a:	f0 e0       	ldi	r31, 0x00	; 0
     e2c:	80 e8       	ldi	r24, 0x80	; 128
     e2e:	80 83       	st	Z, r24

#ifdef USART_RX_COMPLETE_INTERRUPT_ENABLE
  CLEAR_BIT(UCSRB, RXCIE); /* Disable RX Complete Interrupt */
     e30:	aa e2       	ldi	r26, 0x2A	; 42
     e32:	b0 e0       	ldi	r27, 0x00	; 0
     e34:	ea e2       	ldi	r30, 0x2A	; 42
     e36:	f0 e0       	ldi	r31, 0x00	; 0
     e38:	80 81       	ld	r24, Z
     e3a:	8f 77       	andi	r24, 0x7F	; 127
     e3c:	8c 93       	st	X, r24
#endif

#ifdef USART_EMPTY_REGISTER_INTERRUPT_ENABLE
  CLEAR_BIT(UCSRB, UDRIE); /* Disable Data Register Empty Interrupt */
#endif
}
     e3e:	cf 91       	pop	r28
     e40:	df 91       	pop	r29
     e42:	08 95       	ret

00000e44 <USART_sendCharNonBlocking>:
 * the character if possible. Returns TRUE if successful, otherwise FALSE.
 *
 * @param data Character to be sent.
 * @return boolean TRUE if the character was sent, FALSE if the register was not empty.
 */
boolean USART_sendCharNonBlocking(uint8 data) {
     e44:	df 93       	push	r29
     e46:	cf 93       	push	r28
     e48:	00 d0       	rcall	.+0      	; 0xe4a <USART_sendCharNonBlocking+0x6>
     e4a:	cd b7       	in	r28, 0x3d	; 61
     e4c:	de b7       	in	r29, 0x3e	; 62
     e4e:	89 83       	std	Y+1, r24	; 0x01
	if (USART_DATA_REGISTER_EMPTY()) {
     e50:	eb e2       	ldi	r30, 0x2B	; 43
     e52:	f0 e0       	ldi	r31, 0x00	; 0
     e54:	80 81       	ld	r24, Z
     e56:	80 72       	andi	r24, 0x20	; 32
     e58:	88 23       	and	r24, r24
     e5a:	39 f0       	breq	.+14     	; 0xe6a <USART_sendCharNonBlocking+0x26>
		UDR = data; /* Send data */
     e5c:	ec e2       	ldi	r30, 0x2C	; 44
     e5e:	f0 e0       	ldi	r31, 0x00	; 0
     e60:	89 81       	ldd	r24, Y+1	; 0x01
     e62:	80 83       	st	Z, r24
		return TRUE;
     e64:	81 e0       	ldi	r24, 0x01	; 1
     e66:	8a 83       	std	Y+2, r24	; 0x02
     e68:	01 c0       	rjmp	.+2      	; 0xe6c <USART_sendCharNonBlocking+0x28>
	} else {
		return FALSE; /* Data register is not empty */
     e6a:	1a 82       	std	Y+2, r1	; 0x02
     e6c:	8a 81       	ldd	r24, Y+2	; 0x02
	}
}
     e6e:	0f 90       	pop	r0
     e70:	0f 90       	pop	r0
     e72:	cf 91       	pop	r28
     e74:	df 91       	pop	r29
     e76:	08 95       	ret

00000e78 <USART_receiveCharNonBlocking>:
 * otherwise FALSE.
 *
 * @param ptrData Pointer to store the received character.
 * @return boolean TRUE if a character was received, FALSE otherwise.
 */
boolean USART_receiveCharNonBlocking(uint8 *ptrData) {
     e78:	df 93       	push	r29
     e7a:	cf 93       	push	r28
     e7c:	00 d0       	rcall	.+0      	; 0xe7e <USART_receiveCharNonBlocking+0x6>
     e7e:	00 d0       	rcall	.+0      	; 0xe80 <USART_receiveCharNonBlocking+0x8>
     e80:	cd b7       	in	r28, 0x3d	; 61
     e82:	de b7       	in	r29, 0x3e	; 62
     e84:	9b 83       	std	Y+3, r25	; 0x03
     e86:	8a 83       	std	Y+2, r24	; 0x02
	if (USART_RECEIVE_COMPLETE()) {
     e88:	eb e2       	ldi	r30, 0x2B	; 43
     e8a:	f0 e0       	ldi	r31, 0x00	; 0
     e8c:	80 81       	ld	r24, Z
     e8e:	80 78       	andi	r24, 0x80	; 128
     e90:	88 23       	and	r24, r24
     e92:	69 f0       	breq	.+26     	; 0xeae <USART_receiveCharNonBlocking+0x36>
		volatile uint8 dumpStatus = UCSRA; /* Read status */
     e94:	eb e2       	ldi	r30, 0x2B	; 43
     e96:	f0 e0       	ldi	r31, 0x00	; 0
     e98:	80 81       	ld	r24, Z
     e9a:	89 83       	std	Y+1, r24	; 0x01
		*ptrData = UDR; /* Read received data */
     e9c:	ec e2       	ldi	r30, 0x2C	; 44
     e9e:	f0 e0       	ldi	r31, 0x00	; 0
     ea0:	80 81       	ld	r24, Z
     ea2:	ea 81       	ldd	r30, Y+2	; 0x02
     ea4:	fb 81       	ldd	r31, Y+3	; 0x03
     ea6:	80 83       	st	Z, r24
		return TRUE;
     ea8:	81 e0       	ldi	r24, 0x01	; 1
     eaa:	8c 83       	std	Y+4, r24	; 0x04
     eac:	01 c0       	rjmp	.+2      	; 0xeb0 <USART_receiveCharNonBlocking+0x38>
	} else {
		return FALSE; /* No data received */
     eae:	1c 82       	std	Y+4, r1	; 0x04
     eb0:	8c 81       	ldd	r24, Y+4	; 0x04
	}
}
     eb2:	0f 90       	pop	r0
     eb4:	0f 90       	pop	r0
     eb6:	0f 90       	pop	r0
     eb8:	0f 90       	pop	r0
     eba:	cf 91       	pop	r28
     ebc:	df 91       	pop	r29
     ebe:	08 95       	ret

00000ec0 <USART_sendCharBlocking>:
 *
 * This function continuously attempts to send a character until successful.
 *
 * @param data Character to be sent.
 */
void USART_sendCharBlocking(uint8 data) {
     ec0:	df 93       	push	r29
     ec2:	cf 93       	push	r28
     ec4:	0f 92       	push	r0
     ec6:	cd b7       	in	r28, 0x3d	; 61
     ec8:	de b7       	in	r29, 0x3e	; 62
     eca:	89 83       	std	Y+1, r24	; 0x01
	while (FALSE == USART_sendCharNonBlocking(data))
     ecc:	89 81       	ldd	r24, Y+1	; 0x01
     ece:	0e 94 22 07 	call	0xe44	; 0xe44 <USART_sendCharNonBlocking>
     ed2:	88 23       	and	r24, r24
     ed4:	d9 f3       	breq	.-10     	; 0xecc <USART_sendCharBlocking+0xc>
		; /* Wait until character is sent */
}
     ed6:	0f 90       	pop	r0
     ed8:	cf 91       	pop	r28
     eda:	df 91       	pop	r29
     edc:	08 95       	ret

00000ede <USART_sendStringBlocking>:
 * This function sends a string of characters until the null terminator
 * is encountered or a carriage return is found.
 *
 * @param strData Pointer to the string to be sent.
 */
void USART_sendStringBlocking(uint8 *strData) {
     ede:	df 93       	push	r29
     ee0:	cf 93       	push	r28
     ee2:	00 d0       	rcall	.+0      	; 0xee4 <USART_sendStringBlocking+0x6>
     ee4:	cd b7       	in	r28, 0x3d	; 61
     ee6:	de b7       	in	r29, 0x3e	; 62
     ee8:	9a 83       	std	Y+2, r25	; 0x02
     eea:	89 83       	std	Y+1, r24	; 0x01
     eec:	0f c0       	rjmp	.+30     	; 0xf0c <USART_sendStringBlocking+0x2e>
	while (*strData != '\0') {
		USART_sendCharBlocking(*strData); /* Send each character */
     eee:	e9 81       	ldd	r30, Y+1	; 0x01
     ef0:	fa 81       	ldd	r31, Y+2	; 0x02
     ef2:	80 81       	ld	r24, Z
     ef4:	0e 94 60 07 	call	0xec0	; 0xec0 <USART_sendCharBlocking>
		if (*strData == '#')
     ef8:	e9 81       	ldd	r30, Y+1	; 0x01
     efa:	fa 81       	ldd	r31, Y+2	; 0x02
     efc:	80 81       	ld	r24, Z
     efe:	83 32       	cpi	r24, 0x23	; 35
     f00:	51 f0       	breq	.+20     	; 0xf16 <USART_sendStringBlocking+0x38>
			break; /*Stop sending if carriage return is found*/
		else
			strData++; /* Move to the next character */
     f02:	89 81       	ldd	r24, Y+1	; 0x01
     f04:	9a 81       	ldd	r25, Y+2	; 0x02
     f06:	01 96       	adiw	r24, 0x01	; 1
     f08:	9a 83       	std	Y+2, r25	; 0x02
     f0a:	89 83       	std	Y+1, r24	; 0x01
 * is encountered or a carriage return is found.
 *
 * @param strData Pointer to the string to be sent.
 */
void USART_sendStringBlocking(uint8 *strData) {
	while (*strData != '\0') {
     f0c:	e9 81       	ldd	r30, Y+1	; 0x01
     f0e:	fa 81       	ldd	r31, Y+2	; 0x02
     f10:	80 81       	ld	r24, Z
     f12:	88 23       	and	r24, r24
     f14:	61 f7       	brne	.-40     	; 0xeee <USART_sendStringBlocking+0x10>
		if (*strData == '#')
			break; /*Stop sending if carriage return is found*/
		else
			strData++; /* Move to the next character */
	}
}
     f16:	0f 90       	pop	r0
     f18:	0f 90       	pop	r0
     f1a:	cf 91       	pop	r28
     f1c:	df 91       	pop	r29
     f1e:	08 95       	ret

00000f20 <USART_receiveCharBlocking>:
 *
 * This function continuously attempts to receive a character until successful.
 *
 * @param ptrData Pointer to store the received character.
 */
void USART_receiveCharBlocking(uint8 *ptrData) {
     f20:	df 93       	push	r29
     f22:	cf 93       	push	r28
     f24:	00 d0       	rcall	.+0      	; 0xf26 <USART_receiveCharBlocking+0x6>
     f26:	cd b7       	in	r28, 0x3d	; 61
     f28:	de b7       	in	r29, 0x3e	; 62
     f2a:	9a 83       	std	Y+2, r25	; 0x02
     f2c:	89 83       	std	Y+1, r24	; 0x01
	while (FALSE == USART_receiveCharNonBlocking(ptrData))
     f2e:	89 81       	ldd	r24, Y+1	; 0x01
     f30:	9a 81       	ldd	r25, Y+2	; 0x02
     f32:	0e 94 3c 07 	call	0xe78	; 0xe78 <USART_receiveCharNonBlocking>
     f36:	88 23       	and	r24, r24
     f38:	d1 f3       	breq	.-12     	; 0xf2e <USART_receiveCharBlocking+0xe>
		; /* Wait until character is received */
}
     f3a:	0f 90       	pop	r0
     f3c:	0f 90       	pop	r0
     f3e:	cf 91       	pop	r28
     f40:	df 91       	pop	r29
     f42:	08 95       	ret

00000f44 <USART_recieveStringBlocking>:
 * length or until a null terminator or carriage return is found.
 *
 * @param ptrStrData Pointer to store the received string.
 * @param length Maximum length of the string to receive.
 */
void USART_recieveStringBlocking(uint8 *ptrStrData, uint8 length) {
     f44:	df 93       	push	r29
     f46:	cf 93       	push	r28
     f48:	00 d0       	rcall	.+0      	; 0xf4a <USART_recieveStringBlocking+0x6>
     f4a:	00 d0       	rcall	.+0      	; 0xf4c <USART_recieveStringBlocking+0x8>
     f4c:	cd b7       	in	r28, 0x3d	; 61
     f4e:	de b7       	in	r29, 0x3e	; 62
     f50:	9b 83       	std	Y+3, r25	; 0x03
     f52:	8a 83       	std	Y+2, r24	; 0x02
     f54:	6c 83       	std	Y+4, r22	; 0x04
	uint8 len = 0;
     f56:	19 82       	std	Y+1, r1	; 0x01
	do {
		USART_receiveCharBlocking(&ptrStrData[len++]); /* Receive each character */
     f58:	89 81       	ldd	r24, Y+1	; 0x01
     f5a:	28 2f       	mov	r18, r24
     f5c:	30 e0       	ldi	r19, 0x00	; 0
     f5e:	8a 81       	ldd	r24, Y+2	; 0x02
     f60:	9b 81       	ldd	r25, Y+3	; 0x03
     f62:	28 0f       	add	r18, r24
     f64:	39 1f       	adc	r19, r25
     f66:	89 81       	ldd	r24, Y+1	; 0x01
     f68:	8f 5f       	subi	r24, 0xFF	; 255
     f6a:	89 83       	std	Y+1, r24	; 0x01
     f6c:	c9 01       	movw	r24, r18
     f6e:	0e 94 90 07 	call	0xf20	; 0xf20 <USART_receiveCharBlocking>
	} while (length > len && ptrStrData[len - 1] != '\0'
			&& ptrStrData[len - 1] != '#');
     f72:	9c 81       	ldd	r25, Y+4	; 0x04
     f74:	89 81       	ldd	r24, Y+1	; 0x01
     f76:	89 17       	cp	r24, r25
     f78:	e0 f4       	brcc	.+56     	; 0xfb2 <USART_recieveStringBlocking+0x6e>
     f7a:	89 81       	ldd	r24, Y+1	; 0x01
     f7c:	88 2f       	mov	r24, r24
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	9c 01       	movw	r18, r24
     f82:	21 50       	subi	r18, 0x01	; 1
     f84:	30 40       	sbci	r19, 0x00	; 0
     f86:	8a 81       	ldd	r24, Y+2	; 0x02
     f88:	9b 81       	ldd	r25, Y+3	; 0x03
     f8a:	fc 01       	movw	r30, r24
     f8c:	e2 0f       	add	r30, r18
     f8e:	f3 1f       	adc	r31, r19
     f90:	80 81       	ld	r24, Z
     f92:	88 23       	and	r24, r24
     f94:	71 f0       	breq	.+28     	; 0xfb2 <USART_recieveStringBlocking+0x6e>
     f96:	89 81       	ldd	r24, Y+1	; 0x01
     f98:	88 2f       	mov	r24, r24
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	9c 01       	movw	r18, r24
     f9e:	21 50       	subi	r18, 0x01	; 1
     fa0:	30 40       	sbci	r19, 0x00	; 0
     fa2:	8a 81       	ldd	r24, Y+2	; 0x02
     fa4:	9b 81       	ldd	r25, Y+3	; 0x03
     fa6:	fc 01       	movw	r30, r24
     fa8:	e2 0f       	add	r30, r18
     faa:	f3 1f       	adc	r31, r19
     fac:	80 81       	ld	r24, Z
     fae:	83 32       	cpi	r24, 0x23	; 35
     fb0:	99 f6       	brne	.-90     	; 0xf58 <USART_recieveStringBlocking+0x14>
}
     fb2:	0f 90       	pop	r0
     fb4:	0f 90       	pop	r0
     fb6:	0f 90       	pop	r0
     fb8:	0f 90       	pop	r0
     fba:	cf 91       	pop	r28
     fbc:	df 91       	pop	r29
     fbe:	08 95       	ret

00000fc0 <USART_setRXCompleteInterruptHandler>:
 * This function assigns a callback function to be executed when the
 * RX Complete interrupt occurs.
 *
 * @param rxCompleteInterruptHandler Pointer to the callback function.
 */
void USART_setRXCompleteInterruptHandler(void (*rxCompleteInterruptHandler)(void)) {
     fc0:	df 93       	push	r29
     fc2:	cf 93       	push	r28
     fc4:	00 d0       	rcall	.+0      	; 0xfc6 <USART_setRXCompleteInterruptHandler+0x6>
     fc6:	cd b7       	in	r28, 0x3d	; 61
     fc8:	de b7       	in	r29, 0x3e	; 62
     fca:	9a 83       	std	Y+2, r25	; 0x02
     fcc:	89 83       	std	Y+1, r24	; 0x01
  USART_rxCompleteInterruptHandler = rxCompleteInterruptHandler; /* Set handler */
     fce:	89 81       	ldd	r24, Y+1	; 0x01
     fd0:	9a 81       	ldd	r25, Y+2	; 0x02
     fd2:	90 93 95 01 	sts	0x0195, r25
     fd6:	80 93 94 01 	sts	0x0194, r24
}
     fda:	0f 90       	pop	r0
     fdc:	0f 90       	pop	r0
     fde:	cf 91       	pop	r28
     fe0:	df 91       	pop	r29
     fe2:	08 95       	ret

00000fe4 <__vector_13>:
 * @brief USART RX Complete interrupt service routine.
 *
 * This function is called when a byte is received. It invokes the
 * registered RX Complete interrupt handler if one is set.
 */
ISR(USART_RXC_vect) {
     fe4:	1f 92       	push	r1
     fe6:	0f 92       	push	r0
     fe8:	0f b6       	in	r0, 0x3f	; 63
     fea:	0f 92       	push	r0
     fec:	11 24       	eor	r1, r1
     fee:	2f 93       	push	r18
     ff0:	3f 93       	push	r19
     ff2:	4f 93       	push	r20
     ff4:	5f 93       	push	r21
     ff6:	6f 93       	push	r22
     ff8:	7f 93       	push	r23
     ffa:	8f 93       	push	r24
     ffc:	9f 93       	push	r25
     ffe:	af 93       	push	r26
    1000:	bf 93       	push	r27
    1002:	ef 93       	push	r30
    1004:	ff 93       	push	r31
    1006:	df 93       	push	r29
    1008:	cf 93       	push	r28
    100a:	cd b7       	in	r28, 0x3d	; 61
    100c:	de b7       	in	r29, 0x3e	; 62
  if (USART_rxCompleteInterruptHandler != NULL_PTR)
    100e:	80 91 94 01 	lds	r24, 0x0194
    1012:	90 91 95 01 	lds	r25, 0x0195
    1016:	00 97       	sbiw	r24, 0x00	; 0
    1018:	29 f0       	breq	.+10     	; 0x1024 <__vector_13+0x40>
    USART_rxCompleteInterruptHandler(); /* Call handler */
    101a:	e0 91 94 01 	lds	r30, 0x0194
    101e:	f0 91 95 01 	lds	r31, 0x0195
    1022:	09 95       	icall
}
    1024:	cf 91       	pop	r28
    1026:	df 91       	pop	r29
    1028:	ff 91       	pop	r31
    102a:	ef 91       	pop	r30
    102c:	bf 91       	pop	r27
    102e:	af 91       	pop	r26
    1030:	9f 91       	pop	r25
    1032:	8f 91       	pop	r24
    1034:	7f 91       	pop	r23
    1036:	6f 91       	pop	r22
    1038:	5f 91       	pop	r21
    103a:	4f 91       	pop	r20
    103c:	3f 91       	pop	r19
    103e:	2f 91       	pop	r18
    1040:	0f 90       	pop	r0
    1042:	0f be       	out	0x3f, r0	; 63
    1044:	0f 90       	pop	r0
    1046:	1f 90       	pop	r1
    1048:	18 95       	reti

0000104a <GPIO_setupPinDirection>:
 * @param port_num Port number (0 to NUM_OF_PORTS-1)
 * @param pin_num Pin number (0 to NUM_OF_PINS_PER_PORT-1)
 * @param direction Direction of the pin (PIN_INPUT or PIN_OUTPUT)
 */
void GPIO_setupPinDirection (uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    104a:	df 93       	push	r29
    104c:	cf 93       	push	r28
    104e:	00 d0       	rcall	.+0      	; 0x1050 <GPIO_setupPinDirection+0x6>
    1050:	00 d0       	rcall	.+0      	; 0x1052 <GPIO_setupPinDirection+0x8>
    1052:	0f 92       	push	r0
    1054:	cd b7       	in	r28, 0x3d	; 61
    1056:	de b7       	in	r29, 0x3e	; 62
    1058:	89 83       	std	Y+1, r24	; 0x01
    105a:	6a 83       	std	Y+2, r22	; 0x02
    105c:	4b 83       	std	Y+3, r20	; 0x03
  /* Check if the input port or pin number is invalid */
  if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    105e:	8a 81       	ldd	r24, Y+2	; 0x02
    1060:	88 30       	cpi	r24, 0x08	; 8
    1062:	08 f0       	brcs	.+2      	; 0x1066 <GPIO_setupPinDirection+0x1c>
    1064:	d5 c0       	rjmp	.+426    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
    1066:	89 81       	ldd	r24, Y+1	; 0x01
    1068:	84 30       	cpi	r24, 0x04	; 4
    106a:	08 f0       	brcs	.+2      	; 0x106e <GPIO_setupPinDirection+0x24>
    106c:	d1 c0       	rjmp	.+418    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
      /* Do Nothing */
    }
  else
    {
      /* Setup the pin direction as required */
      switch (port_num)
    106e:	89 81       	ldd	r24, Y+1	; 0x01
    1070:	28 2f       	mov	r18, r24
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	3d 83       	std	Y+5, r19	; 0x05
    1076:	2c 83       	std	Y+4, r18	; 0x04
    1078:	8c 81       	ldd	r24, Y+4	; 0x04
    107a:	9d 81       	ldd	r25, Y+5	; 0x05
    107c:	81 30       	cpi	r24, 0x01	; 1
    107e:	91 05       	cpc	r25, r1
    1080:	09 f4       	brne	.+2      	; 0x1084 <GPIO_setupPinDirection+0x3a>
    1082:	43 c0       	rjmp	.+134    	; 0x110a <GPIO_setupPinDirection+0xc0>
    1084:	2c 81       	ldd	r18, Y+4	; 0x04
    1086:	3d 81       	ldd	r19, Y+5	; 0x05
    1088:	22 30       	cpi	r18, 0x02	; 2
    108a:	31 05       	cpc	r19, r1
    108c:	2c f4       	brge	.+10     	; 0x1098 <GPIO_setupPinDirection+0x4e>
    108e:	8c 81       	ldd	r24, Y+4	; 0x04
    1090:	9d 81       	ldd	r25, Y+5	; 0x05
    1092:	00 97       	sbiw	r24, 0x00	; 0
    1094:	71 f0       	breq	.+28     	; 0x10b2 <GPIO_setupPinDirection+0x68>
    1096:	bc c0       	rjmp	.+376    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
    1098:	2c 81       	ldd	r18, Y+4	; 0x04
    109a:	3d 81       	ldd	r19, Y+5	; 0x05
    109c:	22 30       	cpi	r18, 0x02	; 2
    109e:	31 05       	cpc	r19, r1
    10a0:	09 f4       	brne	.+2      	; 0x10a4 <GPIO_setupPinDirection+0x5a>
    10a2:	5f c0       	rjmp	.+190    	; 0x1162 <GPIO_setupPinDirection+0x118>
    10a4:	8c 81       	ldd	r24, Y+4	; 0x04
    10a6:	9d 81       	ldd	r25, Y+5	; 0x05
    10a8:	83 30       	cpi	r24, 0x03	; 3
    10aa:	91 05       	cpc	r25, r1
    10ac:	09 f4       	brne	.+2      	; 0x10b0 <GPIO_setupPinDirection+0x66>
    10ae:	85 c0       	rjmp	.+266    	; 0x11ba <GPIO_setupPinDirection+0x170>
    10b0:	af c0       	rjmp	.+350    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
	{
	case PORTA_ID:
	  if (direction == PIN_OUTPUT)
    10b2:	8b 81       	ldd	r24, Y+3	; 0x03
    10b4:	81 30       	cpi	r24, 0x01	; 1
    10b6:	a1 f4       	brne	.+40     	; 0x10e0 <GPIO_setupPinDirection+0x96>
	    {
	      SET_BIT(DDRA, pin_num);
    10b8:	aa e3       	ldi	r26, 0x3A	; 58
    10ba:	b0 e0       	ldi	r27, 0x00	; 0
    10bc:	ea e3       	ldi	r30, 0x3A	; 58
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	80 81       	ld	r24, Z
    10c2:	48 2f       	mov	r20, r24
    10c4:	8a 81       	ldd	r24, Y+2	; 0x02
    10c6:	28 2f       	mov	r18, r24
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	02 2e       	mov	r0, r18
    10d0:	02 c0       	rjmp	.+4      	; 0x10d6 <GPIO_setupPinDirection+0x8c>
    10d2:	88 0f       	add	r24, r24
    10d4:	99 1f       	adc	r25, r25
    10d6:	0a 94       	dec	r0
    10d8:	e2 f7       	brpl	.-8      	; 0x10d2 <GPIO_setupPinDirection+0x88>
    10da:	84 2b       	or	r24, r20
    10dc:	8c 93       	st	X, r24
    10de:	98 c0       	rjmp	.+304    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
	    }
	  else
	    {
	      CLEAR_BIT(DDRA, pin_num);
    10e0:	aa e3       	ldi	r26, 0x3A	; 58
    10e2:	b0 e0       	ldi	r27, 0x00	; 0
    10e4:	ea e3       	ldi	r30, 0x3A	; 58
    10e6:	f0 e0       	ldi	r31, 0x00	; 0
    10e8:	80 81       	ld	r24, Z
    10ea:	48 2f       	mov	r20, r24
    10ec:	8a 81       	ldd	r24, Y+2	; 0x02
    10ee:	28 2f       	mov	r18, r24
    10f0:	30 e0       	ldi	r19, 0x00	; 0
    10f2:	81 e0       	ldi	r24, 0x01	; 1
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	02 2e       	mov	r0, r18
    10f8:	02 c0       	rjmp	.+4      	; 0x10fe <GPIO_setupPinDirection+0xb4>
    10fa:	88 0f       	add	r24, r24
    10fc:	99 1f       	adc	r25, r25
    10fe:	0a 94       	dec	r0
    1100:	e2 f7       	brpl	.-8      	; 0x10fa <GPIO_setupPinDirection+0xb0>
    1102:	80 95       	com	r24
    1104:	84 23       	and	r24, r20
    1106:	8c 93       	st	X, r24
    1108:	83 c0       	rjmp	.+262    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
	    }
	  break;
	case PORTB_ID:
	  if (direction == PIN_OUTPUT)
    110a:	8b 81       	ldd	r24, Y+3	; 0x03
    110c:	81 30       	cpi	r24, 0x01	; 1
    110e:	a1 f4       	brne	.+40     	; 0x1138 <GPIO_setupPinDirection+0xee>
	    {
	      SET_BIT(DDRB, pin_num);
    1110:	a7 e3       	ldi	r26, 0x37	; 55
    1112:	b0 e0       	ldi	r27, 0x00	; 0
    1114:	e7 e3       	ldi	r30, 0x37	; 55
    1116:	f0 e0       	ldi	r31, 0x00	; 0
    1118:	80 81       	ld	r24, Z
    111a:	48 2f       	mov	r20, r24
    111c:	8a 81       	ldd	r24, Y+2	; 0x02
    111e:	28 2f       	mov	r18, r24
    1120:	30 e0       	ldi	r19, 0x00	; 0
    1122:	81 e0       	ldi	r24, 0x01	; 1
    1124:	90 e0       	ldi	r25, 0x00	; 0
    1126:	02 2e       	mov	r0, r18
    1128:	02 c0       	rjmp	.+4      	; 0x112e <GPIO_setupPinDirection+0xe4>
    112a:	88 0f       	add	r24, r24
    112c:	99 1f       	adc	r25, r25
    112e:	0a 94       	dec	r0
    1130:	e2 f7       	brpl	.-8      	; 0x112a <GPIO_setupPinDirection+0xe0>
    1132:	84 2b       	or	r24, r20
    1134:	8c 93       	st	X, r24
    1136:	6c c0       	rjmp	.+216    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
	    }
	  else
	    {
	      CLEAR_BIT(DDRB, pin_num);
    1138:	a7 e3       	ldi	r26, 0x37	; 55
    113a:	b0 e0       	ldi	r27, 0x00	; 0
    113c:	e7 e3       	ldi	r30, 0x37	; 55
    113e:	f0 e0       	ldi	r31, 0x00	; 0
    1140:	80 81       	ld	r24, Z
    1142:	48 2f       	mov	r20, r24
    1144:	8a 81       	ldd	r24, Y+2	; 0x02
    1146:	28 2f       	mov	r18, r24
    1148:	30 e0       	ldi	r19, 0x00	; 0
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	02 2e       	mov	r0, r18
    1150:	02 c0       	rjmp	.+4      	; 0x1156 <GPIO_setupPinDirection+0x10c>
    1152:	88 0f       	add	r24, r24
    1154:	99 1f       	adc	r25, r25
    1156:	0a 94       	dec	r0
    1158:	e2 f7       	brpl	.-8      	; 0x1152 <GPIO_setupPinDirection+0x108>
    115a:	80 95       	com	r24
    115c:	84 23       	and	r24, r20
    115e:	8c 93       	st	X, r24
    1160:	57 c0       	rjmp	.+174    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
	    }
	  break;
	case PORTC_ID:
	  if (direction == PIN_OUTPUT)
    1162:	8b 81       	ldd	r24, Y+3	; 0x03
    1164:	81 30       	cpi	r24, 0x01	; 1
    1166:	a1 f4       	brne	.+40     	; 0x1190 <GPIO_setupPinDirection+0x146>
	    {
	      SET_BIT(DDRC, pin_num);
    1168:	a4 e3       	ldi	r26, 0x34	; 52
    116a:	b0 e0       	ldi	r27, 0x00	; 0
    116c:	e4 e3       	ldi	r30, 0x34	; 52
    116e:	f0 e0       	ldi	r31, 0x00	; 0
    1170:	80 81       	ld	r24, Z
    1172:	48 2f       	mov	r20, r24
    1174:	8a 81       	ldd	r24, Y+2	; 0x02
    1176:	28 2f       	mov	r18, r24
    1178:	30 e0       	ldi	r19, 0x00	; 0
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	90 e0       	ldi	r25, 0x00	; 0
    117e:	02 2e       	mov	r0, r18
    1180:	02 c0       	rjmp	.+4      	; 0x1186 <GPIO_setupPinDirection+0x13c>
    1182:	88 0f       	add	r24, r24
    1184:	99 1f       	adc	r25, r25
    1186:	0a 94       	dec	r0
    1188:	e2 f7       	brpl	.-8      	; 0x1182 <GPIO_setupPinDirection+0x138>
    118a:	84 2b       	or	r24, r20
    118c:	8c 93       	st	X, r24
    118e:	40 c0       	rjmp	.+128    	; 0x1210 <GPIO_setupPinDirection+0x1c6>
	    }
	  else
	    {
	      CLEAR_BIT(DDRC, pin_num);
    1190:	a4 e3       	ldi	r26, 0x34	; 52
    1192:	b0 e0       	ldi	r27, 0x00	; 0
    1194:	e4 e3       	ldi	r30, 0x34	; 52
    1196:	f0 e0       	ldi	r31, 0x00	; 0
    1198:	80 81       	ld	r24, Z
    119a:	48 2f       	mov	r20, r24
    119c:	8a 81       	ldd	r24, Y+2	; 0x02
    119e:	28 2f       	mov	r18, r24
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	81 e0       	ldi	r24, 0x01	; 1
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	02 2e       	mov	r0, r18
    11a8:	02 c0       	rjmp	.+4      	; 0x11ae <GPIO_setupPinDirection+0x164>
    11aa:	88 0f       	add	r24, r24
    11ac:	99 1f       	adc	r25, r25
    11ae:	0a 94       	dec	r0
    11b0:	e2 f7       	brpl	.-8      	; 0x11aa <GPIO_setupPinDirection+0x160>
    11b2:	80 95       	com	r24
    11b4:	84 23       	and	r24, r20
    11b6:	8c 93       	st	X, r24
    11b8:	2b c0       	rjmp	.+86     	; 0x1210 <GPIO_setupPinDirection+0x1c6>
	    }
	  break;
	case PORTD_ID:
	  if (direction == PIN_OUTPUT)
    11ba:	8b 81       	ldd	r24, Y+3	; 0x03
    11bc:	81 30       	cpi	r24, 0x01	; 1
    11be:	a1 f4       	brne	.+40     	; 0x11e8 <GPIO_setupPinDirection+0x19e>
	    {
	      SET_BIT(DDRD, pin_num);
    11c0:	a1 e3       	ldi	r26, 0x31	; 49
    11c2:	b0 e0       	ldi	r27, 0x00	; 0
    11c4:	e1 e3       	ldi	r30, 0x31	; 49
    11c6:	f0 e0       	ldi	r31, 0x00	; 0
    11c8:	80 81       	ld	r24, Z
    11ca:	48 2f       	mov	r20, r24
    11cc:	8a 81       	ldd	r24, Y+2	; 0x02
    11ce:	28 2f       	mov	r18, r24
    11d0:	30 e0       	ldi	r19, 0x00	; 0
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	02 2e       	mov	r0, r18
    11d8:	02 c0       	rjmp	.+4      	; 0x11de <GPIO_setupPinDirection+0x194>
    11da:	88 0f       	add	r24, r24
    11dc:	99 1f       	adc	r25, r25
    11de:	0a 94       	dec	r0
    11e0:	e2 f7       	brpl	.-8      	; 0x11da <GPIO_setupPinDirection+0x190>
    11e2:	84 2b       	or	r24, r20
    11e4:	8c 93       	st	X, r24
    11e6:	14 c0       	rjmp	.+40     	; 0x1210 <GPIO_setupPinDirection+0x1c6>
	    }
	  else
	    {
	      CLEAR_BIT(DDRD, pin_num);
    11e8:	a1 e3       	ldi	r26, 0x31	; 49
    11ea:	b0 e0       	ldi	r27, 0x00	; 0
    11ec:	e1 e3       	ldi	r30, 0x31	; 49
    11ee:	f0 e0       	ldi	r31, 0x00	; 0
    11f0:	80 81       	ld	r24, Z
    11f2:	48 2f       	mov	r20, r24
    11f4:	8a 81       	ldd	r24, Y+2	; 0x02
    11f6:	28 2f       	mov	r18, r24
    11f8:	30 e0       	ldi	r19, 0x00	; 0
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	90 e0       	ldi	r25, 0x00	; 0
    11fe:	02 2e       	mov	r0, r18
    1200:	02 c0       	rjmp	.+4      	; 0x1206 <GPIO_setupPinDirection+0x1bc>
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	0a 94       	dec	r0
    1208:	e2 f7       	brpl	.-8      	; 0x1202 <GPIO_setupPinDirection+0x1b8>
    120a:	80 95       	com	r24
    120c:	84 23       	and	r24, r20
    120e:	8c 93       	st	X, r24
	    }
	  break;
	}
    }
}
    1210:	0f 90       	pop	r0
    1212:	0f 90       	pop	r0
    1214:	0f 90       	pop	r0
    1216:	0f 90       	pop	r0
    1218:	0f 90       	pop	r0
    121a:	cf 91       	pop	r28
    121c:	df 91       	pop	r29
    121e:	08 95       	ret

00001220 <GPIO_writePin>:
 * @param port_num Port number (0 to NUM_OF_PORTS-1)
 * @param pin_num Pin number (0 to NUM_OF_PINS_PER_PORT-1)
 * @param value Value to write (LOGIC_HIGH or LOGIC_LOW)
 */
void GPIO_writePin (uint8 port_num, uint8 pin_num, uint8 value)
{
    1220:	df 93       	push	r29
    1222:	cf 93       	push	r28
    1224:	00 d0       	rcall	.+0      	; 0x1226 <GPIO_writePin+0x6>
    1226:	00 d0       	rcall	.+0      	; 0x1228 <GPIO_writePin+0x8>
    1228:	0f 92       	push	r0
    122a:	cd b7       	in	r28, 0x3d	; 61
    122c:	de b7       	in	r29, 0x3e	; 62
    122e:	89 83       	std	Y+1, r24	; 0x01
    1230:	6a 83       	std	Y+2, r22	; 0x02
    1232:	4b 83       	std	Y+3, r20	; 0x03
  /* Check if the input port or pin number is invalid */
  if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1234:	8a 81       	ldd	r24, Y+2	; 0x02
    1236:	88 30       	cpi	r24, 0x08	; 8
    1238:	08 f0       	brcs	.+2      	; 0x123c <GPIO_writePin+0x1c>
    123a:	d5 c0       	rjmp	.+426    	; 0x13e6 <GPIO_writePin+0x1c6>
    123c:	89 81       	ldd	r24, Y+1	; 0x01
    123e:	84 30       	cpi	r24, 0x04	; 4
    1240:	08 f0       	brcs	.+2      	; 0x1244 <GPIO_writePin+0x24>
    1242:	d1 c0       	rjmp	.+418    	; 0x13e6 <GPIO_writePin+0x1c6>
      /* Do Nothing */
    }
  else
    {
      /* Write the pin value as required */
      switch (port_num)
    1244:	89 81       	ldd	r24, Y+1	; 0x01
    1246:	28 2f       	mov	r18, r24
    1248:	30 e0       	ldi	r19, 0x00	; 0
    124a:	3d 83       	std	Y+5, r19	; 0x05
    124c:	2c 83       	std	Y+4, r18	; 0x04
    124e:	8c 81       	ldd	r24, Y+4	; 0x04
    1250:	9d 81       	ldd	r25, Y+5	; 0x05
    1252:	81 30       	cpi	r24, 0x01	; 1
    1254:	91 05       	cpc	r25, r1
    1256:	09 f4       	brne	.+2      	; 0x125a <GPIO_writePin+0x3a>
    1258:	43 c0       	rjmp	.+134    	; 0x12e0 <GPIO_writePin+0xc0>
    125a:	2c 81       	ldd	r18, Y+4	; 0x04
    125c:	3d 81       	ldd	r19, Y+5	; 0x05
    125e:	22 30       	cpi	r18, 0x02	; 2
    1260:	31 05       	cpc	r19, r1
    1262:	2c f4       	brge	.+10     	; 0x126e <GPIO_writePin+0x4e>
    1264:	8c 81       	ldd	r24, Y+4	; 0x04
    1266:	9d 81       	ldd	r25, Y+5	; 0x05
    1268:	00 97       	sbiw	r24, 0x00	; 0
    126a:	71 f0       	breq	.+28     	; 0x1288 <GPIO_writePin+0x68>
    126c:	bc c0       	rjmp	.+376    	; 0x13e6 <GPIO_writePin+0x1c6>
    126e:	2c 81       	ldd	r18, Y+4	; 0x04
    1270:	3d 81       	ldd	r19, Y+5	; 0x05
    1272:	22 30       	cpi	r18, 0x02	; 2
    1274:	31 05       	cpc	r19, r1
    1276:	09 f4       	brne	.+2      	; 0x127a <GPIO_writePin+0x5a>
    1278:	5f c0       	rjmp	.+190    	; 0x1338 <GPIO_writePin+0x118>
    127a:	8c 81       	ldd	r24, Y+4	; 0x04
    127c:	9d 81       	ldd	r25, Y+5	; 0x05
    127e:	83 30       	cpi	r24, 0x03	; 3
    1280:	91 05       	cpc	r25, r1
    1282:	09 f4       	brne	.+2      	; 0x1286 <GPIO_writePin+0x66>
    1284:	85 c0       	rjmp	.+266    	; 0x1390 <GPIO_writePin+0x170>
    1286:	af c0       	rjmp	.+350    	; 0x13e6 <GPIO_writePin+0x1c6>
	{
	case PORTA_ID:
	  if (value == LOGIC_HIGH)
    1288:	8b 81       	ldd	r24, Y+3	; 0x03
    128a:	81 30       	cpi	r24, 0x01	; 1
    128c:	a1 f4       	brne	.+40     	; 0x12b6 <GPIO_writePin+0x96>
	    {
	      SET_BIT(PORTA, pin_num);
    128e:	ab e3       	ldi	r26, 0x3B	; 59
    1290:	b0 e0       	ldi	r27, 0x00	; 0
    1292:	eb e3       	ldi	r30, 0x3B	; 59
    1294:	f0 e0       	ldi	r31, 0x00	; 0
    1296:	80 81       	ld	r24, Z
    1298:	48 2f       	mov	r20, r24
    129a:	8a 81       	ldd	r24, Y+2	; 0x02
    129c:	28 2f       	mov	r18, r24
    129e:	30 e0       	ldi	r19, 0x00	; 0
    12a0:	81 e0       	ldi	r24, 0x01	; 1
    12a2:	90 e0       	ldi	r25, 0x00	; 0
    12a4:	02 2e       	mov	r0, r18
    12a6:	02 c0       	rjmp	.+4      	; 0x12ac <GPIO_writePin+0x8c>
    12a8:	88 0f       	add	r24, r24
    12aa:	99 1f       	adc	r25, r25
    12ac:	0a 94       	dec	r0
    12ae:	e2 f7       	brpl	.-8      	; 0x12a8 <GPIO_writePin+0x88>
    12b0:	84 2b       	or	r24, r20
    12b2:	8c 93       	st	X, r24
    12b4:	98 c0       	rjmp	.+304    	; 0x13e6 <GPIO_writePin+0x1c6>
	    }
	  else
	    {
	      CLEAR_BIT(PORTA, pin_num);
    12b6:	ab e3       	ldi	r26, 0x3B	; 59
    12b8:	b0 e0       	ldi	r27, 0x00	; 0
    12ba:	eb e3       	ldi	r30, 0x3B	; 59
    12bc:	f0 e0       	ldi	r31, 0x00	; 0
    12be:	80 81       	ld	r24, Z
    12c0:	48 2f       	mov	r20, r24
    12c2:	8a 81       	ldd	r24, Y+2	; 0x02
    12c4:	28 2f       	mov	r18, r24
    12c6:	30 e0       	ldi	r19, 0x00	; 0
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	02 2e       	mov	r0, r18
    12ce:	02 c0       	rjmp	.+4      	; 0x12d4 <GPIO_writePin+0xb4>
    12d0:	88 0f       	add	r24, r24
    12d2:	99 1f       	adc	r25, r25
    12d4:	0a 94       	dec	r0
    12d6:	e2 f7       	brpl	.-8      	; 0x12d0 <GPIO_writePin+0xb0>
    12d8:	80 95       	com	r24
    12da:	84 23       	and	r24, r20
    12dc:	8c 93       	st	X, r24
    12de:	83 c0       	rjmp	.+262    	; 0x13e6 <GPIO_writePin+0x1c6>
	    }
	  break;
	case PORTB_ID:
	  if (value == LOGIC_HIGH)
    12e0:	8b 81       	ldd	r24, Y+3	; 0x03
    12e2:	81 30       	cpi	r24, 0x01	; 1
    12e4:	a1 f4       	brne	.+40     	; 0x130e <GPIO_writePin+0xee>
	    {
	      SET_BIT(PORTB, pin_num);
    12e6:	a8 e3       	ldi	r26, 0x38	; 56
    12e8:	b0 e0       	ldi	r27, 0x00	; 0
    12ea:	e8 e3       	ldi	r30, 0x38	; 56
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	80 81       	ld	r24, Z
    12f0:	48 2f       	mov	r20, r24
    12f2:	8a 81       	ldd	r24, Y+2	; 0x02
    12f4:	28 2f       	mov	r18, r24
    12f6:	30 e0       	ldi	r19, 0x00	; 0
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	90 e0       	ldi	r25, 0x00	; 0
    12fc:	02 2e       	mov	r0, r18
    12fe:	02 c0       	rjmp	.+4      	; 0x1304 <GPIO_writePin+0xe4>
    1300:	88 0f       	add	r24, r24
    1302:	99 1f       	adc	r25, r25
    1304:	0a 94       	dec	r0
    1306:	e2 f7       	brpl	.-8      	; 0x1300 <GPIO_writePin+0xe0>
    1308:	84 2b       	or	r24, r20
    130a:	8c 93       	st	X, r24
    130c:	6c c0       	rjmp	.+216    	; 0x13e6 <GPIO_writePin+0x1c6>
	    }
	  else
	    {
	      CLEAR_BIT(PORTB, pin_num);
    130e:	a8 e3       	ldi	r26, 0x38	; 56
    1310:	b0 e0       	ldi	r27, 0x00	; 0
    1312:	e8 e3       	ldi	r30, 0x38	; 56
    1314:	f0 e0       	ldi	r31, 0x00	; 0
    1316:	80 81       	ld	r24, Z
    1318:	48 2f       	mov	r20, r24
    131a:	8a 81       	ldd	r24, Y+2	; 0x02
    131c:	28 2f       	mov	r18, r24
    131e:	30 e0       	ldi	r19, 0x00	; 0
    1320:	81 e0       	ldi	r24, 0x01	; 1
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	02 2e       	mov	r0, r18
    1326:	02 c0       	rjmp	.+4      	; 0x132c <GPIO_writePin+0x10c>
    1328:	88 0f       	add	r24, r24
    132a:	99 1f       	adc	r25, r25
    132c:	0a 94       	dec	r0
    132e:	e2 f7       	brpl	.-8      	; 0x1328 <GPIO_writePin+0x108>
    1330:	80 95       	com	r24
    1332:	84 23       	and	r24, r20
    1334:	8c 93       	st	X, r24
    1336:	57 c0       	rjmp	.+174    	; 0x13e6 <GPIO_writePin+0x1c6>
	    }
	  break;
	case PORTC_ID:
	  if (value == LOGIC_HIGH)
    1338:	8b 81       	ldd	r24, Y+3	; 0x03
    133a:	81 30       	cpi	r24, 0x01	; 1
    133c:	a1 f4       	brne	.+40     	; 0x1366 <GPIO_writePin+0x146>
	    {
	      SET_BIT(PORTC, pin_num);
    133e:	a5 e3       	ldi	r26, 0x35	; 53
    1340:	b0 e0       	ldi	r27, 0x00	; 0
    1342:	e5 e3       	ldi	r30, 0x35	; 53
    1344:	f0 e0       	ldi	r31, 0x00	; 0
    1346:	80 81       	ld	r24, Z
    1348:	48 2f       	mov	r20, r24
    134a:	8a 81       	ldd	r24, Y+2	; 0x02
    134c:	28 2f       	mov	r18, r24
    134e:	30 e0       	ldi	r19, 0x00	; 0
    1350:	81 e0       	ldi	r24, 0x01	; 1
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	02 2e       	mov	r0, r18
    1356:	02 c0       	rjmp	.+4      	; 0x135c <GPIO_writePin+0x13c>
    1358:	88 0f       	add	r24, r24
    135a:	99 1f       	adc	r25, r25
    135c:	0a 94       	dec	r0
    135e:	e2 f7       	brpl	.-8      	; 0x1358 <GPIO_writePin+0x138>
    1360:	84 2b       	or	r24, r20
    1362:	8c 93       	st	X, r24
    1364:	40 c0       	rjmp	.+128    	; 0x13e6 <GPIO_writePin+0x1c6>
	    }
	  else
	    {
	      CLEAR_BIT(PORTC, pin_num);
    1366:	a5 e3       	ldi	r26, 0x35	; 53
    1368:	b0 e0       	ldi	r27, 0x00	; 0
    136a:	e5 e3       	ldi	r30, 0x35	; 53
    136c:	f0 e0       	ldi	r31, 0x00	; 0
    136e:	80 81       	ld	r24, Z
    1370:	48 2f       	mov	r20, r24
    1372:	8a 81       	ldd	r24, Y+2	; 0x02
    1374:	28 2f       	mov	r18, r24
    1376:	30 e0       	ldi	r19, 0x00	; 0
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	02 2e       	mov	r0, r18
    137e:	02 c0       	rjmp	.+4      	; 0x1384 <GPIO_writePin+0x164>
    1380:	88 0f       	add	r24, r24
    1382:	99 1f       	adc	r25, r25
    1384:	0a 94       	dec	r0
    1386:	e2 f7       	brpl	.-8      	; 0x1380 <GPIO_writePin+0x160>
    1388:	80 95       	com	r24
    138a:	84 23       	and	r24, r20
    138c:	8c 93       	st	X, r24
    138e:	2b c0       	rjmp	.+86     	; 0x13e6 <GPIO_writePin+0x1c6>
	    }
	  break;
	case PORTD_ID:
	  if (value == LOGIC_HIGH)
    1390:	8b 81       	ldd	r24, Y+3	; 0x03
    1392:	81 30       	cpi	r24, 0x01	; 1
    1394:	a1 f4       	brne	.+40     	; 0x13be <GPIO_writePin+0x19e>
	    {
	      SET_BIT(PORTD, pin_num);
    1396:	a2 e3       	ldi	r26, 0x32	; 50
    1398:	b0 e0       	ldi	r27, 0x00	; 0
    139a:	e2 e3       	ldi	r30, 0x32	; 50
    139c:	f0 e0       	ldi	r31, 0x00	; 0
    139e:	80 81       	ld	r24, Z
    13a0:	48 2f       	mov	r20, r24
    13a2:	8a 81       	ldd	r24, Y+2	; 0x02
    13a4:	28 2f       	mov	r18, r24
    13a6:	30 e0       	ldi	r19, 0x00	; 0
    13a8:	81 e0       	ldi	r24, 0x01	; 1
    13aa:	90 e0       	ldi	r25, 0x00	; 0
    13ac:	02 2e       	mov	r0, r18
    13ae:	02 c0       	rjmp	.+4      	; 0x13b4 <GPIO_writePin+0x194>
    13b0:	88 0f       	add	r24, r24
    13b2:	99 1f       	adc	r25, r25
    13b4:	0a 94       	dec	r0
    13b6:	e2 f7       	brpl	.-8      	; 0x13b0 <GPIO_writePin+0x190>
    13b8:	84 2b       	or	r24, r20
    13ba:	8c 93       	st	X, r24
    13bc:	14 c0       	rjmp	.+40     	; 0x13e6 <GPIO_writePin+0x1c6>
	    }
	  else
	    {
	      CLEAR_BIT(PORTD, pin_num);
    13be:	a2 e3       	ldi	r26, 0x32	; 50
    13c0:	b0 e0       	ldi	r27, 0x00	; 0
    13c2:	e2 e3       	ldi	r30, 0x32	; 50
    13c4:	f0 e0       	ldi	r31, 0x00	; 0
    13c6:	80 81       	ld	r24, Z
    13c8:	48 2f       	mov	r20, r24
    13ca:	8a 81       	ldd	r24, Y+2	; 0x02
    13cc:	28 2f       	mov	r18, r24
    13ce:	30 e0       	ldi	r19, 0x00	; 0
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	90 e0       	ldi	r25, 0x00	; 0
    13d4:	02 2e       	mov	r0, r18
    13d6:	02 c0       	rjmp	.+4      	; 0x13dc <GPIO_writePin+0x1bc>
    13d8:	88 0f       	add	r24, r24
    13da:	99 1f       	adc	r25, r25
    13dc:	0a 94       	dec	r0
    13de:	e2 f7       	brpl	.-8      	; 0x13d8 <GPIO_writePin+0x1b8>
    13e0:	80 95       	com	r24
    13e2:	84 23       	and	r24, r20
    13e4:	8c 93       	st	X, r24
	    }
	  break;
	}
    }
}
    13e6:	0f 90       	pop	r0
    13e8:	0f 90       	pop	r0
    13ea:	0f 90       	pop	r0
    13ec:	0f 90       	pop	r0
    13ee:	0f 90       	pop	r0
    13f0:	cf 91       	pop	r28
    13f2:	df 91       	pop	r29
    13f4:	08 95       	ret

000013f6 <GPIO_togglePin>:
 *
 * @param port_num Port number (0 to NUM_OF_PORTS-1).
 * @param pin_num Pin number (0 to NUM_OF_PINS_PER_PORT-1).
 */
void GPIO_togglePin (uint8 port_num, uint8 pin_num)
{
    13f6:	df 93       	push	r29
    13f8:	cf 93       	push	r28
    13fa:	00 d0       	rcall	.+0      	; 0x13fc <GPIO_togglePin+0x6>
    13fc:	00 d0       	rcall	.+0      	; 0x13fe <GPIO_togglePin+0x8>
    13fe:	cd b7       	in	r28, 0x3d	; 61
    1400:	de b7       	in	r29, 0x3e	; 62
    1402:	89 83       	std	Y+1, r24	; 0x01
    1404:	6a 83       	std	Y+2, r22	; 0x02
  /* Check if the input port or pin number is invalid */
  if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1406:	8a 81       	ldd	r24, Y+2	; 0x02
    1408:	88 30       	cpi	r24, 0x08	; 8
    140a:	08 f0       	brcs	.+2      	; 0x140e <GPIO_togglePin+0x18>
    140c:	72 c0       	rjmp	.+228    	; 0x14f2 <GPIO_togglePin+0xfc>
    140e:	89 81       	ldd	r24, Y+1	; 0x01
    1410:	84 30       	cpi	r24, 0x04	; 4
    1412:	08 f0       	brcs	.+2      	; 0x1416 <GPIO_togglePin+0x20>
    1414:	6e c0       	rjmp	.+220    	; 0x14f2 <GPIO_togglePin+0xfc>
      /* Do Nothing */
    }
  else
    {
      /* Write the pin value as required */
      switch (port_num)
    1416:	89 81       	ldd	r24, Y+1	; 0x01
    1418:	28 2f       	mov	r18, r24
    141a:	30 e0       	ldi	r19, 0x00	; 0
    141c:	3c 83       	std	Y+4, r19	; 0x04
    141e:	2b 83       	std	Y+3, r18	; 0x03
    1420:	8b 81       	ldd	r24, Y+3	; 0x03
    1422:	9c 81       	ldd	r25, Y+4	; 0x04
    1424:	81 30       	cpi	r24, 0x01	; 1
    1426:	91 05       	cpc	r25, r1
    1428:	49 f1       	breq	.+82     	; 0x147c <GPIO_togglePin+0x86>
    142a:	2b 81       	ldd	r18, Y+3	; 0x03
    142c:	3c 81       	ldd	r19, Y+4	; 0x04
    142e:	22 30       	cpi	r18, 0x02	; 2
    1430:	31 05       	cpc	r19, r1
    1432:	2c f4       	brge	.+10     	; 0x143e <GPIO_togglePin+0x48>
    1434:	8b 81       	ldd	r24, Y+3	; 0x03
    1436:	9c 81       	ldd	r25, Y+4	; 0x04
    1438:	00 97       	sbiw	r24, 0x00	; 0
    143a:	61 f0       	breq	.+24     	; 0x1454 <GPIO_togglePin+0x5e>
    143c:	5a c0       	rjmp	.+180    	; 0x14f2 <GPIO_togglePin+0xfc>
    143e:	2b 81       	ldd	r18, Y+3	; 0x03
    1440:	3c 81       	ldd	r19, Y+4	; 0x04
    1442:	22 30       	cpi	r18, 0x02	; 2
    1444:	31 05       	cpc	r19, r1
    1446:	71 f1       	breq	.+92     	; 0x14a4 <GPIO_togglePin+0xae>
    1448:	8b 81       	ldd	r24, Y+3	; 0x03
    144a:	9c 81       	ldd	r25, Y+4	; 0x04
    144c:	83 30       	cpi	r24, 0x03	; 3
    144e:	91 05       	cpc	r25, r1
    1450:	e9 f1       	breq	.+122    	; 0x14cc <GPIO_togglePin+0xd6>
    1452:	4f c0       	rjmp	.+158    	; 0x14f2 <GPIO_togglePin+0xfc>
	{
	case PORTA_ID:
	  TOGGLE_BIT(PORTA, pin_num);
    1454:	ab e3       	ldi	r26, 0x3B	; 59
    1456:	b0 e0       	ldi	r27, 0x00	; 0
    1458:	eb e3       	ldi	r30, 0x3B	; 59
    145a:	f0 e0       	ldi	r31, 0x00	; 0
    145c:	80 81       	ld	r24, Z
    145e:	48 2f       	mov	r20, r24
    1460:	8a 81       	ldd	r24, Y+2	; 0x02
    1462:	28 2f       	mov	r18, r24
    1464:	30 e0       	ldi	r19, 0x00	; 0
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	02 2e       	mov	r0, r18
    146c:	02 c0       	rjmp	.+4      	; 0x1472 <GPIO_togglePin+0x7c>
    146e:	88 0f       	add	r24, r24
    1470:	99 1f       	adc	r25, r25
    1472:	0a 94       	dec	r0
    1474:	e2 f7       	brpl	.-8      	; 0x146e <GPIO_togglePin+0x78>
    1476:	84 27       	eor	r24, r20
    1478:	8c 93       	st	X, r24
    147a:	3b c0       	rjmp	.+118    	; 0x14f2 <GPIO_togglePin+0xfc>
	  break;
	case PORTB_ID:
	  TOGGLE_BIT(PORTB, pin_num);
    147c:	a8 e3       	ldi	r26, 0x38	; 56
    147e:	b0 e0       	ldi	r27, 0x00	; 0
    1480:	e8 e3       	ldi	r30, 0x38	; 56
    1482:	f0 e0       	ldi	r31, 0x00	; 0
    1484:	80 81       	ld	r24, Z
    1486:	48 2f       	mov	r20, r24
    1488:	8a 81       	ldd	r24, Y+2	; 0x02
    148a:	28 2f       	mov	r18, r24
    148c:	30 e0       	ldi	r19, 0x00	; 0
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	90 e0       	ldi	r25, 0x00	; 0
    1492:	02 2e       	mov	r0, r18
    1494:	02 c0       	rjmp	.+4      	; 0x149a <GPIO_togglePin+0xa4>
    1496:	88 0f       	add	r24, r24
    1498:	99 1f       	adc	r25, r25
    149a:	0a 94       	dec	r0
    149c:	e2 f7       	brpl	.-8      	; 0x1496 <GPIO_togglePin+0xa0>
    149e:	84 27       	eor	r24, r20
    14a0:	8c 93       	st	X, r24
    14a2:	27 c0       	rjmp	.+78     	; 0x14f2 <GPIO_togglePin+0xfc>
	  break;
	case PORTC_ID:
	  TOGGLE_BIT(PORTC, pin_num);
    14a4:	a5 e3       	ldi	r26, 0x35	; 53
    14a6:	b0 e0       	ldi	r27, 0x00	; 0
    14a8:	e5 e3       	ldi	r30, 0x35	; 53
    14aa:	f0 e0       	ldi	r31, 0x00	; 0
    14ac:	80 81       	ld	r24, Z
    14ae:	48 2f       	mov	r20, r24
    14b0:	8a 81       	ldd	r24, Y+2	; 0x02
    14b2:	28 2f       	mov	r18, r24
    14b4:	30 e0       	ldi	r19, 0x00	; 0
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	02 2e       	mov	r0, r18
    14bc:	02 c0       	rjmp	.+4      	; 0x14c2 <GPIO_togglePin+0xcc>
    14be:	88 0f       	add	r24, r24
    14c0:	99 1f       	adc	r25, r25
    14c2:	0a 94       	dec	r0
    14c4:	e2 f7       	brpl	.-8      	; 0x14be <GPIO_togglePin+0xc8>
    14c6:	84 27       	eor	r24, r20
    14c8:	8c 93       	st	X, r24
    14ca:	13 c0       	rjmp	.+38     	; 0x14f2 <GPIO_togglePin+0xfc>
	  break;
	case PORTD_ID:
	  TOGGLE_BIT(PORTD, pin_num);
    14cc:	a2 e3       	ldi	r26, 0x32	; 50
    14ce:	b0 e0       	ldi	r27, 0x00	; 0
    14d0:	e2 e3       	ldi	r30, 0x32	; 50
    14d2:	f0 e0       	ldi	r31, 0x00	; 0
    14d4:	80 81       	ld	r24, Z
    14d6:	48 2f       	mov	r20, r24
    14d8:	8a 81       	ldd	r24, Y+2	; 0x02
    14da:	28 2f       	mov	r18, r24
    14dc:	30 e0       	ldi	r19, 0x00	; 0
    14de:	81 e0       	ldi	r24, 0x01	; 1
    14e0:	90 e0       	ldi	r25, 0x00	; 0
    14e2:	02 2e       	mov	r0, r18
    14e4:	02 c0       	rjmp	.+4      	; 0x14ea <GPIO_togglePin+0xf4>
    14e6:	88 0f       	add	r24, r24
    14e8:	99 1f       	adc	r25, r25
    14ea:	0a 94       	dec	r0
    14ec:	e2 f7       	brpl	.-8      	; 0x14e6 <GPIO_togglePin+0xf0>
    14ee:	84 27       	eor	r24, r20
    14f0:	8c 93       	st	X, r24
	  break;
	}
    }
}
    14f2:	0f 90       	pop	r0
    14f4:	0f 90       	pop	r0
    14f6:	0f 90       	pop	r0
    14f8:	0f 90       	pop	r0
    14fa:	cf 91       	pop	r28
    14fc:	df 91       	pop	r29
    14fe:	08 95       	ret

00001500 <GPIO_readPin>:
 * @param pin_num Pin number (0 to NUM_OF_PINS_PER_PORT-1)
 *
 * @return Value of the pin (LOGIC_HIGH or LOGIC_LOW)
 */
uint8 GPIO_readPin (uint8 port_num, uint8 pin_num)
{
    1500:	df 93       	push	r29
    1502:	cf 93       	push	r28
    1504:	00 d0       	rcall	.+0      	; 0x1506 <GPIO_readPin+0x6>
    1506:	00 d0       	rcall	.+0      	; 0x1508 <GPIO_readPin+0x8>
    1508:	0f 92       	push	r0
    150a:	cd b7       	in	r28, 0x3d	; 61
    150c:	de b7       	in	r29, 0x3e	; 62
    150e:	8a 83       	std	Y+2, r24	; 0x02
    1510:	6b 83       	std	Y+3, r22	; 0x03
  uint8 pin_value = LOGIC_LOW;
    1512:	19 82       	std	Y+1, r1	; 0x01

  /* Check if the input port or pin number is invalid */
  if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1514:	8b 81       	ldd	r24, Y+3	; 0x03
    1516:	88 30       	cpi	r24, 0x08	; 8
    1518:	08 f0       	brcs	.+2      	; 0x151c <GPIO_readPin+0x1c>
    151a:	7d c0       	rjmp	.+250    	; 0x1616 <GPIO_readPin+0x116>
    151c:	8a 81       	ldd	r24, Y+2	; 0x02
    151e:	84 30       	cpi	r24, 0x04	; 4
    1520:	08 f0       	brcs	.+2      	; 0x1524 <GPIO_readPin+0x24>
    1522:	79 c0       	rjmp	.+242    	; 0x1616 <GPIO_readPin+0x116>
      /* Do Nothing */
    }
  else
    {
      /* Read the pin value as required */
      switch (port_num)
    1524:	8a 81       	ldd	r24, Y+2	; 0x02
    1526:	28 2f       	mov	r18, r24
    1528:	30 e0       	ldi	r19, 0x00	; 0
    152a:	3d 83       	std	Y+5, r19	; 0x05
    152c:	2c 83       	std	Y+4, r18	; 0x04
    152e:	4c 81       	ldd	r20, Y+4	; 0x04
    1530:	5d 81       	ldd	r21, Y+5	; 0x05
    1532:	41 30       	cpi	r20, 0x01	; 1
    1534:	51 05       	cpc	r21, r1
    1536:	71 f1       	breq	.+92     	; 0x1594 <GPIO_readPin+0x94>
    1538:	8c 81       	ldd	r24, Y+4	; 0x04
    153a:	9d 81       	ldd	r25, Y+5	; 0x05
    153c:	82 30       	cpi	r24, 0x02	; 2
    153e:	91 05       	cpc	r25, r1
    1540:	34 f4       	brge	.+12     	; 0x154e <GPIO_readPin+0x4e>
    1542:	2c 81       	ldd	r18, Y+4	; 0x04
    1544:	3d 81       	ldd	r19, Y+5	; 0x05
    1546:	21 15       	cp	r18, r1
    1548:	31 05       	cpc	r19, r1
    154a:	69 f0       	breq	.+26     	; 0x1566 <GPIO_readPin+0x66>
    154c:	64 c0       	rjmp	.+200    	; 0x1616 <GPIO_readPin+0x116>
    154e:	4c 81       	ldd	r20, Y+4	; 0x04
    1550:	5d 81       	ldd	r21, Y+5	; 0x05
    1552:	42 30       	cpi	r20, 0x02	; 2
    1554:	51 05       	cpc	r21, r1
    1556:	a1 f1       	breq	.+104    	; 0x15c0 <GPIO_readPin+0xc0>
    1558:	8c 81       	ldd	r24, Y+4	; 0x04
    155a:	9d 81       	ldd	r25, Y+5	; 0x05
    155c:	83 30       	cpi	r24, 0x03	; 3
    155e:	91 05       	cpc	r25, r1
    1560:	09 f4       	brne	.+2      	; 0x1564 <GPIO_readPin+0x64>
    1562:	44 c0       	rjmp	.+136    	; 0x15ec <GPIO_readPin+0xec>
    1564:	58 c0       	rjmp	.+176    	; 0x1616 <GPIO_readPin+0x116>
	{
	case PORTA_ID:
	  if (BIT_IS_SET(PINA, pin_num))
    1566:	e9 e3       	ldi	r30, 0x39	; 57
    1568:	f0 e0       	ldi	r31, 0x00	; 0
    156a:	80 81       	ld	r24, Z
    156c:	28 2f       	mov	r18, r24
    156e:	30 e0       	ldi	r19, 0x00	; 0
    1570:	8b 81       	ldd	r24, Y+3	; 0x03
    1572:	88 2f       	mov	r24, r24
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	a9 01       	movw	r20, r18
    1578:	02 c0       	rjmp	.+4      	; 0x157e <GPIO_readPin+0x7e>
    157a:	55 95       	asr	r21
    157c:	47 95       	ror	r20
    157e:	8a 95       	dec	r24
    1580:	e2 f7       	brpl	.-8      	; 0x157a <GPIO_readPin+0x7a>
    1582:	ca 01       	movw	r24, r20
    1584:	81 70       	andi	r24, 0x01	; 1
    1586:	90 70       	andi	r25, 0x00	; 0
    1588:	88 23       	and	r24, r24
    158a:	09 f4       	brne	.+2      	; 0x158e <GPIO_readPin+0x8e>
    158c:	44 c0       	rjmp	.+136    	; 0x1616 <GPIO_readPin+0x116>
	    {
	      pin_value = LOGIC_HIGH;
    158e:	81 e0       	ldi	r24, 0x01	; 1
    1590:	89 83       	std	Y+1, r24	; 0x01
    1592:	41 c0       	rjmp	.+130    	; 0x1616 <GPIO_readPin+0x116>
	    }
	  break;
	case PORTB_ID:
	  if (BIT_IS_SET(PINB, pin_num))
    1594:	e6 e3       	ldi	r30, 0x36	; 54
    1596:	f0 e0       	ldi	r31, 0x00	; 0
    1598:	80 81       	ld	r24, Z
    159a:	28 2f       	mov	r18, r24
    159c:	30 e0       	ldi	r19, 0x00	; 0
    159e:	8b 81       	ldd	r24, Y+3	; 0x03
    15a0:	88 2f       	mov	r24, r24
    15a2:	90 e0       	ldi	r25, 0x00	; 0
    15a4:	a9 01       	movw	r20, r18
    15a6:	02 c0       	rjmp	.+4      	; 0x15ac <GPIO_readPin+0xac>
    15a8:	55 95       	asr	r21
    15aa:	47 95       	ror	r20
    15ac:	8a 95       	dec	r24
    15ae:	e2 f7       	brpl	.-8      	; 0x15a8 <GPIO_readPin+0xa8>
    15b0:	ca 01       	movw	r24, r20
    15b2:	81 70       	andi	r24, 0x01	; 1
    15b4:	90 70       	andi	r25, 0x00	; 0
    15b6:	88 23       	and	r24, r24
    15b8:	71 f1       	breq	.+92     	; 0x1616 <GPIO_readPin+0x116>
	    {
	      pin_value = LOGIC_HIGH;
    15ba:	81 e0       	ldi	r24, 0x01	; 1
    15bc:	89 83       	std	Y+1, r24	; 0x01
    15be:	2b c0       	rjmp	.+86     	; 0x1616 <GPIO_readPin+0x116>
	    }
	  break;
	case PORTC_ID:
	  if (BIT_IS_SET(PINC, pin_num))
    15c0:	e3 e3       	ldi	r30, 0x33	; 51
    15c2:	f0 e0       	ldi	r31, 0x00	; 0
    15c4:	80 81       	ld	r24, Z
    15c6:	28 2f       	mov	r18, r24
    15c8:	30 e0       	ldi	r19, 0x00	; 0
    15ca:	8b 81       	ldd	r24, Y+3	; 0x03
    15cc:	88 2f       	mov	r24, r24
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	a9 01       	movw	r20, r18
    15d2:	02 c0       	rjmp	.+4      	; 0x15d8 <GPIO_readPin+0xd8>
    15d4:	55 95       	asr	r21
    15d6:	47 95       	ror	r20
    15d8:	8a 95       	dec	r24
    15da:	e2 f7       	brpl	.-8      	; 0x15d4 <GPIO_readPin+0xd4>
    15dc:	ca 01       	movw	r24, r20
    15de:	81 70       	andi	r24, 0x01	; 1
    15e0:	90 70       	andi	r25, 0x00	; 0
    15e2:	88 23       	and	r24, r24
    15e4:	c1 f0       	breq	.+48     	; 0x1616 <GPIO_readPin+0x116>
	    {
	      pin_value = LOGIC_HIGH;
    15e6:	81 e0       	ldi	r24, 0x01	; 1
    15e8:	89 83       	std	Y+1, r24	; 0x01
    15ea:	15 c0       	rjmp	.+42     	; 0x1616 <GPIO_readPin+0x116>
	    }
	  break;
	case PORTD_ID:
	  if (BIT_IS_SET(PIND, pin_num))
    15ec:	e0 e3       	ldi	r30, 0x30	; 48
    15ee:	f0 e0       	ldi	r31, 0x00	; 0
    15f0:	80 81       	ld	r24, Z
    15f2:	28 2f       	mov	r18, r24
    15f4:	30 e0       	ldi	r19, 0x00	; 0
    15f6:	8b 81       	ldd	r24, Y+3	; 0x03
    15f8:	88 2f       	mov	r24, r24
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	a9 01       	movw	r20, r18
    15fe:	02 c0       	rjmp	.+4      	; 0x1604 <GPIO_readPin+0x104>
    1600:	55 95       	asr	r21
    1602:	47 95       	ror	r20
    1604:	8a 95       	dec	r24
    1606:	e2 f7       	brpl	.-8      	; 0x1600 <GPIO_readPin+0x100>
    1608:	ca 01       	movw	r24, r20
    160a:	81 70       	andi	r24, 0x01	; 1
    160c:	90 70       	andi	r25, 0x00	; 0
    160e:	88 23       	and	r24, r24
    1610:	11 f0       	breq	.+4      	; 0x1616 <GPIO_readPin+0x116>
	    {
	      pin_value = LOGIC_HIGH;
    1612:	81 e0       	ldi	r24, 0x01	; 1
    1614:	89 83       	std	Y+1, r24	; 0x01
	    }
	  break;
	}
    }

  return pin_value;
    1616:	89 81       	ldd	r24, Y+1	; 0x01
}
    1618:	0f 90       	pop	r0
    161a:	0f 90       	pop	r0
    161c:	0f 90       	pop	r0
    161e:	0f 90       	pop	r0
    1620:	0f 90       	pop	r0
    1622:	cf 91       	pop	r28
    1624:	df 91       	pop	r29
    1626:	08 95       	ret

00001628 <GPIO_setupPortDirection>:
 *
 * @param port_num Port number (0 to NUM_OF_PORTS-1)
 * @param direction Direction of the port (PORT_INPUT or PORT_OUTPUT)
 */
void GPIO_setupPortDirection (uint8 port_num, GPIO_PortDirectionType direction)
{
    1628:	df 93       	push	r29
    162a:	cf 93       	push	r28
    162c:	00 d0       	rcall	.+0      	; 0x162e <GPIO_setupPortDirection+0x6>
    162e:	00 d0       	rcall	.+0      	; 0x1630 <GPIO_setupPortDirection+0x8>
    1630:	cd b7       	in	r28, 0x3d	; 61
    1632:	de b7       	in	r29, 0x3e	; 62
    1634:	89 83       	std	Y+1, r24	; 0x01
    1636:	6a 83       	std	Y+2, r22	; 0x02
  /* Check if the input port number is invalid */
  if (port_num >= NUM_OF_PORTS)
    1638:	89 81       	ldd	r24, Y+1	; 0x01
    163a:	84 30       	cpi	r24, 0x04	; 4
    163c:	90 f5       	brcc	.+100    	; 0x16a2 <GPIO_setupPortDirection+0x7a>
      /* Do Nothing */
    }
  else
    {
      /* Setup the port direction as required */
      switch (port_num)
    163e:	89 81       	ldd	r24, Y+1	; 0x01
    1640:	28 2f       	mov	r18, r24
    1642:	30 e0       	ldi	r19, 0x00	; 0
    1644:	3c 83       	std	Y+4, r19	; 0x04
    1646:	2b 83       	std	Y+3, r18	; 0x03
    1648:	8b 81       	ldd	r24, Y+3	; 0x03
    164a:	9c 81       	ldd	r25, Y+4	; 0x04
    164c:	81 30       	cpi	r24, 0x01	; 1
    164e:	91 05       	cpc	r25, r1
    1650:	d1 f0       	breq	.+52     	; 0x1686 <GPIO_setupPortDirection+0x5e>
    1652:	2b 81       	ldd	r18, Y+3	; 0x03
    1654:	3c 81       	ldd	r19, Y+4	; 0x04
    1656:	22 30       	cpi	r18, 0x02	; 2
    1658:	31 05       	cpc	r19, r1
    165a:	2c f4       	brge	.+10     	; 0x1666 <GPIO_setupPortDirection+0x3e>
    165c:	8b 81       	ldd	r24, Y+3	; 0x03
    165e:	9c 81       	ldd	r25, Y+4	; 0x04
    1660:	00 97       	sbiw	r24, 0x00	; 0
    1662:	61 f0       	breq	.+24     	; 0x167c <GPIO_setupPortDirection+0x54>
    1664:	1e c0       	rjmp	.+60     	; 0x16a2 <GPIO_setupPortDirection+0x7a>
    1666:	2b 81       	ldd	r18, Y+3	; 0x03
    1668:	3c 81       	ldd	r19, Y+4	; 0x04
    166a:	22 30       	cpi	r18, 0x02	; 2
    166c:	31 05       	cpc	r19, r1
    166e:	81 f0       	breq	.+32     	; 0x1690 <GPIO_setupPortDirection+0x68>
    1670:	8b 81       	ldd	r24, Y+3	; 0x03
    1672:	9c 81       	ldd	r25, Y+4	; 0x04
    1674:	83 30       	cpi	r24, 0x03	; 3
    1676:	91 05       	cpc	r25, r1
    1678:	81 f0       	breq	.+32     	; 0x169a <GPIO_setupPortDirection+0x72>
    167a:	13 c0       	rjmp	.+38     	; 0x16a2 <GPIO_setupPortDirection+0x7a>
	{
	case PORTA_ID:
	  DDRA = direction;
    167c:	ea e3       	ldi	r30, 0x3A	; 58
    167e:	f0 e0       	ldi	r31, 0x00	; 0
    1680:	8a 81       	ldd	r24, Y+2	; 0x02
    1682:	80 83       	st	Z, r24
    1684:	0e c0       	rjmp	.+28     	; 0x16a2 <GPIO_setupPortDirection+0x7a>
	  break;
	case PORTB_ID:
	  DDRB = direction;
    1686:	e7 e3       	ldi	r30, 0x37	; 55
    1688:	f0 e0       	ldi	r31, 0x00	; 0
    168a:	8a 81       	ldd	r24, Y+2	; 0x02
    168c:	80 83       	st	Z, r24
    168e:	09 c0       	rjmp	.+18     	; 0x16a2 <GPIO_setupPortDirection+0x7a>
	  break;
	case PORTC_ID:
	  DDRC = direction;
    1690:	e4 e3       	ldi	r30, 0x34	; 52
    1692:	f0 e0       	ldi	r31, 0x00	; 0
    1694:	8a 81       	ldd	r24, Y+2	; 0x02
    1696:	80 83       	st	Z, r24
    1698:	04 c0       	rjmp	.+8      	; 0x16a2 <GPIO_setupPortDirection+0x7a>
	  break;
	case PORTD_ID:
	  DDRD = direction;
    169a:	e1 e3       	ldi	r30, 0x31	; 49
    169c:	f0 e0       	ldi	r31, 0x00	; 0
    169e:	8a 81       	ldd	r24, Y+2	; 0x02
    16a0:	80 83       	st	Z, r24
	  break;
	}
    }
}
    16a2:	0f 90       	pop	r0
    16a4:	0f 90       	pop	r0
    16a6:	0f 90       	pop	r0
    16a8:	0f 90       	pop	r0
    16aa:	cf 91       	pop	r28
    16ac:	df 91       	pop	r29
    16ae:	08 95       	ret

000016b0 <GPIO_writePort>:
 *
 * @param port_num Port number (0 to NUM_OF_PORTS-1)
 * @param value Value to write to the port (0 to 255)
 */
void GPIO_writePort (uint8 port_num, uint8 value)
{
    16b0:	df 93       	push	r29
    16b2:	cf 93       	push	r28
    16b4:	00 d0       	rcall	.+0      	; 0x16b6 <GPIO_writePort+0x6>
    16b6:	00 d0       	rcall	.+0      	; 0x16b8 <GPIO_writePort+0x8>
    16b8:	cd b7       	in	r28, 0x3d	; 61
    16ba:	de b7       	in	r29, 0x3e	; 62
    16bc:	89 83       	std	Y+1, r24	; 0x01
    16be:	6a 83       	std	Y+2, r22	; 0x02
  /* Check if the input port number is invalid */
  if (port_num >= NUM_OF_PORTS)
    16c0:	89 81       	ldd	r24, Y+1	; 0x01
    16c2:	84 30       	cpi	r24, 0x04	; 4
    16c4:	90 f5       	brcc	.+100    	; 0x172a <GPIO_writePort+0x7a>
      /* Do Nothing */
    }
  else
    {
      /* Write the port value as required */
      switch (port_num)
    16c6:	89 81       	ldd	r24, Y+1	; 0x01
    16c8:	28 2f       	mov	r18, r24
    16ca:	30 e0       	ldi	r19, 0x00	; 0
    16cc:	3c 83       	std	Y+4, r19	; 0x04
    16ce:	2b 83       	std	Y+3, r18	; 0x03
    16d0:	8b 81       	ldd	r24, Y+3	; 0x03
    16d2:	9c 81       	ldd	r25, Y+4	; 0x04
    16d4:	81 30       	cpi	r24, 0x01	; 1
    16d6:	91 05       	cpc	r25, r1
    16d8:	d1 f0       	breq	.+52     	; 0x170e <GPIO_writePort+0x5e>
    16da:	2b 81       	ldd	r18, Y+3	; 0x03
    16dc:	3c 81       	ldd	r19, Y+4	; 0x04
    16de:	22 30       	cpi	r18, 0x02	; 2
    16e0:	31 05       	cpc	r19, r1
    16e2:	2c f4       	brge	.+10     	; 0x16ee <GPIO_writePort+0x3e>
    16e4:	8b 81       	ldd	r24, Y+3	; 0x03
    16e6:	9c 81       	ldd	r25, Y+4	; 0x04
    16e8:	00 97       	sbiw	r24, 0x00	; 0
    16ea:	61 f0       	breq	.+24     	; 0x1704 <GPIO_writePort+0x54>
    16ec:	1e c0       	rjmp	.+60     	; 0x172a <GPIO_writePort+0x7a>
    16ee:	2b 81       	ldd	r18, Y+3	; 0x03
    16f0:	3c 81       	ldd	r19, Y+4	; 0x04
    16f2:	22 30       	cpi	r18, 0x02	; 2
    16f4:	31 05       	cpc	r19, r1
    16f6:	81 f0       	breq	.+32     	; 0x1718 <GPIO_writePort+0x68>
    16f8:	8b 81       	ldd	r24, Y+3	; 0x03
    16fa:	9c 81       	ldd	r25, Y+4	; 0x04
    16fc:	83 30       	cpi	r24, 0x03	; 3
    16fe:	91 05       	cpc	r25, r1
    1700:	81 f0       	breq	.+32     	; 0x1722 <GPIO_writePort+0x72>
    1702:	13 c0       	rjmp	.+38     	; 0x172a <GPIO_writePort+0x7a>
	{
	case PORTA_ID:
	  PORTA = value;
    1704:	eb e3       	ldi	r30, 0x3B	; 59
    1706:	f0 e0       	ldi	r31, 0x00	; 0
    1708:	8a 81       	ldd	r24, Y+2	; 0x02
    170a:	80 83       	st	Z, r24
    170c:	0e c0       	rjmp	.+28     	; 0x172a <GPIO_writePort+0x7a>
	  break;
	case PORTB_ID:
	  PORTB = value;
    170e:	e8 e3       	ldi	r30, 0x38	; 56
    1710:	f0 e0       	ldi	r31, 0x00	; 0
    1712:	8a 81       	ldd	r24, Y+2	; 0x02
    1714:	80 83       	st	Z, r24
    1716:	09 c0       	rjmp	.+18     	; 0x172a <GPIO_writePort+0x7a>
	  break;
	case PORTC_ID:
	  PORTC = value;
    1718:	e5 e3       	ldi	r30, 0x35	; 53
    171a:	f0 e0       	ldi	r31, 0x00	; 0
    171c:	8a 81       	ldd	r24, Y+2	; 0x02
    171e:	80 83       	st	Z, r24
    1720:	04 c0       	rjmp	.+8      	; 0x172a <GPIO_writePort+0x7a>
	  break;
	case PORTD_ID:
	  PORTD = value;
    1722:	e2 e3       	ldi	r30, 0x32	; 50
    1724:	f0 e0       	ldi	r31, 0x00	; 0
    1726:	8a 81       	ldd	r24, Y+2	; 0x02
    1728:	80 83       	st	Z, r24
	  break;
	}
    }
}
    172a:	0f 90       	pop	r0
    172c:	0f 90       	pop	r0
    172e:	0f 90       	pop	r0
    1730:	0f 90       	pop	r0
    1732:	cf 91       	pop	r28
    1734:	df 91       	pop	r29
    1736:	08 95       	ret

00001738 <GPIO_readPort>:
 * @param port_num Port number (0 to NUM_OF_PORTS-1)
 *
 * @return Value of the port (0 to 255)
 */
uint8 GPIO_readPort (uint8 port_num)
{
    1738:	df 93       	push	r29
    173a:	cf 93       	push	r28
    173c:	00 d0       	rcall	.+0      	; 0x173e <GPIO_readPort+0x6>
    173e:	00 d0       	rcall	.+0      	; 0x1740 <GPIO_readPort+0x8>
    1740:	cd b7       	in	r28, 0x3d	; 61
    1742:	de b7       	in	r29, 0x3e	; 62
    1744:	8a 83       	std	Y+2, r24	; 0x02
  uint8 value = LOGIC_LOW;
    1746:	19 82       	std	Y+1, r1	; 0x01

  /* Check if the input port number is invalid */
  if (port_num >= NUM_OF_PORTS)
    1748:	8a 81       	ldd	r24, Y+2	; 0x02
    174a:	84 30       	cpi	r24, 0x04	; 4
    174c:	90 f5       	brcc	.+100    	; 0x17b2 <GPIO_readPort+0x7a>
      /* Do Nothing */
    }
  else
    {
      /* Read the port value as required */
      switch (port_num)
    174e:	8a 81       	ldd	r24, Y+2	; 0x02
    1750:	28 2f       	mov	r18, r24
    1752:	30 e0       	ldi	r19, 0x00	; 0
    1754:	3c 83       	std	Y+4, r19	; 0x04
    1756:	2b 83       	std	Y+3, r18	; 0x03
    1758:	8b 81       	ldd	r24, Y+3	; 0x03
    175a:	9c 81       	ldd	r25, Y+4	; 0x04
    175c:	81 30       	cpi	r24, 0x01	; 1
    175e:	91 05       	cpc	r25, r1
    1760:	d1 f0       	breq	.+52     	; 0x1796 <GPIO_readPort+0x5e>
    1762:	2b 81       	ldd	r18, Y+3	; 0x03
    1764:	3c 81       	ldd	r19, Y+4	; 0x04
    1766:	22 30       	cpi	r18, 0x02	; 2
    1768:	31 05       	cpc	r19, r1
    176a:	2c f4       	brge	.+10     	; 0x1776 <GPIO_readPort+0x3e>
    176c:	8b 81       	ldd	r24, Y+3	; 0x03
    176e:	9c 81       	ldd	r25, Y+4	; 0x04
    1770:	00 97       	sbiw	r24, 0x00	; 0
    1772:	61 f0       	breq	.+24     	; 0x178c <GPIO_readPort+0x54>
    1774:	1e c0       	rjmp	.+60     	; 0x17b2 <GPIO_readPort+0x7a>
    1776:	2b 81       	ldd	r18, Y+3	; 0x03
    1778:	3c 81       	ldd	r19, Y+4	; 0x04
    177a:	22 30       	cpi	r18, 0x02	; 2
    177c:	31 05       	cpc	r19, r1
    177e:	81 f0       	breq	.+32     	; 0x17a0 <GPIO_readPort+0x68>
    1780:	8b 81       	ldd	r24, Y+3	; 0x03
    1782:	9c 81       	ldd	r25, Y+4	; 0x04
    1784:	83 30       	cpi	r24, 0x03	; 3
    1786:	91 05       	cpc	r25, r1
    1788:	81 f0       	breq	.+32     	; 0x17aa <GPIO_readPort+0x72>
    178a:	13 c0       	rjmp	.+38     	; 0x17b2 <GPIO_readPort+0x7a>
	{
	case PORTA_ID:
	  value = PINA;
    178c:	e9 e3       	ldi	r30, 0x39	; 57
    178e:	f0 e0       	ldi	r31, 0x00	; 0
    1790:	80 81       	ld	r24, Z
    1792:	89 83       	std	Y+1, r24	; 0x01
    1794:	0e c0       	rjmp	.+28     	; 0x17b2 <GPIO_readPort+0x7a>
	  break;
	case PORTB_ID:
	  value = PINB;
    1796:	e6 e3       	ldi	r30, 0x36	; 54
    1798:	f0 e0       	ldi	r31, 0x00	; 0
    179a:	80 81       	ld	r24, Z
    179c:	89 83       	std	Y+1, r24	; 0x01
    179e:	09 c0       	rjmp	.+18     	; 0x17b2 <GPIO_readPort+0x7a>
	  break;
	case PORTC_ID:
	  value = PINC;
    17a0:	e3 e3       	ldi	r30, 0x33	; 51
    17a2:	f0 e0       	ldi	r31, 0x00	; 0
    17a4:	80 81       	ld	r24, Z
    17a6:	89 83       	std	Y+1, r24	; 0x01
    17a8:	04 c0       	rjmp	.+8      	; 0x17b2 <GPIO_readPort+0x7a>
	  break;
	case PORTD_ID:
	  value = PIND;
    17aa:	e0 e3       	ldi	r30, 0x30	; 48
    17ac:	f0 e0       	ldi	r31, 0x00	; 0
    17ae:	80 81       	ld	r24, Z
    17b0:	89 83       	std	Y+1, r24	; 0x01
	  break;
	}
    }

  return value;
    17b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    17b4:	0f 90       	pop	r0
    17b6:	0f 90       	pop	r0
    17b8:	0f 90       	pop	r0
    17ba:	0f 90       	pop	r0
    17bc:	cf 91       	pop	r28
    17be:	df 91       	pop	r29
    17c0:	08 95       	ret

000017c2 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    17c2:	df 93       	push	r29
    17c4:	cf 93       	push	r28
    17c6:	cd b7       	in	r28, 0x3d	; 61
    17c8:	de b7       	in	r29, 0x3e	; 62
    17ca:	2e 97       	sbiw	r28, 0x0e	; 14
    17cc:	0f b6       	in	r0, 0x3f	; 63
    17ce:	f8 94       	cli
    17d0:	de bf       	out	0x3e, r29	; 62
    17d2:	0f be       	out	0x3f, r0	; 63
    17d4:	cd bf       	out	0x3d, r28	; 61
    17d6:	9e 87       	std	Y+14, r25	; 0x0e
    17d8:	8d 87       	std	Y+13, r24	; 0x0d
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    17da:	1e 82       	std	Y+6, r1	; 0x06
    17dc:	1d 82       	std	Y+5, r1	; 0x05

	vTaskSuspendAll();
    17de:	0e 94 09 1c 	call	0x3812	; 0x3812 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    17e2:	80 91 96 01 	lds	r24, 0x0196
    17e6:	88 23       	and	r24, r24
    17e8:	29 f4       	brne	.+10     	; 0x17f4 <pvPortMalloc+0x32>
		{
			prvHeapInit();
    17ea:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
    17ee:	81 e0       	ldi	r24, 0x01	; 1
    17f0:	80 93 96 01 	sts	0x0196, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    17f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    17f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    17f8:	00 97       	sbiw	r24, 0x00	; 0
    17fa:	51 f0       	breq	.+20     	; 0x1810 <pvPortMalloc+0x4e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    17fc:	80 91 81 01 	lds	r24, 0x0181
    1800:	90 91 82 01 	lds	r25, 0x0182
    1804:	2d 85       	ldd	r18, Y+13	; 0x0d
    1806:	3e 85       	ldd	r19, Y+14	; 0x0e
    1808:	82 0f       	add	r24, r18
    180a:	93 1f       	adc	r25, r19
    180c:	9e 87       	std	Y+14, r25	; 0x0e
    180e:	8d 87       	std	Y+13, r24	; 0x0d
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    1810:	8d 85       	ldd	r24, Y+13	; 0x0d
    1812:	9e 85       	ldd	r25, Y+14	; 0x0e
    1814:	00 97       	sbiw	r24, 0x00	; 0
    1816:	09 f4       	brne	.+2      	; 0x181a <pvPortMalloc+0x58>
    1818:	af c0       	rjmp	.+350    	; 0x1978 <pvPortMalloc+0x1b6>
    181a:	8d 85       	ldd	r24, Y+13	; 0x0d
    181c:	9e 85       	ldd	r25, Y+14	; 0x0e
    181e:	25 e0       	ldi	r18, 0x05	; 5
    1820:	80 39       	cpi	r24, 0x90	; 144
    1822:	92 07       	cpc	r25, r18
    1824:	08 f0       	brcs	.+2      	; 0x1828 <pvPortMalloc+0x66>
    1826:	a8 c0       	rjmp	.+336    	; 0x1978 <pvPortMalloc+0x1b6>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1828:	88 e2       	ldi	r24, 0x28	; 40
    182a:	97 e0       	ldi	r25, 0x07	; 7
    182c:	9a 87       	std	Y+10, r25	; 0x0a
    182e:	89 87       	std	Y+9, r24	; 0x09
			pxBlock = xStart.pxNextFreeBlock;
    1830:	80 91 28 07 	lds	r24, 0x0728
    1834:	90 91 29 07 	lds	r25, 0x0729
    1838:	9c 87       	std	Y+12, r25	; 0x0c
    183a:	8b 87       	std	Y+11, r24	; 0x0b
    183c:	0a c0       	rjmp	.+20     	; 0x1852 <pvPortMalloc+0x90>
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
			{
				pxPreviousBlock = pxBlock;
    183e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1840:	9c 85       	ldd	r25, Y+12	; 0x0c
    1842:	9a 87       	std	Y+10, r25	; 0x0a
    1844:	89 87       	std	Y+9, r24	; 0x09
				pxBlock = pxBlock->pxNextFreeBlock;
    1846:	eb 85       	ldd	r30, Y+11	; 0x0b
    1848:	fc 85       	ldd	r31, Y+12	; 0x0c
    184a:	80 81       	ld	r24, Z
    184c:	91 81       	ldd	r25, Z+1	; 0x01
    184e:	9c 87       	std	Y+12, r25	; 0x0c
    1850:	8b 87       	std	Y+11, r24	; 0x0b
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1852:	eb 85       	ldd	r30, Y+11	; 0x0b
    1854:	fc 85       	ldd	r31, Y+12	; 0x0c
    1856:	22 81       	ldd	r18, Z+2	; 0x02
    1858:	33 81       	ldd	r19, Z+3	; 0x03
    185a:	8d 85       	ldd	r24, Y+13	; 0x0d
    185c:	9e 85       	ldd	r25, Y+14	; 0x0e
    185e:	28 17       	cp	r18, r24
    1860:	39 07       	cpc	r19, r25
    1862:	30 f4       	brcc	.+12     	; 0x1870 <pvPortMalloc+0xae>
    1864:	eb 85       	ldd	r30, Y+11	; 0x0b
    1866:	fc 85       	ldd	r31, Y+12	; 0x0c
    1868:	80 81       	ld	r24, Z
    186a:	91 81       	ldd	r25, Z+1	; 0x01
    186c:	00 97       	sbiw	r24, 0x00	; 0
    186e:	39 f7       	brne	.-50     	; 0x183e <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1870:	8b 85       	ldd	r24, Y+11	; 0x0b
    1872:	9c 85       	ldd	r25, Y+12	; 0x0c
    1874:	47 e0       	ldi	r20, 0x07	; 7
    1876:	8c 32       	cpi	r24, 0x2C	; 44
    1878:	94 07       	cpc	r25, r20
    187a:	09 f4       	brne	.+2      	; 0x187e <pvPortMalloc+0xbc>
    187c:	7d c0       	rjmp	.+250    	; 0x1978 <pvPortMalloc+0x1b6>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    187e:	e9 85       	ldd	r30, Y+9	; 0x09
    1880:	fa 85       	ldd	r31, Y+10	; 0x0a
    1882:	20 81       	ld	r18, Z
    1884:	31 81       	ldd	r19, Z+1	; 0x01
    1886:	80 91 81 01 	lds	r24, 0x0181
    188a:	90 91 82 01 	lds	r25, 0x0182
    188e:	82 0f       	add	r24, r18
    1890:	93 1f       	adc	r25, r19
    1892:	9e 83       	std	Y+6, r25	; 0x06
    1894:	8d 83       	std	Y+5, r24	; 0x05

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1896:	eb 85       	ldd	r30, Y+11	; 0x0b
    1898:	fc 85       	ldd	r31, Y+12	; 0x0c
    189a:	80 81       	ld	r24, Z
    189c:	91 81       	ldd	r25, Z+1	; 0x01
    189e:	e9 85       	ldd	r30, Y+9	; 0x09
    18a0:	fa 85       	ldd	r31, Y+10	; 0x0a
    18a2:	91 83       	std	Z+1, r25	; 0x01
    18a4:	80 83       	st	Z, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    18a6:	eb 85       	ldd	r30, Y+11	; 0x0b
    18a8:	fc 85       	ldd	r31, Y+12	; 0x0c
    18aa:	22 81       	ldd	r18, Z+2	; 0x02
    18ac:	33 81       	ldd	r19, Z+3	; 0x03
    18ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    18b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    18b2:	28 1b       	sub	r18, r24
    18b4:	39 0b       	sbc	r19, r25
    18b6:	80 91 81 01 	lds	r24, 0x0181
    18ba:	90 91 82 01 	lds	r25, 0x0182
    18be:	88 0f       	add	r24, r24
    18c0:	99 1f       	adc	r25, r25
    18c2:	82 17       	cp	r24, r18
    18c4:	93 07       	cpc	r25, r19
    18c6:	08 f0       	brcs	.+2      	; 0x18ca <pvPortMalloc+0x108>
    18c8:	47 c0       	rjmp	.+142    	; 0x1958 <pvPortMalloc+0x196>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    18ca:	2b 85       	ldd	r18, Y+11	; 0x0b
    18cc:	3c 85       	ldd	r19, Y+12	; 0x0c
    18ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    18d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    18d2:	82 0f       	add	r24, r18
    18d4:	93 1f       	adc	r25, r19
    18d6:	98 87       	std	Y+8, r25	; 0x08
    18d8:	8f 83       	std	Y+7, r24	; 0x07

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    18da:	eb 85       	ldd	r30, Y+11	; 0x0b
    18dc:	fc 85       	ldd	r31, Y+12	; 0x0c
    18de:	22 81       	ldd	r18, Z+2	; 0x02
    18e0:	33 81       	ldd	r19, Z+3	; 0x03
    18e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    18e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    18e6:	a9 01       	movw	r20, r18
    18e8:	48 1b       	sub	r20, r24
    18ea:	59 0b       	sbc	r21, r25
    18ec:	ca 01       	movw	r24, r20
    18ee:	ef 81       	ldd	r30, Y+7	; 0x07
    18f0:	f8 85       	ldd	r31, Y+8	; 0x08
    18f2:	93 83       	std	Z+3, r25	; 0x03
    18f4:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->xBlockSize = xWantedSize;
    18f6:	eb 85       	ldd	r30, Y+11	; 0x0b
    18f8:	fc 85       	ldd	r31, Y+12	; 0x0c
    18fa:	8d 85       	ldd	r24, Y+13	; 0x0d
    18fc:	9e 85       	ldd	r25, Y+14	; 0x0e
    18fe:	93 83       	std	Z+3, r25	; 0x03
    1900:	82 83       	std	Z+2, r24	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1902:	ef 81       	ldd	r30, Y+7	; 0x07
    1904:	f8 85       	ldd	r31, Y+8	; 0x08
    1906:	82 81       	ldd	r24, Z+2	; 0x02
    1908:	93 81       	ldd	r25, Z+3	; 0x03
    190a:	9a 83       	std	Y+2, r25	; 0x02
    190c:	89 83       	std	Y+1, r24	; 0x01
    190e:	88 e2       	ldi	r24, 0x28	; 40
    1910:	97 e0       	ldi	r25, 0x07	; 7
    1912:	9c 83       	std	Y+4, r25	; 0x04
    1914:	8b 83       	std	Y+3, r24	; 0x03
    1916:	06 c0       	rjmp	.+12     	; 0x1924 <pvPortMalloc+0x162>
    1918:	eb 81       	ldd	r30, Y+3	; 0x03
    191a:	fc 81       	ldd	r31, Y+4	; 0x04
    191c:	80 81       	ld	r24, Z
    191e:	91 81       	ldd	r25, Z+1	; 0x01
    1920:	9c 83       	std	Y+4, r25	; 0x04
    1922:	8b 83       	std	Y+3, r24	; 0x03
    1924:	eb 81       	ldd	r30, Y+3	; 0x03
    1926:	fc 81       	ldd	r31, Y+4	; 0x04
    1928:	01 90       	ld	r0, Z+
    192a:	f0 81       	ld	r31, Z
    192c:	e0 2d       	mov	r30, r0
    192e:	22 81       	ldd	r18, Z+2	; 0x02
    1930:	33 81       	ldd	r19, Z+3	; 0x03
    1932:	89 81       	ldd	r24, Y+1	; 0x01
    1934:	9a 81       	ldd	r25, Y+2	; 0x02
    1936:	28 17       	cp	r18, r24
    1938:	39 07       	cpc	r19, r25
    193a:	70 f3       	brcs	.-36     	; 0x1918 <pvPortMalloc+0x156>
    193c:	eb 81       	ldd	r30, Y+3	; 0x03
    193e:	fc 81       	ldd	r31, Y+4	; 0x04
    1940:	80 81       	ld	r24, Z
    1942:	91 81       	ldd	r25, Z+1	; 0x01
    1944:	ef 81       	ldd	r30, Y+7	; 0x07
    1946:	f8 85       	ldd	r31, Y+8	; 0x08
    1948:	91 83       	std	Z+1, r25	; 0x01
    194a:	80 83       	st	Z, r24
    194c:	eb 81       	ldd	r30, Y+3	; 0x03
    194e:	fc 81       	ldd	r31, Y+4	; 0x04
    1950:	8f 81       	ldd	r24, Y+7	; 0x07
    1952:	98 85       	ldd	r25, Y+8	; 0x08
    1954:	91 83       	std	Z+1, r25	; 0x01
    1956:	80 83       	st	Z, r24
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1958:	20 91 7f 01 	lds	r18, 0x017F
    195c:	30 91 80 01 	lds	r19, 0x0180
    1960:	eb 85       	ldd	r30, Y+11	; 0x0b
    1962:	fc 85       	ldd	r31, Y+12	; 0x0c
    1964:	82 81       	ldd	r24, Z+2	; 0x02
    1966:	93 81       	ldd	r25, Z+3	; 0x03
    1968:	a9 01       	movw	r20, r18
    196a:	48 1b       	sub	r20, r24
    196c:	59 0b       	sbc	r21, r25
    196e:	ca 01       	movw	r24, r20
    1970:	90 93 80 01 	sts	0x0180, r25
    1974:	80 93 7f 01 	sts	0x017F, r24
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1978:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    197c:	8d 81       	ldd	r24, Y+5	; 0x05
    197e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1980:	2e 96       	adiw	r28, 0x0e	; 14
    1982:	0f b6       	in	r0, 0x3f	; 63
    1984:	f8 94       	cli
    1986:	de bf       	out	0x3e, r29	; 62
    1988:	0f be       	out	0x3f, r0	; 63
    198a:	cd bf       	out	0x3d, r28	; 61
    198c:	cf 91       	pop	r28
    198e:	df 91       	pop	r29
    1990:	08 95       	ret

00001992 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1992:	df 93       	push	r29
    1994:	cf 93       	push	r28
    1996:	cd b7       	in	r28, 0x3d	; 61
    1998:	de b7       	in	r29, 0x3e	; 62
    199a:	2a 97       	sbiw	r28, 0x0a	; 10
    199c:	0f b6       	in	r0, 0x3f	; 63
    199e:	f8 94       	cli
    19a0:	de bf       	out	0x3e, r29	; 62
    19a2:	0f be       	out	0x3f, r0	; 63
    19a4:	cd bf       	out	0x3d, r28	; 61
    19a6:	9a 87       	std	Y+10, r25	; 0x0a
    19a8:	89 87       	std	Y+9, r24	; 0x09
uint8_t *puc = ( uint8_t * ) pv;
    19aa:	89 85       	ldd	r24, Y+9	; 0x09
    19ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    19ae:	98 87       	std	Y+8, r25	; 0x08
    19b0:	8f 83       	std	Y+7, r24	; 0x07
BlockLink_t *pxLink;

	if( pv != NULL )
    19b2:	89 85       	ldd	r24, Y+9	; 0x09
    19b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    19b6:	00 97       	sbiw	r24, 0x00	; 0
    19b8:	09 f4       	brne	.+2      	; 0x19bc <vPortFree+0x2a>
    19ba:	4f c0       	rjmp	.+158    	; 0x1a5a <vPortFree+0xc8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    19bc:	80 91 81 01 	lds	r24, 0x0181
    19c0:	90 91 82 01 	lds	r25, 0x0182
    19c4:	22 27       	eor	r18, r18
    19c6:	33 27       	eor	r19, r19
    19c8:	28 1b       	sub	r18, r24
    19ca:	39 0b       	sbc	r19, r25
    19cc:	8f 81       	ldd	r24, Y+7	; 0x07
    19ce:	98 85       	ldd	r25, Y+8	; 0x08
    19d0:	82 0f       	add	r24, r18
    19d2:	93 1f       	adc	r25, r19
    19d4:	98 87       	std	Y+8, r25	; 0x08
    19d6:	8f 83       	std	Y+7, r24	; 0x07

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
    19d8:	8f 81       	ldd	r24, Y+7	; 0x07
    19da:	98 85       	ldd	r25, Y+8	; 0x08
    19dc:	9e 83       	std	Y+6, r25	; 0x06
    19de:	8d 83       	std	Y+5, r24	; 0x05

		vTaskSuspendAll();
    19e0:	0e 94 09 1c 	call	0x3812	; 0x3812 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    19e4:	ed 81       	ldd	r30, Y+5	; 0x05
    19e6:	fe 81       	ldd	r31, Y+6	; 0x06
    19e8:	82 81       	ldd	r24, Z+2	; 0x02
    19ea:	93 81       	ldd	r25, Z+3	; 0x03
    19ec:	9a 83       	std	Y+2, r25	; 0x02
    19ee:	89 83       	std	Y+1, r24	; 0x01
    19f0:	88 e2       	ldi	r24, 0x28	; 40
    19f2:	97 e0       	ldi	r25, 0x07	; 7
    19f4:	9c 83       	std	Y+4, r25	; 0x04
    19f6:	8b 83       	std	Y+3, r24	; 0x03
    19f8:	06 c0       	rjmp	.+12     	; 0x1a06 <vPortFree+0x74>
    19fa:	eb 81       	ldd	r30, Y+3	; 0x03
    19fc:	fc 81       	ldd	r31, Y+4	; 0x04
    19fe:	80 81       	ld	r24, Z
    1a00:	91 81       	ldd	r25, Z+1	; 0x01
    1a02:	9c 83       	std	Y+4, r25	; 0x04
    1a04:	8b 83       	std	Y+3, r24	; 0x03
    1a06:	eb 81       	ldd	r30, Y+3	; 0x03
    1a08:	fc 81       	ldd	r31, Y+4	; 0x04
    1a0a:	01 90       	ld	r0, Z+
    1a0c:	f0 81       	ld	r31, Z
    1a0e:	e0 2d       	mov	r30, r0
    1a10:	22 81       	ldd	r18, Z+2	; 0x02
    1a12:	33 81       	ldd	r19, Z+3	; 0x03
    1a14:	89 81       	ldd	r24, Y+1	; 0x01
    1a16:	9a 81       	ldd	r25, Y+2	; 0x02
    1a18:	28 17       	cp	r18, r24
    1a1a:	39 07       	cpc	r19, r25
    1a1c:	70 f3       	brcs	.-36     	; 0x19fa <vPortFree+0x68>
    1a1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a20:	fc 81       	ldd	r31, Y+4	; 0x04
    1a22:	80 81       	ld	r24, Z
    1a24:	91 81       	ldd	r25, Z+1	; 0x01
    1a26:	ed 81       	ldd	r30, Y+5	; 0x05
    1a28:	fe 81       	ldd	r31, Y+6	; 0x06
    1a2a:	91 83       	std	Z+1, r25	; 0x01
    1a2c:	80 83       	st	Z, r24
    1a2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a30:	fc 81       	ldd	r31, Y+4	; 0x04
    1a32:	8d 81       	ldd	r24, Y+5	; 0x05
    1a34:	9e 81       	ldd	r25, Y+6	; 0x06
    1a36:	91 83       	std	Z+1, r25	; 0x01
    1a38:	80 83       	st	Z, r24
			xFreeBytesRemaining += pxLink->xBlockSize;
    1a3a:	ed 81       	ldd	r30, Y+5	; 0x05
    1a3c:	fe 81       	ldd	r31, Y+6	; 0x06
    1a3e:	22 81       	ldd	r18, Z+2	; 0x02
    1a40:	33 81       	ldd	r19, Z+3	; 0x03
    1a42:	80 91 7f 01 	lds	r24, 0x017F
    1a46:	90 91 80 01 	lds	r25, 0x0180
    1a4a:	82 0f       	add	r24, r18
    1a4c:	93 1f       	adc	r25, r19
    1a4e:	90 93 80 01 	sts	0x0180, r25
    1a52:	80 93 7f 01 	sts	0x017F, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    1a56:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>
	}
}
    1a5a:	2a 96       	adiw	r28, 0x0a	; 10
    1a5c:	0f b6       	in	r0, 0x3f	; 63
    1a5e:	f8 94       	cli
    1a60:	de bf       	out	0x3e, r29	; 62
    1a62:	0f be       	out	0x3f, r0	; 63
    1a64:	cd bf       	out	0x3d, r28	; 61
    1a66:	cf 91       	pop	r28
    1a68:	df 91       	pop	r29
    1a6a:	08 95       	ret

00001a6c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1a6c:	df 93       	push	r29
    1a6e:	cf 93       	push	r28
    1a70:	cd b7       	in	r28, 0x3d	; 61
    1a72:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
    1a74:	80 91 7f 01 	lds	r24, 0x017F
    1a78:	90 91 80 01 	lds	r25, 0x0180
}
    1a7c:	cf 91       	pop	r28
    1a7e:	df 91       	pop	r29
    1a80:	08 95       	ret

00001a82 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1a82:	df 93       	push	r29
    1a84:	cf 93       	push	r28
    1a86:	cd b7       	in	r28, 0x3d	; 61
    1a88:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
    1a8a:	cf 91       	pop	r28
    1a8c:	df 91       	pop	r29
    1a8e:	08 95       	ret

00001a90 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    1a90:	df 93       	push	r29
    1a92:	cf 93       	push	r28
    1a94:	00 d0       	rcall	.+0      	; 0x1a96 <prvHeapInit+0x6>
    1a96:	00 d0       	rcall	.+0      	; 0x1a98 <prvHeapInit+0x8>
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1a9c:	88 e9       	ldi	r24, 0x98	; 152
    1a9e:	91 e0       	ldi	r25, 0x01	; 1
    1aa0:	9a 83       	std	Y+2, r25	; 0x02
    1aa2:	89 83       	std	Y+1, r24	; 0x01

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    1aa4:	89 81       	ldd	r24, Y+1	; 0x01
    1aa6:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa8:	90 93 29 07 	sts	0x0729, r25
    1aac:	80 93 28 07 	sts	0x0728, r24
	xStart.xBlockSize = ( size_t ) 0;
    1ab0:	10 92 2b 07 	sts	0x072B, r1
    1ab4:	10 92 2a 07 	sts	0x072A, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    1ab8:	80 e9       	ldi	r24, 0x90	; 144
    1aba:	95 e0       	ldi	r25, 0x05	; 5
    1abc:	90 93 2f 07 	sts	0x072F, r25
    1ac0:	80 93 2e 07 	sts	0x072E, r24
	xEnd.pxNextFreeBlock = NULL;
    1ac4:	10 92 2d 07 	sts	0x072D, r1
    1ac8:	10 92 2c 07 	sts	0x072C, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    1acc:	89 81       	ldd	r24, Y+1	; 0x01
    1ace:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad0:	9c 83       	std	Y+4, r25	; 0x04
    1ad2:	8b 83       	std	Y+3, r24	; 0x03
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    1ad4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad8:	80 e9       	ldi	r24, 0x90	; 144
    1ada:	95 e0       	ldi	r25, 0x05	; 5
    1adc:	93 83       	std	Z+3, r25	; 0x03
    1ade:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1ae0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ae2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ae4:	8c e2       	ldi	r24, 0x2C	; 44
    1ae6:	97 e0       	ldi	r25, 0x07	; 7
    1ae8:	91 83       	std	Z+1, r25	; 0x01
    1aea:	80 83       	st	Z, r24
}
    1aec:	0f 90       	pop	r0
    1aee:	0f 90       	pop	r0
    1af0:	0f 90       	pop	r0
    1af2:	0f 90       	pop	r0
    1af4:	cf 91       	pop	r28
    1af6:	df 91       	pop	r29
    1af8:	08 95       	ret

00001afa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1afa:	df 93       	push	r29
    1afc:	cf 93       	push	r28
    1afe:	00 d0       	rcall	.+0      	; 0x1b00 <vListInitialise+0x6>
    1b00:	cd b7       	in	r28, 0x3d	; 61
    1b02:	de b7       	in	r29, 0x3e	; 62
    1b04:	9a 83       	std	Y+2, r25	; 0x02
    1b06:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b08:	89 81       	ldd	r24, Y+1	; 0x01
    1b0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b0c:	03 96       	adiw	r24, 0x03	; 3
    1b0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b10:	fa 81       	ldd	r31, Y+2	; 0x02
    1b12:	92 83       	std	Z+2, r25	; 0x02
    1b14:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b16:	e9 81       	ldd	r30, Y+1	; 0x01
    1b18:	fa 81       	ldd	r31, Y+2	; 0x02
    1b1a:	8f ef       	ldi	r24, 0xFF	; 255
    1b1c:	9f ef       	ldi	r25, 0xFF	; 255
    1b1e:	94 83       	std	Z+4, r25	; 0x04
    1b20:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b22:	89 81       	ldd	r24, Y+1	; 0x01
    1b24:	9a 81       	ldd	r25, Y+2	; 0x02
    1b26:	03 96       	adiw	r24, 0x03	; 3
    1b28:	e9 81       	ldd	r30, Y+1	; 0x01
    1b2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b2c:	96 83       	std	Z+6, r25	; 0x06
    1b2e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b30:	89 81       	ldd	r24, Y+1	; 0x01
    1b32:	9a 81       	ldd	r25, Y+2	; 0x02
    1b34:	03 96       	adiw	r24, 0x03	; 3
    1b36:	e9 81       	ldd	r30, Y+1	; 0x01
    1b38:	fa 81       	ldd	r31, Y+2	; 0x02
    1b3a:	90 87       	std	Z+8, r25	; 0x08
    1b3c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b40:	fa 81       	ldd	r31, Y+2	; 0x02
    1b42:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1b44:	0f 90       	pop	r0
    1b46:	0f 90       	pop	r0
    1b48:	cf 91       	pop	r28
    1b4a:	df 91       	pop	r29
    1b4c:	08 95       	ret

00001b4e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1b4e:	df 93       	push	r29
    1b50:	cf 93       	push	r28
    1b52:	00 d0       	rcall	.+0      	; 0x1b54 <vListInitialiseItem+0x6>
    1b54:	cd b7       	in	r28, 0x3d	; 61
    1b56:	de b7       	in	r29, 0x3e	; 62
    1b58:	9a 83       	std	Y+2, r25	; 0x02
    1b5a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b60:	11 86       	std	Z+9, r1	; 0x09
    1b62:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1b64:	0f 90       	pop	r0
    1b66:	0f 90       	pop	r0
    1b68:	cf 91       	pop	r28
    1b6a:	df 91       	pop	r29
    1b6c:	08 95       	ret

00001b6e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1b6e:	df 93       	push	r29
    1b70:	cf 93       	push	r28
    1b72:	00 d0       	rcall	.+0      	; 0x1b74 <vListInsertEnd+0x6>
    1b74:	00 d0       	rcall	.+0      	; 0x1b76 <vListInsertEnd+0x8>
    1b76:	00 d0       	rcall	.+0      	; 0x1b78 <vListInsertEnd+0xa>
    1b78:	cd b7       	in	r28, 0x3d	; 61
    1b7a:	de b7       	in	r29, 0x3e	; 62
    1b7c:	9c 83       	std	Y+4, r25	; 0x04
    1b7e:	8b 83       	std	Y+3, r24	; 0x03
    1b80:	7e 83       	std	Y+6, r23	; 0x06
    1b82:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1b84:	eb 81       	ldd	r30, Y+3	; 0x03
    1b86:	fc 81       	ldd	r31, Y+4	; 0x04
    1b88:	81 81       	ldd	r24, Z+1	; 0x01
    1b8a:	92 81       	ldd	r25, Z+2	; 0x02
    1b8c:	9a 83       	std	Y+2, r25	; 0x02
    1b8e:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1b90:	ed 81       	ldd	r30, Y+5	; 0x05
    1b92:	fe 81       	ldd	r31, Y+6	; 0x06
    1b94:	89 81       	ldd	r24, Y+1	; 0x01
    1b96:	9a 81       	ldd	r25, Y+2	; 0x02
    1b98:	93 83       	std	Z+3, r25	; 0x03
    1b9a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1ba0:	84 81       	ldd	r24, Z+4	; 0x04
    1ba2:	95 81       	ldd	r25, Z+5	; 0x05
    1ba4:	ed 81       	ldd	r30, Y+5	; 0x05
    1ba6:	fe 81       	ldd	r31, Y+6	; 0x06
    1ba8:	95 83       	std	Z+5, r25	; 0x05
    1baa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1bac:	e9 81       	ldd	r30, Y+1	; 0x01
    1bae:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb0:	04 80       	ldd	r0, Z+4	; 0x04
    1bb2:	f5 81       	ldd	r31, Z+5	; 0x05
    1bb4:	e0 2d       	mov	r30, r0
    1bb6:	8d 81       	ldd	r24, Y+5	; 0x05
    1bb8:	9e 81       	ldd	r25, Y+6	; 0x06
    1bba:	93 83       	std	Z+3, r25	; 0x03
    1bbc:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1bbe:	e9 81       	ldd	r30, Y+1	; 0x01
    1bc0:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc2:	8d 81       	ldd	r24, Y+5	; 0x05
    1bc4:	9e 81       	ldd	r25, Y+6	; 0x06
    1bc6:	95 83       	std	Z+5, r25	; 0x05
    1bc8:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1bca:	ed 81       	ldd	r30, Y+5	; 0x05
    1bcc:	fe 81       	ldd	r31, Y+6	; 0x06
    1bce:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd2:	91 87       	std	Z+9, r25	; 0x09
    1bd4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1bd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bda:	80 81       	ld	r24, Z
    1bdc:	8f 5f       	subi	r24, 0xFF	; 255
    1bde:	eb 81       	ldd	r30, Y+3	; 0x03
    1be0:	fc 81       	ldd	r31, Y+4	; 0x04
    1be2:	80 83       	st	Z, r24
}
    1be4:	26 96       	adiw	r28, 0x06	; 6
    1be6:	0f b6       	in	r0, 0x3f	; 63
    1be8:	f8 94       	cli
    1bea:	de bf       	out	0x3e, r29	; 62
    1bec:	0f be       	out	0x3f, r0	; 63
    1bee:	cd bf       	out	0x3d, r28	; 61
    1bf0:	cf 91       	pop	r28
    1bf2:	df 91       	pop	r29
    1bf4:	08 95       	ret

00001bf6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bf6:	df 93       	push	r29
    1bf8:	cf 93       	push	r28
    1bfa:	cd b7       	in	r28, 0x3d	; 61
    1bfc:	de b7       	in	r29, 0x3e	; 62
    1bfe:	28 97       	sbiw	r28, 0x08	; 8
    1c00:	0f b6       	in	r0, 0x3f	; 63
    1c02:	f8 94       	cli
    1c04:	de bf       	out	0x3e, r29	; 62
    1c06:	0f be       	out	0x3f, r0	; 63
    1c08:	cd bf       	out	0x3d, r28	; 61
    1c0a:	9e 83       	std	Y+6, r25	; 0x06
    1c0c:	8d 83       	std	Y+5, r24	; 0x05
    1c0e:	78 87       	std	Y+8, r23	; 0x08
    1c10:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c12:	ef 81       	ldd	r30, Y+7	; 0x07
    1c14:	f8 85       	ldd	r31, Y+8	; 0x08
    1c16:	80 81       	ld	r24, Z
    1c18:	91 81       	ldd	r25, Z+1	; 0x01
    1c1a:	9a 83       	std	Y+2, r25	; 0x02
    1c1c:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c1e:	89 81       	ldd	r24, Y+1	; 0x01
    1c20:	9a 81       	ldd	r25, Y+2	; 0x02
    1c22:	2f ef       	ldi	r18, 0xFF	; 255
    1c24:	8f 3f       	cpi	r24, 0xFF	; 255
    1c26:	92 07       	cpc	r25, r18
    1c28:	39 f4       	brne	.+14     	; 0x1c38 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c2a:	ed 81       	ldd	r30, Y+5	; 0x05
    1c2c:	fe 81       	ldd	r31, Y+6	; 0x06
    1c2e:	87 81       	ldd	r24, Z+7	; 0x07
    1c30:	90 85       	ldd	r25, Z+8	; 0x08
    1c32:	9c 83       	std	Y+4, r25	; 0x04
    1c34:	8b 83       	std	Y+3, r24	; 0x03
    1c36:	18 c0       	rjmp	.+48     	; 0x1c68 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c38:	8d 81       	ldd	r24, Y+5	; 0x05
    1c3a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c3c:	03 96       	adiw	r24, 0x03	; 3
    1c3e:	9c 83       	std	Y+4, r25	; 0x04
    1c40:	8b 83       	std	Y+3, r24	; 0x03
    1c42:	06 c0       	rjmp	.+12     	; 0x1c50 <vListInsert+0x5a>
    1c44:	eb 81       	ldd	r30, Y+3	; 0x03
    1c46:	fc 81       	ldd	r31, Y+4	; 0x04
    1c48:	82 81       	ldd	r24, Z+2	; 0x02
    1c4a:	93 81       	ldd	r25, Z+3	; 0x03
    1c4c:	9c 83       	std	Y+4, r25	; 0x04
    1c4e:	8b 83       	std	Y+3, r24	; 0x03
    1c50:	eb 81       	ldd	r30, Y+3	; 0x03
    1c52:	fc 81       	ldd	r31, Y+4	; 0x04
    1c54:	02 80       	ldd	r0, Z+2	; 0x02
    1c56:	f3 81       	ldd	r31, Z+3	; 0x03
    1c58:	e0 2d       	mov	r30, r0
    1c5a:	20 81       	ld	r18, Z
    1c5c:	31 81       	ldd	r19, Z+1	; 0x01
    1c5e:	89 81       	ldd	r24, Y+1	; 0x01
    1c60:	9a 81       	ldd	r25, Y+2	; 0x02
    1c62:	82 17       	cp	r24, r18
    1c64:	93 07       	cpc	r25, r19
    1c66:	70 f7       	brcc	.-36     	; 0x1c44 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c68:	eb 81       	ldd	r30, Y+3	; 0x03
    1c6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c6c:	82 81       	ldd	r24, Z+2	; 0x02
    1c6e:	93 81       	ldd	r25, Z+3	; 0x03
    1c70:	ef 81       	ldd	r30, Y+7	; 0x07
    1c72:	f8 85       	ldd	r31, Y+8	; 0x08
    1c74:	93 83       	std	Z+3, r25	; 0x03
    1c76:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c78:	ef 81       	ldd	r30, Y+7	; 0x07
    1c7a:	f8 85       	ldd	r31, Y+8	; 0x08
    1c7c:	02 80       	ldd	r0, Z+2	; 0x02
    1c7e:	f3 81       	ldd	r31, Z+3	; 0x03
    1c80:	e0 2d       	mov	r30, r0
    1c82:	8f 81       	ldd	r24, Y+7	; 0x07
    1c84:	98 85       	ldd	r25, Y+8	; 0x08
    1c86:	95 83       	std	Z+5, r25	; 0x05
    1c88:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c8a:	ef 81       	ldd	r30, Y+7	; 0x07
    1c8c:	f8 85       	ldd	r31, Y+8	; 0x08
    1c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c90:	9c 81       	ldd	r25, Y+4	; 0x04
    1c92:	95 83       	std	Z+5, r25	; 0x05
    1c94:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c96:	eb 81       	ldd	r30, Y+3	; 0x03
    1c98:	fc 81       	ldd	r31, Y+4	; 0x04
    1c9a:	8f 81       	ldd	r24, Y+7	; 0x07
    1c9c:	98 85       	ldd	r25, Y+8	; 0x08
    1c9e:	93 83       	std	Z+3, r25	; 0x03
    1ca0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ca2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ca4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ca6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca8:	9e 81       	ldd	r25, Y+6	; 0x06
    1caa:	91 87       	std	Z+9, r25	; 0x09
    1cac:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1cae:	ed 81       	ldd	r30, Y+5	; 0x05
    1cb0:	fe 81       	ldd	r31, Y+6	; 0x06
    1cb2:	80 81       	ld	r24, Z
    1cb4:	8f 5f       	subi	r24, 0xFF	; 255
    1cb6:	ed 81       	ldd	r30, Y+5	; 0x05
    1cb8:	fe 81       	ldd	r31, Y+6	; 0x06
    1cba:	80 83       	st	Z, r24
}
    1cbc:	28 96       	adiw	r28, 0x08	; 8
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	f8 94       	cli
    1cc2:	de bf       	out	0x3e, r29	; 62
    1cc4:	0f be       	out	0x3f, r0	; 63
    1cc6:	cd bf       	out	0x3d, r28	; 61
    1cc8:	cf 91       	pop	r28
    1cca:	df 91       	pop	r29
    1ccc:	08 95       	ret

00001cce <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1cce:	df 93       	push	r29
    1cd0:	cf 93       	push	r28
    1cd2:	00 d0       	rcall	.+0      	; 0x1cd4 <uxListRemove+0x6>
    1cd4:	00 d0       	rcall	.+0      	; 0x1cd6 <uxListRemove+0x8>
    1cd6:	cd b7       	in	r28, 0x3d	; 61
    1cd8:	de b7       	in	r29, 0x3e	; 62
    1cda:	9c 83       	std	Y+4, r25	; 0x04
    1cdc:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1cde:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce2:	80 85       	ldd	r24, Z+8	; 0x08
    1ce4:	91 85       	ldd	r25, Z+9	; 0x09
    1ce6:	9a 83       	std	Y+2, r25	; 0x02
    1ce8:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cea:	eb 81       	ldd	r30, Y+3	; 0x03
    1cec:	fc 81       	ldd	r31, Y+4	; 0x04
    1cee:	a2 81       	ldd	r26, Z+2	; 0x02
    1cf0:	b3 81       	ldd	r27, Z+3	; 0x03
    1cf2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf6:	84 81       	ldd	r24, Z+4	; 0x04
    1cf8:	95 81       	ldd	r25, Z+5	; 0x05
    1cfa:	15 96       	adiw	r26, 0x05	; 5
    1cfc:	9c 93       	st	X, r25
    1cfe:	8e 93       	st	-X, r24
    1d00:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d02:	eb 81       	ldd	r30, Y+3	; 0x03
    1d04:	fc 81       	ldd	r31, Y+4	; 0x04
    1d06:	a4 81       	ldd	r26, Z+4	; 0x04
    1d08:	b5 81       	ldd	r27, Z+5	; 0x05
    1d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d0e:	82 81       	ldd	r24, Z+2	; 0x02
    1d10:	93 81       	ldd	r25, Z+3	; 0x03
    1d12:	13 96       	adiw	r26, 0x03	; 3
    1d14:	9c 93       	st	X, r25
    1d16:	8e 93       	st	-X, r24
    1d18:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1e:	21 81       	ldd	r18, Z+1	; 0x01
    1d20:	32 81       	ldd	r19, Z+2	; 0x02
    1d22:	8b 81       	ldd	r24, Y+3	; 0x03
    1d24:	9c 81       	ldd	r25, Y+4	; 0x04
    1d26:	28 17       	cp	r18, r24
    1d28:	39 07       	cpc	r19, r25
    1d2a:	41 f4       	brne	.+16     	; 0x1d3c <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d30:	84 81       	ldd	r24, Z+4	; 0x04
    1d32:	95 81       	ldd	r25, Z+5	; 0x05
    1d34:	e9 81       	ldd	r30, Y+1	; 0x01
    1d36:	fa 81       	ldd	r31, Y+2	; 0x02
    1d38:	92 83       	std	Z+2, r25	; 0x02
    1d3a:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1d3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d40:	11 86       	std	Z+9, r1	; 0x09
    1d42:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1d44:	e9 81       	ldd	r30, Y+1	; 0x01
    1d46:	fa 81       	ldd	r31, Y+2	; 0x02
    1d48:	80 81       	ld	r24, Z
    1d4a:	81 50       	subi	r24, 0x01	; 1
    1d4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d50:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1d52:	e9 81       	ldd	r30, Y+1	; 0x01
    1d54:	fa 81       	ldd	r31, Y+2	; 0x02
    1d56:	80 81       	ld	r24, Z
}
    1d58:	0f 90       	pop	r0
    1d5a:	0f 90       	pop	r0
    1d5c:	0f 90       	pop	r0
    1d5e:	0f 90       	pop	r0
    1d60:	cf 91       	pop	r28
    1d62:	df 91       	pop	r29
    1d64:	08 95       	ret

00001d66 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1d66:	df 93       	push	r29
    1d68:	cf 93       	push	r28
    1d6a:	cd b7       	in	r28, 0x3d	; 61
    1d6c:	de b7       	in	r29, 0x3e	; 62
    1d6e:	28 97       	sbiw	r28, 0x08	; 8
    1d70:	0f b6       	in	r0, 0x3f	; 63
    1d72:	f8 94       	cli
    1d74:	de bf       	out	0x3e, r29	; 62
    1d76:	0f be       	out	0x3f, r0	; 63
    1d78:	cd bf       	out	0x3d, r28	; 61
    1d7a:	9c 83       	std	Y+4, r25	; 0x04
    1d7c:	8b 83       	std	Y+3, r24	; 0x03
    1d7e:	7e 83       	std	Y+6, r23	; 0x06
    1d80:	6d 83       	std	Y+5, r22	; 0x05
    1d82:	58 87       	std	Y+8, r21	; 0x08
    1d84:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1d86:	eb 81       	ldd	r30, Y+3	; 0x03
    1d88:	fc 81       	ldd	r31, Y+4	; 0x04
    1d8a:	81 e1       	ldi	r24, 0x11	; 17
    1d8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d90:	9c 81       	ldd	r25, Y+4	; 0x04
    1d92:	01 97       	sbiw	r24, 0x01	; 1
    1d94:	9c 83       	std	Y+4, r25	; 0x04
    1d96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1d98:	eb 81       	ldd	r30, Y+3	; 0x03
    1d9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d9c:	82 e2       	ldi	r24, 0x22	; 34
    1d9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1da0:	8b 81       	ldd	r24, Y+3	; 0x03
    1da2:	9c 81       	ldd	r25, Y+4	; 0x04
    1da4:	01 97       	sbiw	r24, 0x01	; 1
    1da6:	9c 83       	std	Y+4, r25	; 0x04
    1da8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1daa:	eb 81       	ldd	r30, Y+3	; 0x03
    1dac:	fc 81       	ldd	r31, Y+4	; 0x04
    1dae:	83 e3       	ldi	r24, 0x33	; 51
    1db0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1db2:	8b 81       	ldd	r24, Y+3	; 0x03
    1db4:	9c 81       	ldd	r25, Y+4	; 0x04
    1db6:	01 97       	sbiw	r24, 0x01	; 1
    1db8:	9c 83       	std	Y+4, r25	; 0x04
    1dba:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1dbc:	8d 81       	ldd	r24, Y+5	; 0x05
    1dbe:	9e 81       	ldd	r25, Y+6	; 0x06
    1dc0:	9a 83       	std	Y+2, r25	; 0x02
    1dc2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1dc4:	89 81       	ldd	r24, Y+1	; 0x01
    1dc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dca:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dce:	9c 81       	ldd	r25, Y+4	; 0x04
    1dd0:	01 97       	sbiw	r24, 0x01	; 1
    1dd2:	9c 83       	std	Y+4, r25	; 0x04
    1dd4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1dd6:	89 81       	ldd	r24, Y+1	; 0x01
    1dd8:	9a 81       	ldd	r25, Y+2	; 0x02
    1dda:	89 2f       	mov	r24, r25
    1ddc:	99 27       	eor	r25, r25
    1dde:	9a 83       	std	Y+2, r25	; 0x02
    1de0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1de2:	89 81       	ldd	r24, Y+1	; 0x01
    1de4:	eb 81       	ldd	r30, Y+3	; 0x03
    1de6:	fc 81       	ldd	r31, Y+4	; 0x04
    1de8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dea:	8b 81       	ldd	r24, Y+3	; 0x03
    1dec:	9c 81       	ldd	r25, Y+4	; 0x04
    1dee:	01 97       	sbiw	r24, 0x01	; 1
    1df0:	9c 83       	std	Y+4, r25	; 0x04
    1df2:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1df4:	eb 81       	ldd	r30, Y+3	; 0x03
    1df6:	fc 81       	ldd	r31, Y+4	; 0x04
    1df8:	10 82       	st	Z, r1
	pxTopOfStack--;
    1dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    1dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dfe:	01 97       	sbiw	r24, 0x01	; 1
    1e00:	9c 83       	std	Y+4, r25	; 0x04
    1e02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1e04:	eb 81       	ldd	r30, Y+3	; 0x03
    1e06:	fc 81       	ldd	r31, Y+4	; 0x04
    1e08:	80 e8       	ldi	r24, 0x80	; 128
    1e0a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e10:	01 97       	sbiw	r24, 0x01	; 1
    1e12:	9c 83       	std	Y+4, r25	; 0x04
    1e14:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1e16:	eb 81       	ldd	r30, Y+3	; 0x03
    1e18:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1a:	10 82       	st	Z, r1
	pxTopOfStack--;
    1e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e1e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e20:	01 97       	sbiw	r24, 0x01	; 1
    1e22:	9c 83       	std	Y+4, r25	; 0x04
    1e24:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1e26:	eb 81       	ldd	r30, Y+3	; 0x03
    1e28:	fc 81       	ldd	r31, Y+4	; 0x04
    1e2a:	82 e0       	ldi	r24, 0x02	; 2
    1e2c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e30:	9c 81       	ldd	r25, Y+4	; 0x04
    1e32:	01 97       	sbiw	r24, 0x01	; 1
    1e34:	9c 83       	std	Y+4, r25	; 0x04
    1e36:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1e38:	eb 81       	ldd	r30, Y+3	; 0x03
    1e3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e3c:	83 e0       	ldi	r24, 0x03	; 3
    1e3e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e40:	8b 81       	ldd	r24, Y+3	; 0x03
    1e42:	9c 81       	ldd	r25, Y+4	; 0x04
    1e44:	01 97       	sbiw	r24, 0x01	; 1
    1e46:	9c 83       	std	Y+4, r25	; 0x04
    1e48:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e4e:	84 e0       	ldi	r24, 0x04	; 4
    1e50:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e52:	8b 81       	ldd	r24, Y+3	; 0x03
    1e54:	9c 81       	ldd	r25, Y+4	; 0x04
    1e56:	01 97       	sbiw	r24, 0x01	; 1
    1e58:	9c 83       	std	Y+4, r25	; 0x04
    1e5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1e5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e60:	85 e0       	ldi	r24, 0x05	; 5
    1e62:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e64:	8b 81       	ldd	r24, Y+3	; 0x03
    1e66:	9c 81       	ldd	r25, Y+4	; 0x04
    1e68:	01 97       	sbiw	r24, 0x01	; 1
    1e6a:	9c 83       	std	Y+4, r25	; 0x04
    1e6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1e6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e70:	fc 81       	ldd	r31, Y+4	; 0x04
    1e72:	86 e0       	ldi	r24, 0x06	; 6
    1e74:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e76:	8b 81       	ldd	r24, Y+3	; 0x03
    1e78:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7a:	01 97       	sbiw	r24, 0x01	; 1
    1e7c:	9c 83       	std	Y+4, r25	; 0x04
    1e7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1e80:	eb 81       	ldd	r30, Y+3	; 0x03
    1e82:	fc 81       	ldd	r31, Y+4	; 0x04
    1e84:	87 e0       	ldi	r24, 0x07	; 7
    1e86:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e88:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e8c:	01 97       	sbiw	r24, 0x01	; 1
    1e8e:	9c 83       	std	Y+4, r25	; 0x04
    1e90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1e92:	eb 81       	ldd	r30, Y+3	; 0x03
    1e94:	fc 81       	ldd	r31, Y+4	; 0x04
    1e96:	88 e0       	ldi	r24, 0x08	; 8
    1e98:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e9e:	01 97       	sbiw	r24, 0x01	; 1
    1ea0:	9c 83       	std	Y+4, r25	; 0x04
    1ea2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1ea4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ea6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ea8:	89 e0       	ldi	r24, 0x09	; 9
    1eaa:	80 83       	st	Z, r24
	pxTopOfStack--;
    1eac:	8b 81       	ldd	r24, Y+3	; 0x03
    1eae:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb0:	01 97       	sbiw	r24, 0x01	; 1
    1eb2:	9c 83       	std	Y+4, r25	; 0x04
    1eb4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1eba:	80 e1       	ldi	r24, 0x10	; 16
    1ebc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec2:	01 97       	sbiw	r24, 0x01	; 1
    1ec4:	9c 83       	std	Y+4, r25	; 0x04
    1ec6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1ec8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eca:	fc 81       	ldd	r31, Y+4	; 0x04
    1ecc:	81 e1       	ldi	r24, 0x11	; 17
    1ece:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ed2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ed4:	01 97       	sbiw	r24, 0x01	; 1
    1ed6:	9c 83       	std	Y+4, r25	; 0x04
    1ed8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1eda:	eb 81       	ldd	r30, Y+3	; 0x03
    1edc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ede:	82 e1       	ldi	r24, 0x12	; 18
    1ee0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ee6:	01 97       	sbiw	r24, 0x01	; 1
    1ee8:	9c 83       	std	Y+4, r25	; 0x04
    1eea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1eec:	eb 81       	ldd	r30, Y+3	; 0x03
    1eee:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef0:	83 e1       	ldi	r24, 0x13	; 19
    1ef2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef8:	01 97       	sbiw	r24, 0x01	; 1
    1efa:	9c 83       	std	Y+4, r25	; 0x04
    1efc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1efe:	eb 81       	ldd	r30, Y+3	; 0x03
    1f00:	fc 81       	ldd	r31, Y+4	; 0x04
    1f02:	84 e1       	ldi	r24, 0x14	; 20
    1f04:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f06:	8b 81       	ldd	r24, Y+3	; 0x03
    1f08:	9c 81       	ldd	r25, Y+4	; 0x04
    1f0a:	01 97       	sbiw	r24, 0x01	; 1
    1f0c:	9c 83       	std	Y+4, r25	; 0x04
    1f0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1f10:	eb 81       	ldd	r30, Y+3	; 0x03
    1f12:	fc 81       	ldd	r31, Y+4	; 0x04
    1f14:	85 e1       	ldi	r24, 0x15	; 21
    1f16:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f18:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1c:	01 97       	sbiw	r24, 0x01	; 1
    1f1e:	9c 83       	std	Y+4, r25	; 0x04
    1f20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1f22:	eb 81       	ldd	r30, Y+3	; 0x03
    1f24:	fc 81       	ldd	r31, Y+4	; 0x04
    1f26:	86 e1       	ldi	r24, 0x16	; 22
    1f28:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f2e:	01 97       	sbiw	r24, 0x01	; 1
    1f30:	9c 83       	std	Y+4, r25	; 0x04
    1f32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1f34:	eb 81       	ldd	r30, Y+3	; 0x03
    1f36:	fc 81       	ldd	r31, Y+4	; 0x04
    1f38:	87 e1       	ldi	r24, 0x17	; 23
    1f3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1f40:	01 97       	sbiw	r24, 0x01	; 1
    1f42:	9c 83       	std	Y+4, r25	; 0x04
    1f44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1f46:	eb 81       	ldd	r30, Y+3	; 0x03
    1f48:	fc 81       	ldd	r31, Y+4	; 0x04
    1f4a:	88 e1       	ldi	r24, 0x18	; 24
    1f4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f50:	9c 81       	ldd	r25, Y+4	; 0x04
    1f52:	01 97       	sbiw	r24, 0x01	; 1
    1f54:	9c 83       	std	Y+4, r25	; 0x04
    1f56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1f58:	eb 81       	ldd	r30, Y+3	; 0x03
    1f5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f5c:	89 e1       	ldi	r24, 0x19	; 25
    1f5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f60:	8b 81       	ldd	r24, Y+3	; 0x03
    1f62:	9c 81       	ldd	r25, Y+4	; 0x04
    1f64:	01 97       	sbiw	r24, 0x01	; 1
    1f66:	9c 83       	std	Y+4, r25	; 0x04
    1f68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1f6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f6e:	80 e2       	ldi	r24, 0x20	; 32
    1f70:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f72:	8b 81       	ldd	r24, Y+3	; 0x03
    1f74:	9c 81       	ldd	r25, Y+4	; 0x04
    1f76:	01 97       	sbiw	r24, 0x01	; 1
    1f78:	9c 83       	std	Y+4, r25	; 0x04
    1f7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1f7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f80:	81 e2       	ldi	r24, 0x21	; 33
    1f82:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f84:	8b 81       	ldd	r24, Y+3	; 0x03
    1f86:	9c 81       	ldd	r25, Y+4	; 0x04
    1f88:	01 97       	sbiw	r24, 0x01	; 1
    1f8a:	9c 83       	std	Y+4, r25	; 0x04
    1f8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1f8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f90:	fc 81       	ldd	r31, Y+4	; 0x04
    1f92:	82 e2       	ldi	r24, 0x22	; 34
    1f94:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f96:	8b 81       	ldd	r24, Y+3	; 0x03
    1f98:	9c 81       	ldd	r25, Y+4	; 0x04
    1f9a:	01 97       	sbiw	r24, 0x01	; 1
    1f9c:	9c 83       	std	Y+4, r25	; 0x04
    1f9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa4:	83 e2       	ldi	r24, 0x23	; 35
    1fa6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fa8:	8b 81       	ldd	r24, Y+3	; 0x03
    1faa:	9c 81       	ldd	r25, Y+4	; 0x04
    1fac:	01 97       	sbiw	r24, 0x01	; 1
    1fae:	9c 83       	std	Y+4, r25	; 0x04
    1fb0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1fb2:	8f 81       	ldd	r24, Y+7	; 0x07
    1fb4:	98 85       	ldd	r25, Y+8	; 0x08
    1fb6:	9a 83       	std	Y+2, r25	; 0x02
    1fb8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1fba:	89 81       	ldd	r24, Y+1	; 0x01
    1fbc:	eb 81       	ldd	r30, Y+3	; 0x03
    1fbe:	fc 81       	ldd	r31, Y+4	; 0x04
    1fc0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fc6:	01 97       	sbiw	r24, 0x01	; 1
    1fc8:	9c 83       	std	Y+4, r25	; 0x04
    1fca:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1fcc:	89 81       	ldd	r24, Y+1	; 0x01
    1fce:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd0:	89 2f       	mov	r24, r25
    1fd2:	99 27       	eor	r25, r25
    1fd4:	9a 83       	std	Y+2, r25	; 0x02
    1fd6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1fd8:	89 81       	ldd	r24, Y+1	; 0x01
    1fda:	eb 81       	ldd	r30, Y+3	; 0x03
    1fdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1fde:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe4:	01 97       	sbiw	r24, 0x01	; 1
    1fe6:	9c 83       	std	Y+4, r25	; 0x04
    1fe8:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1fea:	eb 81       	ldd	r30, Y+3	; 0x03
    1fec:	fc 81       	ldd	r31, Y+4	; 0x04
    1fee:	86 e2       	ldi	r24, 0x26	; 38
    1ff0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ff6:	01 97       	sbiw	r24, 0x01	; 1
    1ff8:	9c 83       	std	Y+4, r25	; 0x04
    1ffa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    2000:	87 e2       	ldi	r24, 0x27	; 39
    2002:	80 83       	st	Z, r24
	pxTopOfStack--;
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	9c 81       	ldd	r25, Y+4	; 0x04
    2008:	01 97       	sbiw	r24, 0x01	; 1
    200a:	9c 83       	std	Y+4, r25	; 0x04
    200c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    200e:	eb 81       	ldd	r30, Y+3	; 0x03
    2010:	fc 81       	ldd	r31, Y+4	; 0x04
    2012:	88 e2       	ldi	r24, 0x28	; 40
    2014:	80 83       	st	Z, r24
	pxTopOfStack--;
    2016:	8b 81       	ldd	r24, Y+3	; 0x03
    2018:	9c 81       	ldd	r25, Y+4	; 0x04
    201a:	01 97       	sbiw	r24, 0x01	; 1
    201c:	9c 83       	std	Y+4, r25	; 0x04
    201e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2020:	eb 81       	ldd	r30, Y+3	; 0x03
    2022:	fc 81       	ldd	r31, Y+4	; 0x04
    2024:	89 e2       	ldi	r24, 0x29	; 41
    2026:	80 83       	st	Z, r24
	pxTopOfStack--;
    2028:	8b 81       	ldd	r24, Y+3	; 0x03
    202a:	9c 81       	ldd	r25, Y+4	; 0x04
    202c:	01 97       	sbiw	r24, 0x01	; 1
    202e:	9c 83       	std	Y+4, r25	; 0x04
    2030:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2032:	eb 81       	ldd	r30, Y+3	; 0x03
    2034:	fc 81       	ldd	r31, Y+4	; 0x04
    2036:	80 e3       	ldi	r24, 0x30	; 48
    2038:	80 83       	st	Z, r24
	pxTopOfStack--;
    203a:	8b 81       	ldd	r24, Y+3	; 0x03
    203c:	9c 81       	ldd	r25, Y+4	; 0x04
    203e:	01 97       	sbiw	r24, 0x01	; 1
    2040:	9c 83       	std	Y+4, r25	; 0x04
    2042:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2044:	eb 81       	ldd	r30, Y+3	; 0x03
    2046:	fc 81       	ldd	r31, Y+4	; 0x04
    2048:	81 e3       	ldi	r24, 0x31	; 49
    204a:	80 83       	st	Z, r24
	pxTopOfStack--;
    204c:	8b 81       	ldd	r24, Y+3	; 0x03
    204e:	9c 81       	ldd	r25, Y+4	; 0x04
    2050:	01 97       	sbiw	r24, 0x01	; 1
    2052:	9c 83       	std	Y+4, r25	; 0x04
    2054:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2056:	8b 81       	ldd	r24, Y+3	; 0x03
    2058:	9c 81       	ldd	r25, Y+4	; 0x04
}
    205a:	28 96       	adiw	r28, 0x08	; 8
    205c:	0f b6       	in	r0, 0x3f	; 63
    205e:	f8 94       	cli
    2060:	de bf       	out	0x3e, r29	; 62
    2062:	0f be       	out	0x3f, r0	; 63
    2064:	cd bf       	out	0x3d, r28	; 61
    2066:	cf 91       	pop	r28
    2068:	df 91       	pop	r29
    206a:	08 95       	ret

0000206c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    206c:	df 93       	push	r29
    206e:	cf 93       	push	r28
    2070:	cd b7       	in	r28, 0x3d	; 61
    2072:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2074:	0e 94 28 11 	call	0x2250	; 0x2250 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2078:	a0 91 30 07 	lds	r26, 0x0730
    207c:	b0 91 31 07 	lds	r27, 0x0731
    2080:	cd 91       	ld	r28, X+
    2082:	cd bf       	out	0x3d, r28	; 61
    2084:	dd 91       	ld	r29, X+
    2086:	de bf       	out	0x3e, r29	; 62
    2088:	ff 91       	pop	r31
    208a:	ef 91       	pop	r30
    208c:	df 91       	pop	r29
    208e:	cf 91       	pop	r28
    2090:	bf 91       	pop	r27
    2092:	af 91       	pop	r26
    2094:	9f 91       	pop	r25
    2096:	8f 91       	pop	r24
    2098:	7f 91       	pop	r23
    209a:	6f 91       	pop	r22
    209c:	5f 91       	pop	r21
    209e:	4f 91       	pop	r20
    20a0:	3f 91       	pop	r19
    20a2:	2f 91       	pop	r18
    20a4:	1f 91       	pop	r17
    20a6:	0f 91       	pop	r16
    20a8:	ff 90       	pop	r15
    20aa:	ef 90       	pop	r14
    20ac:	df 90       	pop	r13
    20ae:	cf 90       	pop	r12
    20b0:	bf 90       	pop	r11
    20b2:	af 90       	pop	r10
    20b4:	9f 90       	pop	r9
    20b6:	8f 90       	pop	r8
    20b8:	7f 90       	pop	r7
    20ba:	6f 90       	pop	r6
    20bc:	5f 90       	pop	r5
    20be:	4f 90       	pop	r4
    20c0:	3f 90       	pop	r3
    20c2:	2f 90       	pop	r2
    20c4:	1f 90       	pop	r1
    20c6:	0f 90       	pop	r0
    20c8:	0f be       	out	0x3f, r0	; 63
    20ca:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    20cc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    20ce:	81 e0       	ldi	r24, 0x01	; 1
}
    20d0:	cf 91       	pop	r28
    20d2:	df 91       	pop	r29
    20d4:	08 95       	ret

000020d6 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    20d6:	df 93       	push	r29
    20d8:	cf 93       	push	r28
    20da:	cd b7       	in	r28, 0x3d	; 61
    20dc:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    20de:	cf 91       	pop	r28
    20e0:	df 91       	pop	r29
    20e2:	08 95       	ret

000020e4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    20e4:	0f 92       	push	r0
    20e6:	0f b6       	in	r0, 0x3f	; 63
    20e8:	f8 94       	cli
    20ea:	0f 92       	push	r0
    20ec:	1f 92       	push	r1
    20ee:	11 24       	eor	r1, r1
    20f0:	2f 92       	push	r2
    20f2:	3f 92       	push	r3
    20f4:	4f 92       	push	r4
    20f6:	5f 92       	push	r5
    20f8:	6f 92       	push	r6
    20fa:	7f 92       	push	r7
    20fc:	8f 92       	push	r8
    20fe:	9f 92       	push	r9
    2100:	af 92       	push	r10
    2102:	bf 92       	push	r11
    2104:	cf 92       	push	r12
    2106:	df 92       	push	r13
    2108:	ef 92       	push	r14
    210a:	ff 92       	push	r15
    210c:	0f 93       	push	r16
    210e:	1f 93       	push	r17
    2110:	2f 93       	push	r18
    2112:	3f 93       	push	r19
    2114:	4f 93       	push	r20
    2116:	5f 93       	push	r21
    2118:	6f 93       	push	r22
    211a:	7f 93       	push	r23
    211c:	8f 93       	push	r24
    211e:	9f 93       	push	r25
    2120:	af 93       	push	r26
    2122:	bf 93       	push	r27
    2124:	cf 93       	push	r28
    2126:	df 93       	push	r29
    2128:	ef 93       	push	r30
    212a:	ff 93       	push	r31
    212c:	a0 91 30 07 	lds	r26, 0x0730
    2130:	b0 91 31 07 	lds	r27, 0x0731
    2134:	0d b6       	in	r0, 0x3d	; 61
    2136:	0d 92       	st	X+, r0
    2138:	0e b6       	in	r0, 0x3e	; 62
    213a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    213c:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2140:	a0 91 30 07 	lds	r26, 0x0730
    2144:	b0 91 31 07 	lds	r27, 0x0731
    2148:	cd 91       	ld	r28, X+
    214a:	cd bf       	out	0x3d, r28	; 61
    214c:	dd 91       	ld	r29, X+
    214e:	de bf       	out	0x3e, r29	; 62
    2150:	ff 91       	pop	r31
    2152:	ef 91       	pop	r30
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	bf 91       	pop	r27
    215a:	af 91       	pop	r26
    215c:	9f 91       	pop	r25
    215e:	8f 91       	pop	r24
    2160:	7f 91       	pop	r23
    2162:	6f 91       	pop	r22
    2164:	5f 91       	pop	r21
    2166:	4f 91       	pop	r20
    2168:	3f 91       	pop	r19
    216a:	2f 91       	pop	r18
    216c:	1f 91       	pop	r17
    216e:	0f 91       	pop	r16
    2170:	ff 90       	pop	r15
    2172:	ef 90       	pop	r14
    2174:	df 90       	pop	r13
    2176:	cf 90       	pop	r12
    2178:	bf 90       	pop	r11
    217a:	af 90       	pop	r10
    217c:	9f 90       	pop	r9
    217e:	8f 90       	pop	r8
    2180:	7f 90       	pop	r7
    2182:	6f 90       	pop	r6
    2184:	5f 90       	pop	r5
    2186:	4f 90       	pop	r4
    2188:	3f 90       	pop	r3
    218a:	2f 90       	pop	r2
    218c:	1f 90       	pop	r1
    218e:	0f 90       	pop	r0
    2190:	0f be       	out	0x3f, r0	; 63
    2192:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2194:	08 95       	ret

00002196 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2196:	0f 92       	push	r0
    2198:	0f b6       	in	r0, 0x3f	; 63
    219a:	f8 94       	cli
    219c:	0f 92       	push	r0
    219e:	1f 92       	push	r1
    21a0:	11 24       	eor	r1, r1
    21a2:	2f 92       	push	r2
    21a4:	3f 92       	push	r3
    21a6:	4f 92       	push	r4
    21a8:	5f 92       	push	r5
    21aa:	6f 92       	push	r6
    21ac:	7f 92       	push	r7
    21ae:	8f 92       	push	r8
    21b0:	9f 92       	push	r9
    21b2:	af 92       	push	r10
    21b4:	bf 92       	push	r11
    21b6:	cf 92       	push	r12
    21b8:	df 92       	push	r13
    21ba:	ef 92       	push	r14
    21bc:	ff 92       	push	r15
    21be:	0f 93       	push	r16
    21c0:	1f 93       	push	r17
    21c2:	2f 93       	push	r18
    21c4:	3f 93       	push	r19
    21c6:	4f 93       	push	r20
    21c8:	5f 93       	push	r21
    21ca:	6f 93       	push	r22
    21cc:	7f 93       	push	r23
    21ce:	8f 93       	push	r24
    21d0:	9f 93       	push	r25
    21d2:	af 93       	push	r26
    21d4:	bf 93       	push	r27
    21d6:	cf 93       	push	r28
    21d8:	df 93       	push	r29
    21da:	ef 93       	push	r30
    21dc:	ff 93       	push	r31
    21de:	a0 91 30 07 	lds	r26, 0x0730
    21e2:	b0 91 31 07 	lds	r27, 0x0731
    21e6:	0d b6       	in	r0, 0x3d	; 61
    21e8:	0d 92       	st	X+, r0
    21ea:	0e b6       	in	r0, 0x3e	; 62
    21ec:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    21ee:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <xTaskIncrementTick>
    21f2:	88 23       	and	r24, r24
    21f4:	11 f0       	breq	.+4      	; 0x21fa <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    21f6:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    21fa:	a0 91 30 07 	lds	r26, 0x0730
    21fe:	b0 91 31 07 	lds	r27, 0x0731
    2202:	cd 91       	ld	r28, X+
    2204:	cd bf       	out	0x3d, r28	; 61
    2206:	dd 91       	ld	r29, X+
    2208:	de bf       	out	0x3e, r29	; 62
    220a:	ff 91       	pop	r31
    220c:	ef 91       	pop	r30
    220e:	df 91       	pop	r29
    2210:	cf 91       	pop	r28
    2212:	bf 91       	pop	r27
    2214:	af 91       	pop	r26
    2216:	9f 91       	pop	r25
    2218:	8f 91       	pop	r24
    221a:	7f 91       	pop	r23
    221c:	6f 91       	pop	r22
    221e:	5f 91       	pop	r21
    2220:	4f 91       	pop	r20
    2222:	3f 91       	pop	r19
    2224:	2f 91       	pop	r18
    2226:	1f 91       	pop	r17
    2228:	0f 91       	pop	r16
    222a:	ff 90       	pop	r15
    222c:	ef 90       	pop	r14
    222e:	df 90       	pop	r13
    2230:	cf 90       	pop	r12
    2232:	bf 90       	pop	r11
    2234:	af 90       	pop	r10
    2236:	9f 90       	pop	r9
    2238:	8f 90       	pop	r8
    223a:	7f 90       	pop	r7
    223c:	6f 90       	pop	r6
    223e:	5f 90       	pop	r5
    2240:	4f 90       	pop	r4
    2242:	3f 90       	pop	r3
    2244:	2f 90       	pop	r2
    2246:	1f 90       	pop	r1
    2248:	0f 90       	pop	r0
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    224e:	08 95       	ret

00002250 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2250:	df 93       	push	r29
    2252:	cf 93       	push	r28
    2254:	00 d0       	rcall	.+0      	; 0x2256 <prvSetupTimerInterrupt+0x6>
    2256:	00 d0       	rcall	.+0      	; 0x2258 <prvSetupTimerInterrupt+0x8>
    2258:	00 d0       	rcall	.+0      	; 0x225a <prvSetupTimerInterrupt+0xa>
    225a:	cd b7       	in	r28, 0x3d	; 61
    225c:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    225e:	80 e4       	ldi	r24, 0x40	; 64
    2260:	9f e1       	ldi	r25, 0x1F	; 31
    2262:	a0 e0       	ldi	r26, 0x00	; 0
    2264:	b0 e0       	ldi	r27, 0x00	; 0
    2266:	8b 83       	std	Y+3, r24	; 0x03
    2268:	9c 83       	std	Y+4, r25	; 0x04
    226a:	ad 83       	std	Y+5, r26	; 0x05
    226c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    226e:	8b 81       	ldd	r24, Y+3	; 0x03
    2270:	9c 81       	ldd	r25, Y+4	; 0x04
    2272:	ad 81       	ldd	r26, Y+5	; 0x05
    2274:	be 81       	ldd	r27, Y+6	; 0x06
    2276:	68 94       	set
    2278:	15 f8       	bld	r1, 5
    227a:	b6 95       	lsr	r27
    227c:	a7 95       	ror	r26
    227e:	97 95       	ror	r25
    2280:	87 95       	ror	r24
    2282:	16 94       	lsr	r1
    2284:	d1 f7       	brne	.-12     	; 0x227a <prvSetupTimerInterrupt+0x2a>
    2286:	8b 83       	std	Y+3, r24	; 0x03
    2288:	9c 83       	std	Y+4, r25	; 0x04
    228a:	ad 83       	std	Y+5, r26	; 0x05
    228c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    228e:	8b 81       	ldd	r24, Y+3	; 0x03
    2290:	9c 81       	ldd	r25, Y+4	; 0x04
    2292:	ad 81       	ldd	r26, Y+5	; 0x05
    2294:	be 81       	ldd	r27, Y+6	; 0x06
    2296:	01 97       	sbiw	r24, 0x01	; 1
    2298:	a1 09       	sbc	r26, r1
    229a:	b1 09       	sbc	r27, r1
    229c:	8b 83       	std	Y+3, r24	; 0x03
    229e:	9c 83       	std	Y+4, r25	; 0x04
    22a0:	ad 83       	std	Y+5, r26	; 0x05
    22a2:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    22a4:	8b 81       	ldd	r24, Y+3	; 0x03
    22a6:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    22a8:	8b 81       	ldd	r24, Y+3	; 0x03
    22aa:	9c 81       	ldd	r25, Y+4	; 0x04
    22ac:	ad 81       	ldd	r26, Y+5	; 0x05
    22ae:	be 81       	ldd	r27, Y+6	; 0x06
    22b0:	89 2f       	mov	r24, r25
    22b2:	9a 2f       	mov	r25, r26
    22b4:	ab 2f       	mov	r26, r27
    22b6:	bb 27       	eor	r27, r27
    22b8:	8b 83       	std	Y+3, r24	; 0x03
    22ba:	9c 83       	std	Y+4, r25	; 0x04
    22bc:	ad 83       	std	Y+5, r26	; 0x05
    22be:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    22c0:	8b 81       	ldd	r24, Y+3	; 0x03
    22c2:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    22c4:	eb e4       	ldi	r30, 0x4B	; 75
    22c6:	f0 e0       	ldi	r31, 0x00	; 0
    22c8:	8a 81       	ldd	r24, Y+2	; 0x02
    22ca:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    22cc:	ea e4       	ldi	r30, 0x4A	; 74
    22ce:	f0 e0       	ldi	r31, 0x00	; 0
    22d0:	89 81       	ldd	r24, Y+1	; 0x01
    22d2:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    22d4:	8b e0       	ldi	r24, 0x0B	; 11
    22d6:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    22d8:	ee e4       	ldi	r30, 0x4E	; 78
    22da:	f0 e0       	ldi	r31, 0x00	; 0
    22dc:	89 81       	ldd	r24, Y+1	; 0x01
    22de:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    22e0:	e9 e5       	ldi	r30, 0x59	; 89
    22e2:	f0 e0       	ldi	r31, 0x00	; 0
    22e4:	80 81       	ld	r24, Z
    22e6:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    22e8:	89 81       	ldd	r24, Y+1	; 0x01
    22ea:	80 61       	ori	r24, 0x10	; 16
    22ec:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    22ee:	e9 e5       	ldi	r30, 0x59	; 89
    22f0:	f0 e0       	ldi	r31, 0x00	; 0
    22f2:	89 81       	ldd	r24, Y+1	; 0x01
    22f4:	80 83       	st	Z, r24
}
    22f6:	26 96       	adiw	r28, 0x06	; 6
    22f8:	0f b6       	in	r0, 0x3f	; 63
    22fa:	f8 94       	cli
    22fc:	de bf       	out	0x3e, r29	; 62
    22fe:	0f be       	out	0x3f, r0	; 63
    2300:	cd bf       	out	0x3d, r28	; 61
    2302:	cf 91       	pop	r28
    2304:	df 91       	pop	r29
    2306:	08 95       	ret

00002308 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2308:	0e 94 cb 10 	call	0x2196	; 0x2196 <vPortYieldFromTick>
		asm volatile ( "reti" );
    230c:	18 95       	reti

0000230e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    230e:	df 93       	push	r29
    2310:	cf 93       	push	r28
    2312:	00 d0       	rcall	.+0      	; 0x2314 <xQueueGenericReset+0x6>
    2314:	00 d0       	rcall	.+0      	; 0x2316 <xQueueGenericReset+0x8>
    2316:	0f 92       	push	r0
    2318:	cd b7       	in	r28, 0x3d	; 61
    231a:	de b7       	in	r29, 0x3e	; 62
    231c:	9c 83       	std	Y+4, r25	; 0x04
    231e:	8b 83       	std	Y+3, r24	; 0x03
    2320:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2322:	8b 81       	ldd	r24, Y+3	; 0x03
    2324:	9c 81       	ldd	r25, Y+4	; 0x04
    2326:	9a 83       	std	Y+2, r25	; 0x02
    2328:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    232a:	0f b6       	in	r0, 0x3f	; 63
    232c:	f8 94       	cli
    232e:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2330:	e9 81       	ldd	r30, Y+1	; 0x01
    2332:	fa 81       	ldd	r31, Y+2	; 0x02
    2334:	40 81       	ld	r20, Z
    2336:	51 81       	ldd	r21, Z+1	; 0x01
    2338:	e9 81       	ldd	r30, Y+1	; 0x01
    233a:	fa 81       	ldd	r31, Y+2	; 0x02
    233c:	83 8d       	ldd	r24, Z+27	; 0x1b
    233e:	28 2f       	mov	r18, r24
    2340:	30 e0       	ldi	r19, 0x00	; 0
    2342:	e9 81       	ldd	r30, Y+1	; 0x01
    2344:	fa 81       	ldd	r31, Y+2	; 0x02
    2346:	84 8d       	ldd	r24, Z+28	; 0x1c
    2348:	88 2f       	mov	r24, r24
    234a:	90 e0       	ldi	r25, 0x00	; 0
    234c:	bc 01       	movw	r22, r24
    234e:	26 9f       	mul	r18, r22
    2350:	c0 01       	movw	r24, r0
    2352:	27 9f       	mul	r18, r23
    2354:	90 0d       	add	r25, r0
    2356:	36 9f       	mul	r19, r22
    2358:	90 0d       	add	r25, r0
    235a:	11 24       	eor	r1, r1
    235c:	84 0f       	add	r24, r20
    235e:	95 1f       	adc	r25, r21
    2360:	e9 81       	ldd	r30, Y+1	; 0x01
    2362:	fa 81       	ldd	r31, Y+2	; 0x02
    2364:	93 83       	std	Z+3, r25	; 0x03
    2366:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2368:	e9 81       	ldd	r30, Y+1	; 0x01
    236a:	fa 81       	ldd	r31, Y+2	; 0x02
    236c:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    236e:	e9 81       	ldd	r30, Y+1	; 0x01
    2370:	fa 81       	ldd	r31, Y+2	; 0x02
    2372:	80 81       	ld	r24, Z
    2374:	91 81       	ldd	r25, Z+1	; 0x01
    2376:	e9 81       	ldd	r30, Y+1	; 0x01
    2378:	fa 81       	ldd	r31, Y+2	; 0x02
    237a:	95 83       	std	Z+5, r25	; 0x05
    237c:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    237e:	e9 81       	ldd	r30, Y+1	; 0x01
    2380:	fa 81       	ldd	r31, Y+2	; 0x02
    2382:	40 81       	ld	r20, Z
    2384:	51 81       	ldd	r21, Z+1	; 0x01
    2386:	e9 81       	ldd	r30, Y+1	; 0x01
    2388:	fa 81       	ldd	r31, Y+2	; 0x02
    238a:	83 8d       	ldd	r24, Z+27	; 0x1b
    238c:	88 2f       	mov	r24, r24
    238e:	90 e0       	ldi	r25, 0x00	; 0
    2390:	9c 01       	movw	r18, r24
    2392:	21 50       	subi	r18, 0x01	; 1
    2394:	30 40       	sbci	r19, 0x00	; 0
    2396:	e9 81       	ldd	r30, Y+1	; 0x01
    2398:	fa 81       	ldd	r31, Y+2	; 0x02
    239a:	84 8d       	ldd	r24, Z+28	; 0x1c
    239c:	88 2f       	mov	r24, r24
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	bc 01       	movw	r22, r24
    23a2:	26 9f       	mul	r18, r22
    23a4:	c0 01       	movw	r24, r0
    23a6:	27 9f       	mul	r18, r23
    23a8:	90 0d       	add	r25, r0
    23aa:	36 9f       	mul	r19, r22
    23ac:	90 0d       	add	r25, r0
    23ae:	11 24       	eor	r1, r1
    23b0:	84 0f       	add	r24, r20
    23b2:	95 1f       	adc	r25, r21
    23b4:	e9 81       	ldd	r30, Y+1	; 0x01
    23b6:	fa 81       	ldd	r31, Y+2	; 0x02
    23b8:	97 83       	std	Z+7, r25	; 0x07
    23ba:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    23bc:	e9 81       	ldd	r30, Y+1	; 0x01
    23be:	fa 81       	ldd	r31, Y+2	; 0x02
    23c0:	8f ef       	ldi	r24, 0xFF	; 255
    23c2:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    23c4:	e9 81       	ldd	r30, Y+1	; 0x01
    23c6:	fa 81       	ldd	r31, Y+2	; 0x02
    23c8:	8f ef       	ldi	r24, 0xFF	; 255
    23ca:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    23cc:	8d 81       	ldd	r24, Y+5	; 0x05
    23ce:	88 23       	and	r24, r24
    23d0:	79 f4       	brne	.+30     	; 0x23f0 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    23d2:	e9 81       	ldd	r30, Y+1	; 0x01
    23d4:	fa 81       	ldd	r31, Y+2	; 0x02
    23d6:	80 85       	ldd	r24, Z+8	; 0x08
    23d8:	88 23       	and	r24, r24
    23da:	a1 f0       	breq	.+40     	; 0x2404 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23dc:	89 81       	ldd	r24, Y+1	; 0x01
    23de:	9a 81       	ldd	r25, Y+2	; 0x02
    23e0:	08 96       	adiw	r24, 0x08	; 8
    23e2:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    23e6:	88 23       	and	r24, r24
    23e8:	69 f0       	breq	.+26     	; 0x2404 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    23ea:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
    23ee:	0a c0       	rjmp	.+20     	; 0x2404 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    23f0:	89 81       	ldd	r24, Y+1	; 0x01
    23f2:	9a 81       	ldd	r25, Y+2	; 0x02
    23f4:	08 96       	adiw	r24, 0x08	; 8
    23f6:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    23fa:	89 81       	ldd	r24, Y+1	; 0x01
    23fc:	9a 81       	ldd	r25, Y+2	; 0x02
    23fe:	41 96       	adiw	r24, 0x11	; 17
    2400:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2404:	0f 90       	pop	r0
    2406:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2408:	81 e0       	ldi	r24, 0x01	; 1
}
    240a:	0f 90       	pop	r0
    240c:	0f 90       	pop	r0
    240e:	0f 90       	pop	r0
    2410:	0f 90       	pop	r0
    2412:	0f 90       	pop	r0
    2414:	cf 91       	pop	r28
    2416:	df 91       	pop	r29
    2418:	08 95       	ret

0000241a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    241a:	0f 93       	push	r16
    241c:	1f 93       	push	r17
    241e:	df 93       	push	r29
    2420:	cf 93       	push	r28
    2422:	cd b7       	in	r28, 0x3d	; 61
    2424:	de b7       	in	r29, 0x3e	; 62
    2426:	29 97       	sbiw	r28, 0x09	; 9
    2428:	0f b6       	in	r0, 0x3f	; 63
    242a:	f8 94       	cli
    242c:	de bf       	out	0x3e, r29	; 62
    242e:	0f be       	out	0x3f, r0	; 63
    2430:	cd bf       	out	0x3d, r28	; 61
    2432:	8f 83       	std	Y+7, r24	; 0x07
    2434:	68 87       	std	Y+8, r22	; 0x08
    2436:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    2438:	88 85       	ldd	r24, Y+8	; 0x08
    243a:	88 23       	and	r24, r24
    243c:	19 f4       	brne	.+6      	; 0x2444 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    243e:	1c 82       	std	Y+4, r1	; 0x04
    2440:	1b 82       	std	Y+3, r1	; 0x03
    2442:	10 c0       	rjmp	.+32     	; 0x2464 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2444:	8f 81       	ldd	r24, Y+7	; 0x07
    2446:	28 2f       	mov	r18, r24
    2448:	30 e0       	ldi	r19, 0x00	; 0
    244a:	88 85       	ldd	r24, Y+8	; 0x08
    244c:	88 2f       	mov	r24, r24
    244e:	90 e0       	ldi	r25, 0x00	; 0
    2450:	ac 01       	movw	r20, r24
    2452:	24 9f       	mul	r18, r20
    2454:	c0 01       	movw	r24, r0
    2456:	25 9f       	mul	r18, r21
    2458:	90 0d       	add	r25, r0
    245a:	34 9f       	mul	r19, r20
    245c:	90 0d       	add	r25, r0
    245e:	11 24       	eor	r1, r1
    2460:	9c 83       	std	Y+4, r25	; 0x04
    2462:	8b 83       	std	Y+3, r24	; 0x03
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    2464:	8b 81       	ldd	r24, Y+3	; 0x03
    2466:	9c 81       	ldd	r25, Y+4	; 0x04
    2468:	4f 96       	adiw	r24, 0x1f	; 31
    246a:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <pvPortMalloc>
    246e:	9e 83       	std	Y+6, r25	; 0x06
    2470:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    2472:	8d 81       	ldd	r24, Y+5	; 0x05
    2474:	9e 81       	ldd	r25, Y+6	; 0x06
    2476:	00 97       	sbiw	r24, 0x00	; 0
    2478:	81 f0       	breq	.+32     	; 0x249a <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    247a:	8d 81       	ldd	r24, Y+5	; 0x05
    247c:	9e 81       	ldd	r25, Y+6	; 0x06
    247e:	4f 96       	adiw	r24, 0x1f	; 31
    2480:	9a 83       	std	Y+2, r25	; 0x02
    2482:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2484:	29 81       	ldd	r18, Y+1	; 0x01
    2486:	3a 81       	ldd	r19, Y+2	; 0x02
    2488:	ed 81       	ldd	r30, Y+5	; 0x05
    248a:	fe 81       	ldd	r31, Y+6	; 0x06
    248c:	8f 81       	ldd	r24, Y+7	; 0x07
    248e:	68 85       	ldd	r22, Y+8	; 0x08
    2490:	a9 01       	movw	r20, r18
    2492:	29 85       	ldd	r18, Y+9	; 0x09
    2494:	8f 01       	movw	r16, r30
    2496:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
    249a:	8d 81       	ldd	r24, Y+5	; 0x05
    249c:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    249e:	29 96       	adiw	r28, 0x09	; 9
    24a0:	0f b6       	in	r0, 0x3f	; 63
    24a2:	f8 94       	cli
    24a4:	de bf       	out	0x3e, r29	; 62
    24a6:	0f be       	out	0x3f, r0	; 63
    24a8:	cd bf       	out	0x3d, r28	; 61
    24aa:	cf 91       	pop	r28
    24ac:	df 91       	pop	r29
    24ae:	1f 91       	pop	r17
    24b0:	0f 91       	pop	r16
    24b2:	08 95       	ret

000024b4 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    24b4:	0f 93       	push	r16
    24b6:	1f 93       	push	r17
    24b8:	df 93       	push	r29
    24ba:	cf 93       	push	r28
    24bc:	cd b7       	in	r28, 0x3d	; 61
    24be:	de b7       	in	r29, 0x3e	; 62
    24c0:	27 97       	sbiw	r28, 0x07	; 7
    24c2:	0f b6       	in	r0, 0x3f	; 63
    24c4:	f8 94       	cli
    24c6:	de bf       	out	0x3e, r29	; 62
    24c8:	0f be       	out	0x3f, r0	; 63
    24ca:	cd bf       	out	0x3d, r28	; 61
    24cc:	89 83       	std	Y+1, r24	; 0x01
    24ce:	6a 83       	std	Y+2, r22	; 0x02
    24d0:	5c 83       	std	Y+4, r21	; 0x04
    24d2:	4b 83       	std	Y+3, r20	; 0x03
    24d4:	2d 83       	std	Y+5, r18	; 0x05
    24d6:	1f 83       	std	Y+7, r17	; 0x07
    24d8:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    24da:	8a 81       	ldd	r24, Y+2	; 0x02
    24dc:	88 23       	and	r24, r24
    24de:	39 f4       	brne	.+14     	; 0x24ee <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    24e0:	8e 81       	ldd	r24, Y+6	; 0x06
    24e2:	9f 81       	ldd	r25, Y+7	; 0x07
    24e4:	ee 81       	ldd	r30, Y+6	; 0x06
    24e6:	ff 81       	ldd	r31, Y+7	; 0x07
    24e8:	91 83       	std	Z+1, r25	; 0x01
    24ea:	80 83       	st	Z, r24
    24ec:	06 c0       	rjmp	.+12     	; 0x24fa <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    24ee:	8b 81       	ldd	r24, Y+3	; 0x03
    24f0:	9c 81       	ldd	r25, Y+4	; 0x04
    24f2:	ee 81       	ldd	r30, Y+6	; 0x06
    24f4:	ff 81       	ldd	r31, Y+7	; 0x07
    24f6:	91 83       	std	Z+1, r25	; 0x01
    24f8:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    24fa:	ee 81       	ldd	r30, Y+6	; 0x06
    24fc:	ff 81       	ldd	r31, Y+7	; 0x07
    24fe:	89 81       	ldd	r24, Y+1	; 0x01
    2500:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    2502:	ee 81       	ldd	r30, Y+6	; 0x06
    2504:	ff 81       	ldd	r31, Y+7	; 0x07
    2506:	8a 81       	ldd	r24, Y+2	; 0x02
    2508:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    250a:	8e 81       	ldd	r24, Y+6	; 0x06
    250c:	9f 81       	ldd	r25, Y+7	; 0x07
    250e:	61 e0       	ldi	r22, 0x01	; 1
    2510:	0e 94 87 11 	call	0x230e	; 0x230e <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    2514:	27 96       	adiw	r28, 0x07	; 7
    2516:	0f b6       	in	r0, 0x3f	; 63
    2518:	f8 94       	cli
    251a:	de bf       	out	0x3e, r29	; 62
    251c:	0f be       	out	0x3f, r0	; 63
    251e:	cd bf       	out	0x3d, r28	; 61
    2520:	cf 91       	pop	r28
    2522:	df 91       	pop	r29
    2524:	1f 91       	pop	r17
    2526:	0f 91       	pop	r16
    2528:	08 95       	ret

0000252a <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    252a:	df 93       	push	r29
    252c:	cf 93       	push	r28
    252e:	00 d0       	rcall	.+0      	; 0x2530 <prvInitialiseMutex+0x6>
    2530:	cd b7       	in	r28, 0x3d	; 61
    2532:	de b7       	in	r29, 0x3e	; 62
    2534:	9a 83       	std	Y+2, r25	; 0x02
    2536:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    2538:	89 81       	ldd	r24, Y+1	; 0x01
    253a:	9a 81       	ldd	r25, Y+2	; 0x02
    253c:	00 97       	sbiw	r24, 0x00	; 0
    253e:	a1 f0       	breq	.+40     	; 0x2568 <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    2540:	e9 81       	ldd	r30, Y+1	; 0x01
    2542:	fa 81       	ldd	r31, Y+2	; 0x02
    2544:	13 82       	std	Z+3, r1	; 0x03
    2546:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    2548:	e9 81       	ldd	r30, Y+1	; 0x01
    254a:	fa 81       	ldd	r31, Y+2	; 0x02
    254c:	11 82       	std	Z+1, r1	; 0x01
    254e:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    2550:	e9 81       	ldd	r30, Y+1	; 0x01
    2552:	fa 81       	ldd	r31, Y+2	; 0x02
    2554:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    2556:	89 81       	ldd	r24, Y+1	; 0x01
    2558:	9a 81       	ldd	r25, Y+2	; 0x02
    255a:	60 e0       	ldi	r22, 0x00	; 0
    255c:	70 e0       	ldi	r23, 0x00	; 0
    255e:	40 e0       	ldi	r20, 0x00	; 0
    2560:	50 e0       	ldi	r21, 0x00	; 0
    2562:	20 e0       	ldi	r18, 0x00	; 0
    2564:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    2568:	0f 90       	pop	r0
    256a:	0f 90       	pop	r0
    256c:	cf 91       	pop	r28
    256e:	df 91       	pop	r29
    2570:	08 95       	ret

00002572 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    2572:	df 93       	push	r29
    2574:	cf 93       	push	r28
    2576:	00 d0       	rcall	.+0      	; 0x2578 <xQueueCreateMutex+0x6>
    2578:	00 d0       	rcall	.+0      	; 0x257a <xQueueCreateMutex+0x8>
    257a:	0f 92       	push	r0
    257c:	cd b7       	in	r28, 0x3d	; 61
    257e:	de b7       	in	r29, 0x3e	; 62
    2580:	8d 83       	std	Y+5, r24	; 0x05
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	8a 83       	std	Y+2, r24	; 0x02
    2586:	19 82       	std	Y+1, r1	; 0x01

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    2588:	8a 81       	ldd	r24, Y+2	; 0x02
    258a:	69 81       	ldd	r22, Y+1	; 0x01
    258c:	4d 81       	ldd	r20, Y+5	; 0x05
    258e:	0e 94 0d 12 	call	0x241a	; 0x241a <xQueueGenericCreate>
    2592:	9c 83       	std	Y+4, r25	; 0x04
    2594:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( pxNewQueue );
    2596:	8b 81       	ldd	r24, Y+3	; 0x03
    2598:	9c 81       	ldd	r25, Y+4	; 0x04
    259a:	0e 94 95 12 	call	0x252a	; 0x252a <prvInitialiseMutex>

		return pxNewQueue;
    259e:	8b 81       	ldd	r24, Y+3	; 0x03
    25a0:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    25a2:	0f 90       	pop	r0
    25a4:	0f 90       	pop	r0
    25a6:	0f 90       	pop	r0
    25a8:	0f 90       	pop	r0
    25aa:	0f 90       	pop	r0
    25ac:	cf 91       	pop	r28
    25ae:	df 91       	pop	r29
    25b0:	08 95       	ret

000025b2 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    25b2:	df 93       	push	r29
    25b4:	cf 93       	push	r28
    25b6:	cd b7       	in	r28, 0x3d	; 61
    25b8:	de b7       	in	r29, 0x3e	; 62
    25ba:	2f 97       	sbiw	r28, 0x0f	; 15
    25bc:	0f b6       	in	r0, 0x3f	; 63
    25be:	f8 94       	cli
    25c0:	de bf       	out	0x3e, r29	; 62
    25c2:	0f be       	out	0x3f, r0	; 63
    25c4:	cd bf       	out	0x3d, r28	; 61
    25c6:	99 87       	std	Y+9, r25	; 0x09
    25c8:	88 87       	std	Y+8, r24	; 0x08
    25ca:	7b 87       	std	Y+11, r23	; 0x0b
    25cc:	6a 87       	std	Y+10, r22	; 0x0a
    25ce:	5d 87       	std	Y+13, r21	; 0x0d
    25d0:	4c 87       	std	Y+12, r20	; 0x0c
    25d2:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    25d4:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    25d6:	88 85       	ldd	r24, Y+8	; 0x08
    25d8:	99 85       	ldd	r25, Y+9	; 0x09
    25da:	9a 83       	std	Y+2, r25	; 0x02
    25dc:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    25de:	0f b6       	in	r0, 0x3f	; 63
    25e0:	f8 94       	cli
    25e2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    25e4:	e9 81       	ldd	r30, Y+1	; 0x01
    25e6:	fa 81       	ldd	r31, Y+2	; 0x02
    25e8:	92 8d       	ldd	r25, Z+26	; 0x1a
    25ea:	e9 81       	ldd	r30, Y+1	; 0x01
    25ec:	fa 81       	ldd	r31, Y+2	; 0x02
    25ee:	83 8d       	ldd	r24, Z+27	; 0x1b
    25f0:	98 17       	cp	r25, r24
    25f2:	18 f0       	brcs	.+6      	; 0x25fa <xQueueGenericSend+0x48>
    25f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    25f6:	82 30       	cpi	r24, 0x02	; 2
    25f8:	11 f5       	brne	.+68     	; 0x263e <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    25fa:	89 81       	ldd	r24, Y+1	; 0x01
    25fc:	9a 81       	ldd	r25, Y+2	; 0x02
    25fe:	2a 85       	ldd	r18, Y+10	; 0x0a
    2600:	3b 85       	ldd	r19, Y+11	; 0x0b
    2602:	b9 01       	movw	r22, r18
    2604:	4e 85       	ldd	r20, Y+14	; 0x0e
    2606:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <prvCopyDataToQueue>
    260a:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    260c:	e9 81       	ldd	r30, Y+1	; 0x01
    260e:	fa 81       	ldd	r31, Y+2	; 0x02
    2610:	81 89       	ldd	r24, Z+17	; 0x11
    2612:	88 23       	and	r24, r24
    2614:	51 f0       	breq	.+20     	; 0x262a <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2616:	89 81       	ldd	r24, Y+1	; 0x01
    2618:	9a 81       	ldd	r25, Y+2	; 0x02
    261a:	41 96       	adiw	r24, 0x11	; 17
    261c:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    2620:	88 23       	and	r24, r24
    2622:	41 f0       	breq	.+16     	; 0x2634 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2624:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
    2628:	05 c0       	rjmp	.+10     	; 0x2634 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    262a:	8b 81       	ldd	r24, Y+3	; 0x03
    262c:	88 23       	and	r24, r24
    262e:	11 f0       	breq	.+4      	; 0x2634 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2630:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2634:	0f 90       	pop	r0
    2636:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2638:	81 e0       	ldi	r24, 0x01	; 1
    263a:	8f 87       	std	Y+15, r24	; 0x0f
    263c:	5c c0       	rjmp	.+184    	; 0x26f6 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    263e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2640:	9d 85       	ldd	r25, Y+13	; 0x0d
    2642:	00 97       	sbiw	r24, 0x00	; 0
    2644:	21 f4       	brne	.+8      	; 0x264e <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2646:	0f 90       	pop	r0
    2648:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    264a:	1f 86       	std	Y+15, r1	; 0x0f
    264c:	54 c0       	rjmp	.+168    	; 0x26f6 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    264e:	8c 81       	ldd	r24, Y+4	; 0x04
    2650:	88 23       	and	r24, r24
    2652:	31 f4       	brne	.+12     	; 0x2660 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2654:	ce 01       	movw	r24, r28
    2656:	05 96       	adiw	r24, 0x05	; 5
    2658:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    265c:	81 e0       	ldi	r24, 0x01	; 1
    265e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2660:	0f 90       	pop	r0
    2662:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2664:	0e 94 09 1c 	call	0x3812	; 0x3812 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	0f 92       	push	r0
    266e:	e9 81       	ldd	r30, Y+1	; 0x01
    2670:	fa 81       	ldd	r31, Y+2	; 0x02
    2672:	85 8d       	ldd	r24, Z+29	; 0x1d
    2674:	8f 3f       	cpi	r24, 0xFF	; 255
    2676:	19 f4       	brne	.+6      	; 0x267e <xQueueGenericSend+0xcc>
    2678:	e9 81       	ldd	r30, Y+1	; 0x01
    267a:	fa 81       	ldd	r31, Y+2	; 0x02
    267c:	15 8e       	std	Z+29, r1	; 0x1d
    267e:	e9 81       	ldd	r30, Y+1	; 0x01
    2680:	fa 81       	ldd	r31, Y+2	; 0x02
    2682:	86 8d       	ldd	r24, Z+30	; 0x1e
    2684:	8f 3f       	cpi	r24, 0xFF	; 255
    2686:	19 f4       	brne	.+6      	; 0x268e <xQueueGenericSend+0xdc>
    2688:	e9 81       	ldd	r30, Y+1	; 0x01
    268a:	fa 81       	ldd	r31, Y+2	; 0x02
    268c:	16 8e       	std	Z+30, r1	; 0x1e
    268e:	0f 90       	pop	r0
    2690:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2692:	ce 01       	movw	r24, r28
    2694:	05 96       	adiw	r24, 0x05	; 5
    2696:	9e 01       	movw	r18, r28
    2698:	24 5f       	subi	r18, 0xF4	; 244
    269a:	3f 4f       	sbci	r19, 0xFF	; 255
    269c:	b9 01       	movw	r22, r18
    269e:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <xTaskCheckForTimeOut>
    26a2:	88 23       	and	r24, r24
    26a4:	09 f5       	brne	.+66     	; 0x26e8 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    26a6:	89 81       	ldd	r24, Y+1	; 0x01
    26a8:	9a 81       	ldd	r25, Y+2	; 0x02
    26aa:	0e 94 94 17 	call	0x2f28	; 0x2f28 <prvIsQueueFull>
    26ae:	88 23       	and	r24, r24
    26b0:	a1 f0       	breq	.+40     	; 0x26da <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    26b2:	89 81       	ldd	r24, Y+1	; 0x01
    26b4:	9a 81       	ldd	r25, Y+2	; 0x02
    26b6:	08 96       	adiw	r24, 0x08	; 8
    26b8:	2c 85       	ldd	r18, Y+12	; 0x0c
    26ba:	3d 85       	ldd	r19, Y+13	; 0x0d
    26bc:	b9 01       	movw	r22, r18
    26be:	0e 94 57 1e 	call	0x3cae	; 0x3cae <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    26c2:	89 81       	ldd	r24, Y+1	; 0x01
    26c4:	9a 81       	ldd	r25, Y+2	; 0x02
    26c6:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    26ca:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>
    26ce:	88 23       	and	r24, r24
    26d0:	09 f0       	breq	.+2      	; 0x26d4 <xQueueGenericSend+0x122>
    26d2:	85 cf       	rjmp	.-246    	; 0x25de <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    26d4:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
    26d8:	82 cf       	rjmp	.-252    	; 0x25de <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    26da:	89 81       	ldd	r24, Y+1	; 0x01
    26dc:	9a 81       	ldd	r25, Y+2	; 0x02
    26de:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    26e2:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>
    26e6:	7b cf       	rjmp	.-266    	; 0x25de <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    26e8:	89 81       	ldd	r24, Y+1	; 0x01
    26ea:	9a 81       	ldd	r25, Y+2	; 0x02
    26ec:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    26f0:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    26f4:	1f 86       	std	Y+15, r1	; 0x0f
    26f6:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}

	return 0;
}
    26f8:	2f 96       	adiw	r28, 0x0f	; 15
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	de bf       	out	0x3e, r29	; 62
    2700:	0f be       	out	0x3f, r0	; 63
    2702:	cd bf       	out	0x3d, r28	; 61
    2704:	cf 91       	pop	r28
    2706:	df 91       	pop	r29
    2708:	08 95       	ret

0000270a <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    270a:	df 93       	push	r29
    270c:	cf 93       	push	r28
    270e:	cd b7       	in	r28, 0x3d	; 61
    2710:	de b7       	in	r29, 0x3e	; 62
    2712:	2c 97       	sbiw	r28, 0x0c	; 12
    2714:	0f b6       	in	r0, 0x3f	; 63
    2716:	f8 94       	cli
    2718:	de bf       	out	0x3e, r29	; 62
    271a:	0f be       	out	0x3f, r0	; 63
    271c:	cd bf       	out	0x3d, r28	; 61
    271e:	9f 83       	std	Y+7, r25	; 0x07
    2720:	8e 83       	std	Y+6, r24	; 0x06
    2722:	79 87       	std	Y+9, r23	; 0x09
    2724:	68 87       	std	Y+8, r22	; 0x08
    2726:	5b 87       	std	Y+11, r21	; 0x0b
    2728:	4a 87       	std	Y+10, r20	; 0x0a
    272a:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    272c:	8e 81       	ldd	r24, Y+6	; 0x06
    272e:	9f 81       	ldd	r25, Y+7	; 0x07
    2730:	9b 83       	std	Y+3, r25	; 0x03
    2732:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2734:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2736:	ea 81       	ldd	r30, Y+2	; 0x02
    2738:	fb 81       	ldd	r31, Y+3	; 0x03
    273a:	92 8d       	ldd	r25, Z+26	; 0x1a
    273c:	ea 81       	ldd	r30, Y+2	; 0x02
    273e:	fb 81       	ldd	r31, Y+3	; 0x03
    2740:	83 8d       	ldd	r24, Z+27	; 0x1b
    2742:	98 17       	cp	r25, r24
    2744:	18 f0       	brcs	.+6      	; 0x274c <xQueueGenericSendFromISR+0x42>
    2746:	8c 85       	ldd	r24, Y+12	; 0x0c
    2748:	82 30       	cpi	r24, 0x02	; 2
    274a:	61 f5       	brne	.+88     	; 0x27a4 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    274c:	ea 81       	ldd	r30, Y+2	; 0x02
    274e:	fb 81       	ldd	r31, Y+3	; 0x03
    2750:	86 8d       	ldd	r24, Z+30	; 0x1e
    2752:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2754:	8a 81       	ldd	r24, Y+2	; 0x02
    2756:	9b 81       	ldd	r25, Y+3	; 0x03
    2758:	28 85       	ldd	r18, Y+8	; 0x08
    275a:	39 85       	ldd	r19, Y+9	; 0x09
    275c:	b9 01       	movw	r22, r18
    275e:	4c 85       	ldd	r20, Y+12	; 0x0c
    2760:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2764:	89 81       	ldd	r24, Y+1	; 0x01
    2766:	8f 3f       	cpi	r24, 0xFF	; 255
    2768:	a9 f4       	brne	.+42     	; 0x2794 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    276a:	ea 81       	ldd	r30, Y+2	; 0x02
    276c:	fb 81       	ldd	r31, Y+3	; 0x03
    276e:	81 89       	ldd	r24, Z+17	; 0x11
    2770:	88 23       	and	r24, r24
    2772:	a9 f0       	breq	.+42     	; 0x279e <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2774:	8a 81       	ldd	r24, Y+2	; 0x02
    2776:	9b 81       	ldd	r25, Y+3	; 0x03
    2778:	41 96       	adiw	r24, 0x11	; 17
    277a:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    277e:	88 23       	and	r24, r24
    2780:	71 f0       	breq	.+28     	; 0x279e <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2782:	8a 85       	ldd	r24, Y+10	; 0x0a
    2784:	9b 85       	ldd	r25, Y+11	; 0x0b
    2786:	00 97       	sbiw	r24, 0x00	; 0
    2788:	51 f0       	breq	.+20     	; 0x279e <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    278a:	ea 85       	ldd	r30, Y+10	; 0x0a
    278c:	fb 85       	ldd	r31, Y+11	; 0x0b
    278e:	81 e0       	ldi	r24, 0x01	; 1
    2790:	80 83       	st	Z, r24
    2792:	05 c0       	rjmp	.+10     	; 0x279e <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2794:	89 81       	ldd	r24, Y+1	; 0x01
    2796:	8f 5f       	subi	r24, 0xFF	; 255
    2798:	ea 81       	ldd	r30, Y+2	; 0x02
    279a:	fb 81       	ldd	r31, Y+3	; 0x03
    279c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    279e:	81 e0       	ldi	r24, 0x01	; 1
    27a0:	8d 83       	std	Y+5, r24	; 0x05
    27a2:	01 c0       	rjmp	.+2      	; 0x27a6 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    27a4:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    27a6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    27a8:	2c 96       	adiw	r28, 0x0c	; 12
    27aa:	0f b6       	in	r0, 0x3f	; 63
    27ac:	f8 94       	cli
    27ae:	de bf       	out	0x3e, r29	; 62
    27b0:	0f be       	out	0x3f, r0	; 63
    27b2:	cd bf       	out	0x3d, r28	; 61
    27b4:	cf 91       	pop	r28
    27b6:	df 91       	pop	r29
    27b8:	08 95       	ret

000027ba <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    27ba:	df 93       	push	r29
    27bc:	cf 93       	push	r28
    27be:	cd b7       	in	r28, 0x3d	; 61
    27c0:	de b7       	in	r29, 0x3e	; 62
    27c2:	2a 97       	sbiw	r28, 0x0a	; 10
    27c4:	0f b6       	in	r0, 0x3f	; 63
    27c6:	f8 94       	cli
    27c8:	de bf       	out	0x3e, r29	; 62
    27ca:	0f be       	out	0x3f, r0	; 63
    27cc:	cd bf       	out	0x3d, r28	; 61
    27ce:	98 87       	std	Y+8, r25	; 0x08
    27d0:	8f 83       	std	Y+7, r24	; 0x07
    27d2:	7a 87       	std	Y+10, r23	; 0x0a
    27d4:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    27d6:	8f 81       	ldd	r24, Y+7	; 0x07
    27d8:	98 85       	ldd	r25, Y+8	; 0x08
    27da:	9c 83       	std	Y+4, r25	; 0x04
    27dc:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    27de:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    27e0:	eb 81       	ldd	r30, Y+3	; 0x03
    27e2:	fc 81       	ldd	r31, Y+4	; 0x04
    27e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    27e6:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    27e8:	eb 81       	ldd	r30, Y+3	; 0x03
    27ea:	fc 81       	ldd	r31, Y+4	; 0x04
    27ec:	93 8d       	ldd	r25, Z+27	; 0x1b
    27ee:	8a 81       	ldd	r24, Y+2	; 0x02
    27f0:	89 17       	cp	r24, r25
    27f2:	48 f5       	brcc	.+82     	; 0x2846 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    27f4:	eb 81       	ldd	r30, Y+3	; 0x03
    27f6:	fc 81       	ldd	r31, Y+4	; 0x04
    27f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    27fa:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    27fc:	8a 81       	ldd	r24, Y+2	; 0x02
    27fe:	8f 5f       	subi	r24, 0xFF	; 255
    2800:	eb 81       	ldd	r30, Y+3	; 0x03
    2802:	fc 81       	ldd	r31, Y+4	; 0x04
    2804:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2806:	89 81       	ldd	r24, Y+1	; 0x01
    2808:	8f 3f       	cpi	r24, 0xFF	; 255
    280a:	a9 f4       	brne	.+42     	; 0x2836 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    280c:	eb 81       	ldd	r30, Y+3	; 0x03
    280e:	fc 81       	ldd	r31, Y+4	; 0x04
    2810:	81 89       	ldd	r24, Z+17	; 0x11
    2812:	88 23       	and	r24, r24
    2814:	a9 f0       	breq	.+42     	; 0x2840 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2816:	8b 81       	ldd	r24, Y+3	; 0x03
    2818:	9c 81       	ldd	r25, Y+4	; 0x04
    281a:	41 96       	adiw	r24, 0x11	; 17
    281c:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    2820:	88 23       	and	r24, r24
    2822:	71 f0       	breq	.+28     	; 0x2840 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2824:	89 85       	ldd	r24, Y+9	; 0x09
    2826:	9a 85       	ldd	r25, Y+10	; 0x0a
    2828:	00 97       	sbiw	r24, 0x00	; 0
    282a:	51 f0       	breq	.+20     	; 0x2840 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    282c:	e9 85       	ldd	r30, Y+9	; 0x09
    282e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2830:	81 e0       	ldi	r24, 0x01	; 1
    2832:	80 83       	st	Z, r24
    2834:	05 c0       	rjmp	.+10     	; 0x2840 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2836:	89 81       	ldd	r24, Y+1	; 0x01
    2838:	8f 5f       	subi	r24, 0xFF	; 255
    283a:	eb 81       	ldd	r30, Y+3	; 0x03
    283c:	fc 81       	ldd	r31, Y+4	; 0x04
    283e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2840:	81 e0       	ldi	r24, 0x01	; 1
    2842:	8e 83       	std	Y+6, r24	; 0x06
    2844:	01 c0       	rjmp	.+2      	; 0x2848 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2846:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2848:	8e 81       	ldd	r24, Y+6	; 0x06
}
    284a:	2a 96       	adiw	r28, 0x0a	; 10
    284c:	0f b6       	in	r0, 0x3f	; 63
    284e:	f8 94       	cli
    2850:	de bf       	out	0x3e, r29	; 62
    2852:	0f be       	out	0x3f, r0	; 63
    2854:	cd bf       	out	0x3d, r28	; 61
    2856:	cf 91       	pop	r28
    2858:	df 91       	pop	r29
    285a:	08 95       	ret

0000285c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    285c:	df 93       	push	r29
    285e:	cf 93       	push	r28
    2860:	cd b7       	in	r28, 0x3d	; 61
    2862:	de b7       	in	r29, 0x3e	; 62
    2864:	61 97       	sbiw	r28, 0x11	; 17
    2866:	0f b6       	in	r0, 0x3f	; 63
    2868:	f8 94       	cli
    286a:	de bf       	out	0x3e, r29	; 62
    286c:	0f be       	out	0x3f, r0	; 63
    286e:	cd bf       	out	0x3d, r28	; 61
    2870:	9b 87       	std	Y+11, r25	; 0x0b
    2872:	8a 87       	std	Y+10, r24	; 0x0a
    2874:	7d 87       	std	Y+13, r23	; 0x0d
    2876:	6c 87       	std	Y+12, r22	; 0x0c
    2878:	5f 87       	std	Y+15, r21	; 0x0f
    287a:	4e 87       	std	Y+14, r20	; 0x0e
    287c:	28 8b       	std	Y+16, r18	; 0x10
BaseType_t xEntryTimeSet = pdFALSE;
    287e:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2880:	8a 85       	ldd	r24, Y+10	; 0x0a
    2882:	9b 85       	ldd	r25, Y+11	; 0x0b
    2884:	9b 83       	std	Y+3, r25	; 0x03
    2886:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2888:	0f b6       	in	r0, 0x3f	; 63
    288a:	f8 94       	cli
    288c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    288e:	ea 81       	ldd	r30, Y+2	; 0x02
    2890:	fb 81       	ldd	r31, Y+3	; 0x03
    2892:	82 8d       	ldd	r24, Z+26	; 0x1a
    2894:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2896:	89 81       	ldd	r24, Y+1	; 0x01
    2898:	88 23       	and	r24, r24
    289a:	09 f4       	brne	.+2      	; 0x289e <xQueueGenericReceive+0x42>
    289c:	49 c0       	rjmp	.+146    	; 0x2930 <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    289e:	ea 81       	ldd	r30, Y+2	; 0x02
    28a0:	fb 81       	ldd	r31, Y+3	; 0x03
    28a2:	86 81       	ldd	r24, Z+6	; 0x06
    28a4:	97 81       	ldd	r25, Z+7	; 0x07
    28a6:	9d 83       	std	Y+5, r25	; 0x05
    28a8:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    28aa:	8a 81       	ldd	r24, Y+2	; 0x02
    28ac:	9b 81       	ldd	r25, Y+3	; 0x03
    28ae:	2c 85       	ldd	r18, Y+12	; 0x0c
    28b0:	3d 85       	ldd	r19, Y+13	; 0x0d
    28b2:	b9 01       	movw	r22, r18
    28b4:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    28b8:	88 89       	ldd	r24, Y+16	; 0x10
    28ba:	88 23       	and	r24, r24
    28bc:	01 f5       	brne	.+64     	; 0x28fe <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    28be:	89 81       	ldd	r24, Y+1	; 0x01
    28c0:	81 50       	subi	r24, 0x01	; 1
    28c2:	ea 81       	ldd	r30, Y+2	; 0x02
    28c4:	fb 81       	ldd	r31, Y+3	; 0x03
    28c6:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    28c8:	ea 81       	ldd	r30, Y+2	; 0x02
    28ca:	fb 81       	ldd	r31, Y+3	; 0x03
    28cc:	80 81       	ld	r24, Z
    28ce:	91 81       	ldd	r25, Z+1	; 0x01
    28d0:	00 97       	sbiw	r24, 0x00	; 0
    28d2:	31 f4       	brne	.+12     	; 0x28e0 <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    28d4:	0e 94 be 21 	call	0x437c	; 0x437c <pvTaskIncrementMutexHeldCount>
    28d8:	ea 81       	ldd	r30, Y+2	; 0x02
    28da:	fb 81       	ldd	r31, Y+3	; 0x03
    28dc:	93 83       	std	Z+3, r25	; 0x03
    28de:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28e0:	ea 81       	ldd	r30, Y+2	; 0x02
    28e2:	fb 81       	ldd	r31, Y+3	; 0x03
    28e4:	80 85       	ldd	r24, Z+8	; 0x08
    28e6:	88 23       	and	r24, r24
    28e8:	f1 f0       	breq	.+60     	; 0x2926 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    28ea:	8a 81       	ldd	r24, Y+2	; 0x02
    28ec:	9b 81       	ldd	r25, Y+3	; 0x03
    28ee:	08 96       	adiw	r24, 0x08	; 8
    28f0:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    28f4:	88 23       	and	r24, r24
    28f6:	b9 f0       	breq	.+46     	; 0x2926 <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    28f8:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
    28fc:	14 c0       	rjmp	.+40     	; 0x2926 <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    28fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2900:	fb 81       	ldd	r31, Y+3	; 0x03
    2902:	8c 81       	ldd	r24, Y+4	; 0x04
    2904:	9d 81       	ldd	r25, Y+5	; 0x05
    2906:	97 83       	std	Z+7, r25	; 0x07
    2908:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    290a:	ea 81       	ldd	r30, Y+2	; 0x02
    290c:	fb 81       	ldd	r31, Y+3	; 0x03
    290e:	81 89       	ldd	r24, Z+17	; 0x11
    2910:	88 23       	and	r24, r24
    2912:	49 f0       	breq	.+18     	; 0x2926 <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2914:	8a 81       	ldd	r24, Y+2	; 0x02
    2916:	9b 81       	ldd	r25, Y+3	; 0x03
    2918:	41 96       	adiw	r24, 0x11	; 17
    291a:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    291e:	88 23       	and	r24, r24
    2920:	11 f0       	breq	.+4      	; 0x2926 <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2922:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2926:	0f 90       	pop	r0
    2928:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    292a:	81 e0       	ldi	r24, 0x01	; 1
    292c:	89 8b       	std	Y+17, r24	; 0x11
    292e:	74 c0       	rjmp	.+232    	; 0x2a18 <xQueueGenericReceive+0x1bc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2930:	8e 85       	ldd	r24, Y+14	; 0x0e
    2932:	9f 85       	ldd	r25, Y+15	; 0x0f
    2934:	00 97       	sbiw	r24, 0x00	; 0
    2936:	21 f4       	brne	.+8      	; 0x2940 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2938:	0f 90       	pop	r0
    293a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    293c:	19 8a       	std	Y+17, r1	; 0x11
    293e:	6c c0       	rjmp	.+216    	; 0x2a18 <xQueueGenericReceive+0x1bc>
				}
				else if( xEntryTimeSet == pdFALSE )
    2940:	8e 81       	ldd	r24, Y+6	; 0x06
    2942:	88 23       	and	r24, r24
    2944:	31 f4       	brne	.+12     	; 0x2952 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2946:	ce 01       	movw	r24, r28
    2948:	07 96       	adiw	r24, 0x07	; 7
    294a:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    294e:	81 e0       	ldi	r24, 0x01	; 1
    2950:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2952:	0f 90       	pop	r0
    2954:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2956:	0e 94 09 1c 	call	0x3812	; 0x3812 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    295a:	0f b6       	in	r0, 0x3f	; 63
    295c:	f8 94       	cli
    295e:	0f 92       	push	r0
    2960:	ea 81       	ldd	r30, Y+2	; 0x02
    2962:	fb 81       	ldd	r31, Y+3	; 0x03
    2964:	85 8d       	ldd	r24, Z+29	; 0x1d
    2966:	8f 3f       	cpi	r24, 0xFF	; 255
    2968:	19 f4       	brne	.+6      	; 0x2970 <xQueueGenericReceive+0x114>
    296a:	ea 81       	ldd	r30, Y+2	; 0x02
    296c:	fb 81       	ldd	r31, Y+3	; 0x03
    296e:	15 8e       	std	Z+29, r1	; 0x1d
    2970:	ea 81       	ldd	r30, Y+2	; 0x02
    2972:	fb 81       	ldd	r31, Y+3	; 0x03
    2974:	86 8d       	ldd	r24, Z+30	; 0x1e
    2976:	8f 3f       	cpi	r24, 0xFF	; 255
    2978:	19 f4       	brne	.+6      	; 0x2980 <xQueueGenericReceive+0x124>
    297a:	ea 81       	ldd	r30, Y+2	; 0x02
    297c:	fb 81       	ldd	r31, Y+3	; 0x03
    297e:	16 8e       	std	Z+30, r1	; 0x1e
    2980:	0f 90       	pop	r0
    2982:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2984:	ce 01       	movw	r24, r28
    2986:	07 96       	adiw	r24, 0x07	; 7
    2988:	9e 01       	movw	r18, r28
    298a:	22 5f       	subi	r18, 0xF2	; 242
    298c:	3f 4f       	sbci	r19, 0xFF	; 255
    298e:	b9 01       	movw	r22, r18
    2990:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <xTaskCheckForTimeOut>
    2994:	88 23       	and	r24, r24
    2996:	91 f5       	brne	.+100    	; 0x29fc <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2998:	8a 81       	ldd	r24, Y+2	; 0x02
    299a:	9b 81       	ldd	r25, Y+3	; 0x03
    299c:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <prvIsQueueEmpty>
    29a0:	88 23       	and	r24, r24
    29a2:	29 f1       	breq	.+74     	; 0x29ee <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    29a4:	ea 81       	ldd	r30, Y+2	; 0x02
    29a6:	fb 81       	ldd	r31, Y+3	; 0x03
    29a8:	80 81       	ld	r24, Z
    29aa:	91 81       	ldd	r25, Z+1	; 0x01
    29ac:	00 97       	sbiw	r24, 0x00	; 0
    29ae:	59 f4       	brne	.+22     	; 0x29c6 <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    29b0:	0f b6       	in	r0, 0x3f	; 63
    29b2:	f8 94       	cli
    29b4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    29b6:	ea 81       	ldd	r30, Y+2	; 0x02
    29b8:	fb 81       	ldd	r31, Y+3	; 0x03
    29ba:	82 81       	ldd	r24, Z+2	; 0x02
    29bc:	93 81       	ldd	r25, Z+3	; 0x03
    29be:	0e 94 9a 20 	call	0x4134	; 0x4134 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    29c2:	0f 90       	pop	r0
    29c4:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    29c6:	8a 81       	ldd	r24, Y+2	; 0x02
    29c8:	9b 81       	ldd	r25, Y+3	; 0x03
    29ca:	41 96       	adiw	r24, 0x11	; 17
    29cc:	2e 85       	ldd	r18, Y+14	; 0x0e
    29ce:	3f 85       	ldd	r19, Y+15	; 0x0f
    29d0:	b9 01       	movw	r22, r18
    29d2:	0e 94 57 1e 	call	0x3cae	; 0x3cae <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    29d6:	8a 81       	ldd	r24, Y+2	; 0x02
    29d8:	9b 81       	ldd	r25, Y+3	; 0x03
    29da:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    29de:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>
    29e2:	88 23       	and	r24, r24
    29e4:	09 f0       	breq	.+2      	; 0x29e8 <xQueueGenericReceive+0x18c>
    29e6:	50 cf       	rjmp	.-352    	; 0x2888 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    29e8:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
    29ec:	4d cf       	rjmp	.-358    	; 0x2888 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    29ee:	8a 81       	ldd	r24, Y+2	; 0x02
    29f0:	9b 81       	ldd	r25, Y+3	; 0x03
    29f2:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    29f6:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>
    29fa:	46 cf       	rjmp	.-372    	; 0x2888 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    29fc:	8a 81       	ldd	r24, Y+2	; 0x02
    29fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2a00:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2a04:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2a08:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a0c:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <prvIsQueueEmpty>
    2a10:	88 23       	and	r24, r24
    2a12:	09 f4       	brne	.+2      	; 0x2a16 <xQueueGenericReceive+0x1ba>
    2a14:	39 cf       	rjmp	.-398    	; 0x2888 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2a16:	19 8a       	std	Y+17, r1	; 0x11
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2a18:	89 89       	ldd	r24, Y+17	; 0x11

	return 0;
}
    2a1a:	61 96       	adiw	r28, 0x11	; 17
    2a1c:	0f b6       	in	r0, 0x3f	; 63
    2a1e:	f8 94       	cli
    2a20:	de bf       	out	0x3e, r29	; 62
    2a22:	0f be       	out	0x3f, r0	; 63
    2a24:	cd bf       	out	0x3d, r28	; 61
    2a26:	cf 91       	pop	r28
    2a28:	df 91       	pop	r29
    2a2a:	08 95       	ret

00002a2c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2a2c:	df 93       	push	r29
    2a2e:	cf 93       	push	r28
    2a30:	cd b7       	in	r28, 0x3d	; 61
    2a32:	de b7       	in	r29, 0x3e	; 62
    2a34:	2c 97       	sbiw	r28, 0x0c	; 12
    2a36:	0f b6       	in	r0, 0x3f	; 63
    2a38:	f8 94       	cli
    2a3a:	de bf       	out	0x3e, r29	; 62
    2a3c:	0f be       	out	0x3f, r0	; 63
    2a3e:	cd bf       	out	0x3d, r28	; 61
    2a40:	98 87       	std	Y+8, r25	; 0x08
    2a42:	8f 83       	std	Y+7, r24	; 0x07
    2a44:	7a 87       	std	Y+10, r23	; 0x0a
    2a46:	69 87       	std	Y+9, r22	; 0x09
    2a48:	5c 87       	std	Y+12, r21	; 0x0c
    2a4a:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2a4c:	8f 81       	ldd	r24, Y+7	; 0x07
    2a4e:	98 85       	ldd	r25, Y+8	; 0x08
    2a50:	9c 83       	std	Y+4, r25	; 0x04
    2a52:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a54:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2a56:	eb 81       	ldd	r30, Y+3	; 0x03
    2a58:	fc 81       	ldd	r31, Y+4	; 0x04
    2a5a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a5c:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2a5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a60:	88 23       	and	r24, r24
    2a62:	81 f1       	breq	.+96     	; 0x2ac4 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2a64:	eb 81       	ldd	r30, Y+3	; 0x03
    2a66:	fc 81       	ldd	r31, Y+4	; 0x04
    2a68:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a6a:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2a6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a70:	29 85       	ldd	r18, Y+9	; 0x09
    2a72:	3a 85       	ldd	r19, Y+10	; 0x0a
    2a74:	b9 01       	movw	r22, r18
    2a76:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    2a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a7c:	81 50       	subi	r24, 0x01	; 1
    2a7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a80:	fc 81       	ldd	r31, Y+4	; 0x04
    2a82:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    2a84:	89 81       	ldd	r24, Y+1	; 0x01
    2a86:	8f 3f       	cpi	r24, 0xFF	; 255
    2a88:	a9 f4       	brne	.+42     	; 0x2ab4 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8e:	80 85       	ldd	r24, Z+8	; 0x08
    2a90:	88 23       	and	r24, r24
    2a92:	a9 f0       	breq	.+42     	; 0x2abe <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a94:	8b 81       	ldd	r24, Y+3	; 0x03
    2a96:	9c 81       	ldd	r25, Y+4	; 0x04
    2a98:	08 96       	adiw	r24, 0x08	; 8
    2a9a:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    2a9e:	88 23       	and	r24, r24
    2aa0:	71 f0       	breq	.+28     	; 0x2abe <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2aa2:	8b 85       	ldd	r24, Y+11	; 0x0b
    2aa4:	9c 85       	ldd	r25, Y+12	; 0x0c
    2aa6:	00 97       	sbiw	r24, 0x00	; 0
    2aa8:	51 f0       	breq	.+20     	; 0x2abe <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2aaa:	eb 85       	ldd	r30, Y+11	; 0x0b
    2aac:	fc 85       	ldd	r31, Y+12	; 0x0c
    2aae:	81 e0       	ldi	r24, 0x01	; 1
    2ab0:	80 83       	st	Z, r24
    2ab2:	05 c0       	rjmp	.+10     	; 0x2abe <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2ab4:	89 81       	ldd	r24, Y+1	; 0x01
    2ab6:	8f 5f       	subi	r24, 0xFF	; 255
    2ab8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aba:	fc 81       	ldd	r31, Y+4	; 0x04
    2abc:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2abe:	81 e0       	ldi	r24, 0x01	; 1
    2ac0:	8e 83       	std	Y+6, r24	; 0x06
    2ac2:	01 c0       	rjmp	.+2      	; 0x2ac6 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2ac4:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2ac6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2ac8:	2c 96       	adiw	r28, 0x0c	; 12
    2aca:	0f b6       	in	r0, 0x3f	; 63
    2acc:	f8 94       	cli
    2ace:	de bf       	out	0x3e, r29	; 62
    2ad0:	0f be       	out	0x3f, r0	; 63
    2ad2:	cd bf       	out	0x3d, r28	; 61
    2ad4:	cf 91       	pop	r28
    2ad6:	df 91       	pop	r29
    2ad8:	08 95       	ret

00002ada <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2ada:	df 93       	push	r29
    2adc:	cf 93       	push	r28
    2ade:	cd b7       	in	r28, 0x3d	; 61
    2ae0:	de b7       	in	r29, 0x3e	; 62
    2ae2:	2a 97       	sbiw	r28, 0x0a	; 10
    2ae4:	0f b6       	in	r0, 0x3f	; 63
    2ae6:	f8 94       	cli
    2ae8:	de bf       	out	0x3e, r29	; 62
    2aea:	0f be       	out	0x3f, r0	; 63
    2aec:	cd bf       	out	0x3d, r28	; 61
    2aee:	98 87       	std	Y+8, r25	; 0x08
    2af0:	8f 83       	std	Y+7, r24	; 0x07
    2af2:	7a 87       	std	Y+10, r23	; 0x0a
    2af4:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2af6:	8f 81       	ldd	r24, Y+7	; 0x07
    2af8:	98 85       	ldd	r25, Y+8	; 0x08
    2afa:	9a 83       	std	Y+2, r25	; 0x02
    2afc:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2afe:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b00:	e9 81       	ldd	r30, Y+1	; 0x01
    2b02:	fa 81       	ldd	r31, Y+2	; 0x02
    2b04:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b06:	88 23       	and	r24, r24
    2b08:	b1 f0       	breq	.+44     	; 0x2b36 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2b0a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b0c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b0e:	86 81       	ldd	r24, Z+6	; 0x06
    2b10:	97 81       	ldd	r25, Z+7	; 0x07
    2b12:	9c 83       	std	Y+4, r25	; 0x04
    2b14:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2b16:	89 81       	ldd	r24, Y+1	; 0x01
    2b18:	9a 81       	ldd	r25, Y+2	; 0x02
    2b1a:	29 85       	ldd	r18, Y+9	; 0x09
    2b1c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2b1e:	b9 01       	movw	r22, r18
    2b20:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2b24:	e9 81       	ldd	r30, Y+1	; 0x01
    2b26:	fa 81       	ldd	r31, Y+2	; 0x02
    2b28:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2c:	97 83       	std	Z+7, r25	; 0x07
    2b2e:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2b30:	81 e0       	ldi	r24, 0x01	; 1
    2b32:	8e 83       	std	Y+6, r24	; 0x06
    2b34:	01 c0       	rjmp	.+2      	; 0x2b38 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2b36:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2b38:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2b3a:	2a 96       	adiw	r28, 0x0a	; 10
    2b3c:	0f b6       	in	r0, 0x3f	; 63
    2b3e:	f8 94       	cli
    2b40:	de bf       	out	0x3e, r29	; 62
    2b42:	0f be       	out	0x3f, r0	; 63
    2b44:	cd bf       	out	0x3d, r28	; 61
    2b46:	cf 91       	pop	r28
    2b48:	df 91       	pop	r29
    2b4a:	08 95       	ret

00002b4c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2b4c:	df 93       	push	r29
    2b4e:	cf 93       	push	r28
    2b50:	00 d0       	rcall	.+0      	; 0x2b52 <uxQueueMessagesWaiting+0x6>
    2b52:	0f 92       	push	r0
    2b54:	cd b7       	in	r28, 0x3d	; 61
    2b56:	de b7       	in	r29, 0x3e	; 62
    2b58:	9b 83       	std	Y+3, r25	; 0x03
    2b5a:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2b5c:	0f b6       	in	r0, 0x3f	; 63
    2b5e:	f8 94       	cli
    2b60:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2b62:	ea 81       	ldd	r30, Y+2	; 0x02
    2b64:	fb 81       	ldd	r31, Y+3	; 0x03
    2b66:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b68:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2b6a:	0f 90       	pop	r0
    2b6c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2b6e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2b70:	0f 90       	pop	r0
    2b72:	0f 90       	pop	r0
    2b74:	0f 90       	pop	r0
    2b76:	cf 91       	pop	r28
    2b78:	df 91       	pop	r29
    2b7a:	08 95       	ret

00002b7c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2b7c:	df 93       	push	r29
    2b7e:	cf 93       	push	r28
    2b80:	00 d0       	rcall	.+0      	; 0x2b82 <uxQueueSpacesAvailable+0x6>
    2b82:	00 d0       	rcall	.+0      	; 0x2b84 <uxQueueSpacesAvailable+0x8>
    2b84:	0f 92       	push	r0
    2b86:	cd b7       	in	r28, 0x3d	; 61
    2b88:	de b7       	in	r29, 0x3e	; 62
    2b8a:	9d 83       	std	Y+5, r25	; 0x05
    2b8c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    2b8e:	8c 81       	ldd	r24, Y+4	; 0x04
    2b90:	9d 81       	ldd	r25, Y+5	; 0x05
    2b92:	9a 83       	std	Y+2, r25	; 0x02
    2b94:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2b96:	0f b6       	in	r0, 0x3f	; 63
    2b98:	f8 94       	cli
    2b9a:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2b9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba0:	93 8d       	ldd	r25, Z+27	; 0x1b
    2ba2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ba8:	29 2f       	mov	r18, r25
    2baa:	28 1b       	sub	r18, r24
    2bac:	82 2f       	mov	r24, r18
    2bae:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2bb0:	0f 90       	pop	r0
    2bb2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2bb4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2bb6:	0f 90       	pop	r0
    2bb8:	0f 90       	pop	r0
    2bba:	0f 90       	pop	r0
    2bbc:	0f 90       	pop	r0
    2bbe:	0f 90       	pop	r0
    2bc0:	cf 91       	pop	r28
    2bc2:	df 91       	pop	r29
    2bc4:	08 95       	ret

00002bc6 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2bc6:	df 93       	push	r29
    2bc8:	cf 93       	push	r28
    2bca:	00 d0       	rcall	.+0      	; 0x2bcc <uxQueueMessagesWaitingFromISR+0x6>
    2bcc:	0f 92       	push	r0
    2bce:	cd b7       	in	r28, 0x3d	; 61
    2bd0:	de b7       	in	r29, 0x3e	; 62
    2bd2:	9b 83       	std	Y+3, r25	; 0x03
    2bd4:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2bd6:	ea 81       	ldd	r30, Y+2	; 0x02
    2bd8:	fb 81       	ldd	r31, Y+3	; 0x03
    2bda:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bdc:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    2bde:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2be0:	0f 90       	pop	r0
    2be2:	0f 90       	pop	r0
    2be4:	0f 90       	pop	r0
    2be6:	cf 91       	pop	r28
    2be8:	df 91       	pop	r29
    2bea:	08 95       	ret

00002bec <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2bec:	df 93       	push	r29
    2bee:	cf 93       	push	r28
    2bf0:	00 d0       	rcall	.+0      	; 0x2bf2 <vQueueDelete+0x6>
    2bf2:	00 d0       	rcall	.+0      	; 0x2bf4 <vQueueDelete+0x8>
    2bf4:	cd b7       	in	r28, 0x3d	; 61
    2bf6:	de b7       	in	r29, 0x3e	; 62
    2bf8:	9c 83       	std	Y+4, r25	; 0x04
    2bfa:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2c00:	9a 83       	std	Y+2, r25	; 0x02
    2c02:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2c04:	89 81       	ldd	r24, Y+1	; 0x01
    2c06:	9a 81       	ldd	r25, Y+2	; 0x02
    2c08:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2c0c:	0f 90       	pop	r0
    2c0e:	0f 90       	pop	r0
    2c10:	0f 90       	pop	r0
    2c12:	0f 90       	pop	r0
    2c14:	cf 91       	pop	r28
    2c16:	df 91       	pop	r29
    2c18:	08 95       	ret

00002c1a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2c1a:	df 93       	push	r29
    2c1c:	cf 93       	push	r28
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
    2c22:	27 97       	sbiw	r28, 0x07	; 7
    2c24:	0f b6       	in	r0, 0x3f	; 63
    2c26:	f8 94       	cli
    2c28:	de bf       	out	0x3e, r29	; 62
    2c2a:	0f be       	out	0x3f, r0	; 63
    2c2c:	cd bf       	out	0x3d, r28	; 61
    2c2e:	9c 83       	std	Y+4, r25	; 0x04
    2c30:	8b 83       	std	Y+3, r24	; 0x03
    2c32:	7e 83       	std	Y+6, r23	; 0x06
    2c34:	6d 83       	std	Y+5, r22	; 0x05
    2c36:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2c38:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2c3a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c3c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c40:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2c42:	eb 81       	ldd	r30, Y+3	; 0x03
    2c44:	fc 81       	ldd	r31, Y+4	; 0x04
    2c46:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c48:	88 23       	and	r24, r24
    2c4a:	99 f4       	brne	.+38     	; 0x2c72 <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2c4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c50:	80 81       	ld	r24, Z
    2c52:	91 81       	ldd	r25, Z+1	; 0x01
    2c54:	00 97       	sbiw	r24, 0x00	; 0
    2c56:	09 f0       	breq	.+2      	; 0x2c5a <prvCopyDataToQueue+0x40>
    2c58:	89 c0       	rjmp	.+274    	; 0x2d6c <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    2c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5e:	82 81       	ldd	r24, Z+2	; 0x02
    2c60:	93 81       	ldd	r25, Z+3	; 0x03
    2c62:	0e 94 25 21 	call	0x424a	; 0x424a <xTaskPriorityDisinherit>
    2c66:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->pxMutexHolder = NULL;
    2c68:	eb 81       	ldd	r30, Y+3	; 0x03
    2c6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c6c:	13 82       	std	Z+3, r1	; 0x03
    2c6e:	12 82       	std	Z+2, r1	; 0x02
    2c70:	7d c0       	rjmp	.+250    	; 0x2d6c <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2c72:	8f 81       	ldd	r24, Y+7	; 0x07
    2c74:	88 23       	and	r24, r24
    2c76:	99 f5       	brne	.+102    	; 0x2cde <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2c78:	eb 81       	ldd	r30, Y+3	; 0x03
    2c7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7c:	64 81       	ldd	r22, Z+4	; 0x04
    2c7e:	75 81       	ldd	r23, Z+5	; 0x05
    2c80:	eb 81       	ldd	r30, Y+3	; 0x03
    2c82:	fc 81       	ldd	r31, Y+4	; 0x04
    2c84:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c86:	48 2f       	mov	r20, r24
    2c88:	50 e0       	ldi	r21, 0x00	; 0
    2c8a:	2d 81       	ldd	r18, Y+5	; 0x05
    2c8c:	3e 81       	ldd	r19, Y+6	; 0x06
    2c8e:	cb 01       	movw	r24, r22
    2c90:	b9 01       	movw	r22, r18
    2c92:	0e 94 39 30 	call	0x6072	; 0x6072 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2c96:	eb 81       	ldd	r30, Y+3	; 0x03
    2c98:	fc 81       	ldd	r31, Y+4	; 0x04
    2c9a:	24 81       	ldd	r18, Z+4	; 0x04
    2c9c:	35 81       	ldd	r19, Z+5	; 0x05
    2c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ca4:	88 2f       	mov	r24, r24
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	82 0f       	add	r24, r18
    2caa:	93 1f       	adc	r25, r19
    2cac:	eb 81       	ldd	r30, Y+3	; 0x03
    2cae:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb0:	95 83       	std	Z+5, r25	; 0x05
    2cb2:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2cb4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb8:	24 81       	ldd	r18, Z+4	; 0x04
    2cba:	35 81       	ldd	r19, Z+5	; 0x05
    2cbc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cbe:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc0:	82 81       	ldd	r24, Z+2	; 0x02
    2cc2:	93 81       	ldd	r25, Z+3	; 0x03
    2cc4:	28 17       	cp	r18, r24
    2cc6:	39 07       	cpc	r19, r25
    2cc8:	08 f4       	brcc	.+2      	; 0x2ccc <prvCopyDataToQueue+0xb2>
    2cca:	50 c0       	rjmp	.+160    	; 0x2d6c <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2ccc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cce:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd0:	80 81       	ld	r24, Z
    2cd2:	91 81       	ldd	r25, Z+1	; 0x01
    2cd4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cd6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cd8:	95 83       	std	Z+5, r25	; 0x05
    2cda:	84 83       	std	Z+4, r24	; 0x04
    2cdc:	47 c0       	rjmp	.+142    	; 0x2d6c <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2cde:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce2:	66 81       	ldd	r22, Z+6	; 0x06
    2ce4:	77 81       	ldd	r23, Z+7	; 0x07
    2ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cea:	84 8d       	ldd	r24, Z+28	; 0x1c
    2cec:	48 2f       	mov	r20, r24
    2cee:	50 e0       	ldi	r21, 0x00	; 0
    2cf0:	2d 81       	ldd	r18, Y+5	; 0x05
    2cf2:	3e 81       	ldd	r19, Y+6	; 0x06
    2cf4:	cb 01       	movw	r24, r22
    2cf6:	b9 01       	movw	r22, r18
    2cf8:	0e 94 39 30 	call	0x6072	; 0x6072 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2cfc:	eb 81       	ldd	r30, Y+3	; 0x03
    2cfe:	fc 81       	ldd	r31, Y+4	; 0x04
    2d00:	26 81       	ldd	r18, Z+6	; 0x06
    2d02:	37 81       	ldd	r19, Z+7	; 0x07
    2d04:	eb 81       	ldd	r30, Y+3	; 0x03
    2d06:	fc 81       	ldd	r31, Y+4	; 0x04
    2d08:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d0a:	88 2f       	mov	r24, r24
    2d0c:	90 e0       	ldi	r25, 0x00	; 0
    2d0e:	90 95       	com	r25
    2d10:	81 95       	neg	r24
    2d12:	9f 4f       	sbci	r25, 0xFF	; 255
    2d14:	82 0f       	add	r24, r18
    2d16:	93 1f       	adc	r25, r19
    2d18:	eb 81       	ldd	r30, Y+3	; 0x03
    2d1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1c:	97 83       	std	Z+7, r25	; 0x07
    2d1e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2d20:	eb 81       	ldd	r30, Y+3	; 0x03
    2d22:	fc 81       	ldd	r31, Y+4	; 0x04
    2d24:	26 81       	ldd	r18, Z+6	; 0x06
    2d26:	37 81       	ldd	r19, Z+7	; 0x07
    2d28:	eb 81       	ldd	r30, Y+3	; 0x03
    2d2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d2c:	80 81       	ld	r24, Z
    2d2e:	91 81       	ldd	r25, Z+1	; 0x01
    2d30:	28 17       	cp	r18, r24
    2d32:	39 07       	cpc	r19, r25
    2d34:	90 f4       	brcc	.+36     	; 0x2d5a <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2d36:	eb 81       	ldd	r30, Y+3	; 0x03
    2d38:	fc 81       	ldd	r31, Y+4	; 0x04
    2d3a:	22 81       	ldd	r18, Z+2	; 0x02
    2d3c:	33 81       	ldd	r19, Z+3	; 0x03
    2d3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2d40:	fc 81       	ldd	r31, Y+4	; 0x04
    2d42:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d44:	88 2f       	mov	r24, r24
    2d46:	90 e0       	ldi	r25, 0x00	; 0
    2d48:	90 95       	com	r25
    2d4a:	81 95       	neg	r24
    2d4c:	9f 4f       	sbci	r25, 0xFF	; 255
    2d4e:	82 0f       	add	r24, r18
    2d50:	93 1f       	adc	r25, r19
    2d52:	eb 81       	ldd	r30, Y+3	; 0x03
    2d54:	fc 81       	ldd	r31, Y+4	; 0x04
    2d56:	97 83       	std	Z+7, r25	; 0x07
    2d58:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2d5a:	8f 81       	ldd	r24, Y+7	; 0x07
    2d5c:	82 30       	cpi	r24, 0x02	; 2
    2d5e:	31 f4       	brne	.+12     	; 0x2d6c <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d60:	89 81       	ldd	r24, Y+1	; 0x01
    2d62:	88 23       	and	r24, r24
    2d64:	19 f0       	breq	.+6      	; 0x2d6c <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2d66:	89 81       	ldd	r24, Y+1	; 0x01
    2d68:	81 50       	subi	r24, 0x01	; 1
    2d6a:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    2d6c:	89 81       	ldd	r24, Y+1	; 0x01
    2d6e:	8f 5f       	subi	r24, 0xFF	; 255
    2d70:	eb 81       	ldd	r30, Y+3	; 0x03
    2d72:	fc 81       	ldd	r31, Y+4	; 0x04
    2d74:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2d76:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2d78:	27 96       	adiw	r28, 0x07	; 7
    2d7a:	0f b6       	in	r0, 0x3f	; 63
    2d7c:	f8 94       	cli
    2d7e:	de bf       	out	0x3e, r29	; 62
    2d80:	0f be       	out	0x3f, r0	; 63
    2d82:	cd bf       	out	0x3d, r28	; 61
    2d84:	cf 91       	pop	r28
    2d86:	df 91       	pop	r29
    2d88:	08 95       	ret

00002d8a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2d8a:	df 93       	push	r29
    2d8c:	cf 93       	push	r28
    2d8e:	00 d0       	rcall	.+0      	; 0x2d90 <prvCopyDataFromQueue+0x6>
    2d90:	00 d0       	rcall	.+0      	; 0x2d92 <prvCopyDataFromQueue+0x8>
    2d92:	cd b7       	in	r28, 0x3d	; 61
    2d94:	de b7       	in	r29, 0x3e	; 62
    2d96:	9a 83       	std	Y+2, r25	; 0x02
    2d98:	89 83       	std	Y+1, r24	; 0x01
    2d9a:	7c 83       	std	Y+4, r23	; 0x04
    2d9c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2d9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2da0:	fa 81       	ldd	r31, Y+2	; 0x02
    2da2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2da4:	88 23       	and	r24, r24
    2da6:	89 f1       	breq	.+98     	; 0x2e0a <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2da8:	e9 81       	ldd	r30, Y+1	; 0x01
    2daa:	fa 81       	ldd	r31, Y+2	; 0x02
    2dac:	26 81       	ldd	r18, Z+6	; 0x06
    2dae:	37 81       	ldd	r19, Z+7	; 0x07
    2db0:	e9 81       	ldd	r30, Y+1	; 0x01
    2db2:	fa 81       	ldd	r31, Y+2	; 0x02
    2db4:	84 8d       	ldd	r24, Z+28	; 0x1c
    2db6:	88 2f       	mov	r24, r24
    2db8:	90 e0       	ldi	r25, 0x00	; 0
    2dba:	82 0f       	add	r24, r18
    2dbc:	93 1f       	adc	r25, r19
    2dbe:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc0:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc2:	97 83       	std	Z+7, r25	; 0x07
    2dc4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2dc6:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dca:	26 81       	ldd	r18, Z+6	; 0x06
    2dcc:	37 81       	ldd	r19, Z+7	; 0x07
    2dce:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd2:	82 81       	ldd	r24, Z+2	; 0x02
    2dd4:	93 81       	ldd	r25, Z+3	; 0x03
    2dd6:	28 17       	cp	r18, r24
    2dd8:	39 07       	cpc	r19, r25
    2dda:	40 f0       	brcs	.+16     	; 0x2dec <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dde:	fa 81       	ldd	r31, Y+2	; 0x02
    2de0:	80 81       	ld	r24, Z
    2de2:	91 81       	ldd	r25, Z+1	; 0x01
    2de4:	e9 81       	ldd	r30, Y+1	; 0x01
    2de6:	fa 81       	ldd	r31, Y+2	; 0x02
    2de8:	97 83       	std	Z+7, r25	; 0x07
    2dea:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2dec:	e9 81       	ldd	r30, Y+1	; 0x01
    2dee:	fa 81       	ldd	r31, Y+2	; 0x02
    2df0:	46 81       	ldd	r20, Z+6	; 0x06
    2df2:	57 81       	ldd	r21, Z+7	; 0x07
    2df4:	e9 81       	ldd	r30, Y+1	; 0x01
    2df6:	fa 81       	ldd	r31, Y+2	; 0x02
    2df8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2dfa:	28 2f       	mov	r18, r24
    2dfc:	30 e0       	ldi	r19, 0x00	; 0
    2dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2e00:	9c 81       	ldd	r25, Y+4	; 0x04
    2e02:	ba 01       	movw	r22, r20
    2e04:	a9 01       	movw	r20, r18
    2e06:	0e 94 39 30 	call	0x6072	; 0x6072 <memcpy>
	}
}
    2e0a:	0f 90       	pop	r0
    2e0c:	0f 90       	pop	r0
    2e0e:	0f 90       	pop	r0
    2e10:	0f 90       	pop	r0
    2e12:	cf 91       	pop	r28
    2e14:	df 91       	pop	r29
    2e16:	08 95       	ret

00002e18 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2e18:	df 93       	push	r29
    2e1a:	cf 93       	push	r28
    2e1c:	00 d0       	rcall	.+0      	; 0x2e1e <prvUnlockQueue+0x6>
    2e1e:	00 d0       	rcall	.+0      	; 0x2e20 <prvUnlockQueue+0x8>
    2e20:	cd b7       	in	r28, 0x3d	; 61
    2e22:	de b7       	in	r29, 0x3e	; 62
    2e24:	9c 83       	std	Y+4, r25	; 0x04
    2e26:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2e28:	0f b6       	in	r0, 0x3f	; 63
    2e2a:	f8 94       	cli
    2e2c:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2e2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e30:	fc 81       	ldd	r31, Y+4	; 0x04
    2e32:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e34:	8a 83       	std	Y+2, r24	; 0x02
    2e36:	11 c0       	rjmp	.+34     	; 0x2e5a <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e38:	eb 81       	ldd	r30, Y+3	; 0x03
    2e3a:	fc 81       	ldd	r31, Y+4	; 0x04
    2e3c:	81 89       	ldd	r24, Z+17	; 0x11
    2e3e:	88 23       	and	r24, r24
    2e40:	79 f0       	breq	.+30     	; 0x2e60 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e42:	8b 81       	ldd	r24, Y+3	; 0x03
    2e44:	9c 81       	ldd	r25, Y+4	; 0x04
    2e46:	41 96       	adiw	r24, 0x11	; 17
    2e48:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    2e4c:	88 23       	and	r24, r24
    2e4e:	11 f0       	breq	.+4      	; 0x2e54 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2e50:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2e54:	8a 81       	ldd	r24, Y+2	; 0x02
    2e56:	81 50       	subi	r24, 0x01	; 1
    2e58:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2e5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e5c:	18 16       	cp	r1, r24
    2e5e:	64 f3       	brlt	.-40     	; 0x2e38 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2e60:	eb 81       	ldd	r30, Y+3	; 0x03
    2e62:	fc 81       	ldd	r31, Y+4	; 0x04
    2e64:	8f ef       	ldi	r24, 0xFF	; 255
    2e66:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2e68:	0f 90       	pop	r0
    2e6a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2e6c:	0f b6       	in	r0, 0x3f	; 63
    2e6e:	f8 94       	cli
    2e70:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2e72:	eb 81       	ldd	r30, Y+3	; 0x03
    2e74:	fc 81       	ldd	r31, Y+4	; 0x04
    2e76:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e78:	89 83       	std	Y+1, r24	; 0x01
    2e7a:	11 c0       	rjmp	.+34     	; 0x2e9e <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e80:	80 85       	ldd	r24, Z+8	; 0x08
    2e82:	88 23       	and	r24, r24
    2e84:	79 f0       	breq	.+30     	; 0x2ea4 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e86:	8b 81       	ldd	r24, Y+3	; 0x03
    2e88:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8a:	08 96       	adiw	r24, 0x08	; 8
    2e8c:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <xTaskRemoveFromEventList>
    2e90:	88 23       	and	r24, r24
    2e92:	11 f0       	breq	.+4      	; 0x2e98 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2e94:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2e98:	89 81       	ldd	r24, Y+1	; 0x01
    2e9a:	81 50       	subi	r24, 0x01	; 1
    2e9c:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2e9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ea0:	18 16       	cp	r1, r24
    2ea2:	64 f3       	brlt	.-40     	; 0x2e7c <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2ea4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ea8:	8f ef       	ldi	r24, 0xFF	; 255
    2eaa:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2eac:	0f 90       	pop	r0
    2eae:	0f be       	out	0x3f, r0	; 63
}
    2eb0:	0f 90       	pop	r0
    2eb2:	0f 90       	pop	r0
    2eb4:	0f 90       	pop	r0
    2eb6:	0f 90       	pop	r0
    2eb8:	cf 91       	pop	r28
    2eba:	df 91       	pop	r29
    2ebc:	08 95       	ret

00002ebe <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2ebe:	df 93       	push	r29
    2ec0:	cf 93       	push	r28
    2ec2:	00 d0       	rcall	.+0      	; 0x2ec4 <prvIsQueueEmpty+0x6>
    2ec4:	0f 92       	push	r0
    2ec6:	cd b7       	in	r28, 0x3d	; 61
    2ec8:	de b7       	in	r29, 0x3e	; 62
    2eca:	9b 83       	std	Y+3, r25	; 0x03
    2ecc:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2ece:	0f b6       	in	r0, 0x3f	; 63
    2ed0:	f8 94       	cli
    2ed2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2ed4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ed6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ed8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2eda:	88 23       	and	r24, r24
    2edc:	19 f4       	brne	.+6      	; 0x2ee4 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2ede:	81 e0       	ldi	r24, 0x01	; 1
    2ee0:	89 83       	std	Y+1, r24	; 0x01
    2ee2:	01 c0       	rjmp	.+2      	; 0x2ee6 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2ee4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ee6:	0f 90       	pop	r0
    2ee8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2eea:	89 81       	ldd	r24, Y+1	; 0x01
}
    2eec:	0f 90       	pop	r0
    2eee:	0f 90       	pop	r0
    2ef0:	0f 90       	pop	r0
    2ef2:	cf 91       	pop	r28
    2ef4:	df 91       	pop	r29
    2ef6:	08 95       	ret

00002ef8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2ef8:	df 93       	push	r29
    2efa:	cf 93       	push	r28
    2efc:	00 d0       	rcall	.+0      	; 0x2efe <xQueueIsQueueEmptyFromISR+0x6>
    2efe:	0f 92       	push	r0
    2f00:	cd b7       	in	r28, 0x3d	; 61
    2f02:	de b7       	in	r29, 0x3e	; 62
    2f04:	9b 83       	std	Y+3, r25	; 0x03
    2f06:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2f08:	ea 81       	ldd	r30, Y+2	; 0x02
    2f0a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f0e:	88 23       	and	r24, r24
    2f10:	19 f4       	brne	.+6      	; 0x2f18 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    2f12:	81 e0       	ldi	r24, 0x01	; 1
    2f14:	89 83       	std	Y+1, r24	; 0x01
    2f16:	01 c0       	rjmp	.+2      	; 0x2f1a <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    2f18:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2f1a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2f1c:	0f 90       	pop	r0
    2f1e:	0f 90       	pop	r0
    2f20:	0f 90       	pop	r0
    2f22:	cf 91       	pop	r28
    2f24:	df 91       	pop	r29
    2f26:	08 95       	ret

00002f28 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2f28:	df 93       	push	r29
    2f2a:	cf 93       	push	r28
    2f2c:	00 d0       	rcall	.+0      	; 0x2f2e <prvIsQueueFull+0x6>
    2f2e:	0f 92       	push	r0
    2f30:	cd b7       	in	r28, 0x3d	; 61
    2f32:	de b7       	in	r29, 0x3e	; 62
    2f34:	9b 83       	std	Y+3, r25	; 0x03
    2f36:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2f38:	0f b6       	in	r0, 0x3f	; 63
    2f3a:	f8 94       	cli
    2f3c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2f3e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f40:	fb 81       	ldd	r31, Y+3	; 0x03
    2f42:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f44:	ea 81       	ldd	r30, Y+2	; 0x02
    2f46:	fb 81       	ldd	r31, Y+3	; 0x03
    2f48:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f4a:	98 17       	cp	r25, r24
    2f4c:	19 f4       	brne	.+6      	; 0x2f54 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2f4e:	81 e0       	ldi	r24, 0x01	; 1
    2f50:	89 83       	std	Y+1, r24	; 0x01
    2f52:	01 c0       	rjmp	.+2      	; 0x2f56 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2f54:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2f56:	0f 90       	pop	r0
    2f58:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2f5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f5c:	0f 90       	pop	r0
    2f5e:	0f 90       	pop	r0
    2f60:	0f 90       	pop	r0
    2f62:	cf 91       	pop	r28
    2f64:	df 91       	pop	r29
    2f66:	08 95       	ret

00002f68 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2f68:	df 93       	push	r29
    2f6a:	cf 93       	push	r28
    2f6c:	00 d0       	rcall	.+0      	; 0x2f6e <xQueueIsQueueFullFromISR+0x6>
    2f6e:	0f 92       	push	r0
    2f70:	cd b7       	in	r28, 0x3d	; 61
    2f72:	de b7       	in	r29, 0x3e	; 62
    2f74:	9b 83       	std	Y+3, r25	; 0x03
    2f76:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    2f78:	ea 81       	ldd	r30, Y+2	; 0x02
    2f7a:	fb 81       	ldd	r31, Y+3	; 0x03
    2f7c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f7e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f80:	fb 81       	ldd	r31, Y+3	; 0x03
    2f82:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f84:	98 17       	cp	r25, r24
    2f86:	19 f4       	brne	.+6      	; 0x2f8e <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    2f88:	81 e0       	ldi	r24, 0x01	; 1
    2f8a:	89 83       	std	Y+1, r24	; 0x01
    2f8c:	01 c0       	rjmp	.+2      	; 0x2f90 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    2f8e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2f90:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2f92:	0f 90       	pop	r0
    2f94:	0f 90       	pop	r0
    2f96:	0f 90       	pop	r0
    2f98:	cf 91       	pop	r28
    2f9a:	df 91       	pop	r29
    2f9c:	08 95       	ret

00002f9e <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    2f9e:	8f 92       	push	r8
    2fa0:	9f 92       	push	r9
    2fa2:	af 92       	push	r10
    2fa4:	bf 92       	push	r11
    2fa6:	cf 92       	push	r12
    2fa8:	df 92       	push	r13
    2faa:	ef 92       	push	r14
    2fac:	ff 92       	push	r15
    2fae:	0f 93       	push	r16
    2fb0:	1f 93       	push	r17
    2fb2:	df 93       	push	r29
    2fb4:	cf 93       	push	r28
    2fb6:	cd b7       	in	r28, 0x3d	; 61
    2fb8:	de b7       	in	r29, 0x3e	; 62
    2fba:	60 97       	sbiw	r28, 0x10	; 16
    2fbc:	0f b6       	in	r0, 0x3f	; 63
    2fbe:	f8 94       	cli
    2fc0:	de bf       	out	0x3e, r29	; 62
    2fc2:	0f be       	out	0x3f, r0	; 63
    2fc4:	cd bf       	out	0x3d, r28	; 61
    2fc6:	9f 83       	std	Y+7, r25	; 0x07
    2fc8:	8e 83       	std	Y+6, r24	; 0x06
    2fca:	79 87       	std	Y+9, r23	; 0x09
    2fcc:	68 87       	std	Y+8, r22	; 0x08
    2fce:	5b 87       	std	Y+11, r21	; 0x0b
    2fd0:	4a 87       	std	Y+10, r20	; 0x0a
    2fd2:	3d 87       	std	Y+13, r19	; 0x0d
    2fd4:	2c 87       	std	Y+12, r18	; 0x0c
    2fd6:	0e 87       	std	Y+14, r16	; 0x0e
    2fd8:	f8 8a       	std	Y+16, r15	; 0x10
    2fda:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2fdc:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fde:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fe0:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <pvPortMalloc>
    2fe4:	9a 83       	std	Y+2, r25	; 0x02
    2fe6:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2fe8:	89 81       	ldd	r24, Y+1	; 0x01
    2fea:	9a 81       	ldd	r25, Y+2	; 0x02
    2fec:	00 97       	sbiw	r24, 0x00	; 0
    2fee:	b1 f0       	breq	.+44     	; 0x301c <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    2ff0:	83 e2       	ldi	r24, 0x23	; 35
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <pvPortMalloc>
    2ff8:	9d 83       	std	Y+5, r25	; 0x05
    2ffa:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2ffc:	8c 81       	ldd	r24, Y+4	; 0x04
    2ffe:	9d 81       	ldd	r25, Y+5	; 0x05
    3000:	00 97       	sbiw	r24, 0x00	; 0
    3002:	39 f0       	breq	.+14     	; 0x3012 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3004:	ec 81       	ldd	r30, Y+4	; 0x04
    3006:	fd 81       	ldd	r31, Y+5	; 0x05
    3008:	89 81       	ldd	r24, Y+1	; 0x01
    300a:	9a 81       	ldd	r25, Y+2	; 0x02
    300c:	90 8f       	std	Z+24, r25	; 0x18
    300e:	87 8b       	std	Z+23, r24	; 0x17
    3010:	07 c0       	rjmp	.+14     	; 0x3020 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3012:	89 81       	ldd	r24, Y+1	; 0x01
    3014:	9a 81       	ldd	r25, Y+2	; 0x02
    3016:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vPortFree>
    301a:	02 c0       	rjmp	.+4      	; 0x3020 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    301c:	1d 82       	std	Y+5, r1	; 0x05
    301e:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3020:	8c 81       	ldd	r24, Y+4	; 0x04
    3022:	9d 81       	ldd	r25, Y+5	; 0x05
    3024:	00 97       	sbiw	r24, 0x00	; 0
    3026:	e9 f0       	breq	.+58     	; 0x3062 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3028:	8a 85       	ldd	r24, Y+10	; 0x0a
    302a:	9b 85       	ldd	r25, Y+11	; 0x0b
    302c:	9c 01       	movw	r18, r24
    302e:	40 e0       	ldi	r20, 0x00	; 0
    3030:	50 e0       	ldi	r21, 0x00	; 0
    3032:	8e 81       	ldd	r24, Y+6	; 0x06
    3034:	9f 81       	ldd	r25, Y+7	; 0x07
    3036:	68 85       	ldd	r22, Y+8	; 0x08
    3038:	79 85       	ldd	r23, Y+9	; 0x09
    303a:	ec 85       	ldd	r30, Y+12	; 0x0c
    303c:	fd 85       	ldd	r31, Y+13	; 0x0d
    303e:	af 85       	ldd	r26, Y+15	; 0x0f
    3040:	b8 89       	ldd	r27, Y+16	; 0x10
    3042:	ac 80       	ldd	r10, Y+4	; 0x04
    3044:	bd 80       	ldd	r11, Y+5	; 0x05
    3046:	8f 01       	movw	r16, r30
    3048:	ee 84       	ldd	r14, Y+14	; 0x0e
    304a:	6d 01       	movw	r12, r26
    304c:	88 24       	eor	r8, r8
    304e:	99 24       	eor	r9, r9
    3050:	0e 94 47 18 	call	0x308e	; 0x308e <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3054:	8c 81       	ldd	r24, Y+4	; 0x04
    3056:	9d 81       	ldd	r25, Y+5	; 0x05
    3058:	0e 94 02 19 	call	0x3204	; 0x3204 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    305c:	81 e0       	ldi	r24, 0x01	; 1
    305e:	8b 83       	std	Y+3, r24	; 0x03
    3060:	02 c0       	rjmp	.+4      	; 0x3066 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3062:	8f ef       	ldi	r24, 0xFF	; 255
    3064:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3066:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3068:	60 96       	adiw	r28, 0x10	; 16
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	de bf       	out	0x3e, r29	; 62
    3070:	0f be       	out	0x3f, r0	; 63
    3072:	cd bf       	out	0x3d, r28	; 61
    3074:	cf 91       	pop	r28
    3076:	df 91       	pop	r29
    3078:	1f 91       	pop	r17
    307a:	0f 91       	pop	r16
    307c:	ff 90       	pop	r15
    307e:	ef 90       	pop	r14
    3080:	df 90       	pop	r13
    3082:	cf 90       	pop	r12
    3084:	bf 90       	pop	r11
    3086:	af 90       	pop	r10
    3088:	9f 90       	pop	r9
    308a:	8f 90       	pop	r8
    308c:	08 95       	ret

0000308e <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    308e:	8f 92       	push	r8
    3090:	9f 92       	push	r9
    3092:	af 92       	push	r10
    3094:	bf 92       	push	r11
    3096:	cf 92       	push	r12
    3098:	df 92       	push	r13
    309a:	ef 92       	push	r14
    309c:	0f 93       	push	r16
    309e:	1f 93       	push	r17
    30a0:	df 93       	push	r29
    30a2:	cf 93       	push	r28
    30a4:	cd b7       	in	r28, 0x3d	; 61
    30a6:	de b7       	in	r29, 0x3e	; 62
    30a8:	64 97       	sbiw	r28, 0x14	; 20
    30aa:	0f b6       	in	r0, 0x3f	; 63
    30ac:	f8 94       	cli
    30ae:	de bf       	out	0x3e, r29	; 62
    30b0:	0f be       	out	0x3f, r0	; 63
    30b2:	cd bf       	out	0x3d, r28	; 61
    30b4:	9d 83       	std	Y+5, r25	; 0x05
    30b6:	8c 83       	std	Y+4, r24	; 0x04
    30b8:	7f 83       	std	Y+7, r23	; 0x07
    30ba:	6e 83       	std	Y+6, r22	; 0x06
    30bc:	28 87       	std	Y+8, r18	; 0x08
    30be:	39 87       	std	Y+9, r19	; 0x09
    30c0:	4a 87       	std	Y+10, r20	; 0x0a
    30c2:	5b 87       	std	Y+11, r21	; 0x0b
    30c4:	1d 87       	std	Y+13, r17	; 0x0d
    30c6:	0c 87       	std	Y+12, r16	; 0x0c
    30c8:	ee 86       	std	Y+14, r14	; 0x0e
    30ca:	d8 8a       	std	Y+16, r13	; 0x10
    30cc:	cf 86       	std	Y+15, r12	; 0x0f
    30ce:	ba 8a       	std	Y+18, r11	; 0x12
    30d0:	a9 8a       	std	Y+17, r10	; 0x11
    30d2:	9c 8a       	std	Y+20, r9	; 0x14
    30d4:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    30d6:	e9 89       	ldd	r30, Y+17	; 0x11
    30d8:	fa 89       	ldd	r31, Y+18	; 0x12
    30da:	27 89       	ldd	r18, Z+23	; 0x17
    30dc:	30 8d       	ldd	r19, Z+24	; 0x18
    30de:	88 85       	ldd	r24, Y+8	; 0x08
    30e0:	99 85       	ldd	r25, Y+9	; 0x09
    30e2:	01 97       	sbiw	r24, 0x01	; 1
    30e4:	82 0f       	add	r24, r18
    30e6:	93 1f       	adc	r25, r19
    30e8:	9b 83       	std	Y+3, r25	; 0x03
    30ea:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    30ec:	19 82       	std	Y+1, r1	; 0x01
    30ee:	21 c0       	rjmp	.+66     	; 0x3132 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    30f0:	89 81       	ldd	r24, Y+1	; 0x01
    30f2:	48 2f       	mov	r20, r24
    30f4:	50 e0       	ldi	r21, 0x00	; 0
    30f6:	89 81       	ldd	r24, Y+1	; 0x01
    30f8:	28 2f       	mov	r18, r24
    30fa:	30 e0       	ldi	r19, 0x00	; 0
    30fc:	8e 81       	ldd	r24, Y+6	; 0x06
    30fe:	9f 81       	ldd	r25, Y+7	; 0x07
    3100:	fc 01       	movw	r30, r24
    3102:	e2 0f       	add	r30, r18
    3104:	f3 1f       	adc	r31, r19
    3106:	20 81       	ld	r18, Z
    3108:	89 89       	ldd	r24, Y+17	; 0x11
    310a:	9a 89       	ldd	r25, Y+18	; 0x12
    310c:	84 0f       	add	r24, r20
    310e:	95 1f       	adc	r25, r21
    3110:	fc 01       	movw	r30, r24
    3112:	79 96       	adiw	r30, 0x19	; 25
    3114:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    3116:	89 81       	ldd	r24, Y+1	; 0x01
    3118:	28 2f       	mov	r18, r24
    311a:	30 e0       	ldi	r19, 0x00	; 0
    311c:	8e 81       	ldd	r24, Y+6	; 0x06
    311e:	9f 81       	ldd	r25, Y+7	; 0x07
    3120:	fc 01       	movw	r30, r24
    3122:	e2 0f       	add	r30, r18
    3124:	f3 1f       	adc	r31, r19
    3126:	80 81       	ld	r24, Z
    3128:	88 23       	and	r24, r24
    312a:	31 f0       	breq	.+12     	; 0x3138 <prvInitialiseNewTask+0xaa>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    312c:	89 81       	ldd	r24, Y+1	; 0x01
    312e:	8f 5f       	subi	r24, 0xFF	; 255
    3130:	89 83       	std	Y+1, r24	; 0x01
    3132:	89 81       	ldd	r24, Y+1	; 0x01
    3134:	83 30       	cpi	r24, 0x03	; 3
    3136:	e0 f2       	brcs	.-72     	; 0x30f0 <prvInitialiseNewTask+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3138:	e9 89       	ldd	r30, Y+17	; 0x11
    313a:	fa 89       	ldd	r31, Y+18	; 0x12
    313c:	13 8e       	std	Z+27, r1	; 0x1b

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    313e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3140:	83 30       	cpi	r24, 0x03	; 3
    3142:	10 f0       	brcs	.+4      	; 0x3148 <prvInitialiseNewTask+0xba>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3144:	82 e0       	ldi	r24, 0x02	; 2
    3146:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3148:	e9 89       	ldd	r30, Y+17	; 0x11
    314a:	fa 89       	ldd	r31, Y+18	; 0x12
    314c:	8e 85       	ldd	r24, Y+14	; 0x0e
    314e:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    3150:	e9 89       	ldd	r30, Y+17	; 0x11
    3152:	fa 89       	ldd	r31, Y+18	; 0x12
    3154:	8e 85       	ldd	r24, Y+14	; 0x0e
    3156:	84 8f       	std	Z+28, r24	; 0x1c
		pxNewTCB->uxMutexesHeld = 0;
    3158:	e9 89       	ldd	r30, Y+17	; 0x11
    315a:	fa 89       	ldd	r31, Y+18	; 0x12
    315c:	15 8e       	std	Z+29, r1	; 0x1d
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    315e:	89 89       	ldd	r24, Y+17	; 0x11
    3160:	9a 89       	ldd	r25, Y+18	; 0x12
    3162:	02 96       	adiw	r24, 0x02	; 2
    3164:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3168:	89 89       	ldd	r24, Y+17	; 0x11
    316a:	9a 89       	ldd	r25, Y+18	; 0x12
    316c:	0c 96       	adiw	r24, 0x0c	; 12
    316e:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3172:	e9 89       	ldd	r30, Y+17	; 0x11
    3174:	fa 89       	ldd	r31, Y+18	; 0x12
    3176:	89 89       	ldd	r24, Y+17	; 0x11
    3178:	9a 89       	ldd	r25, Y+18	; 0x12
    317a:	91 87       	std	Z+9, r25	; 0x09
    317c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    317e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3180:	28 2f       	mov	r18, r24
    3182:	30 e0       	ldi	r19, 0x00	; 0
    3184:	83 e0       	ldi	r24, 0x03	; 3
    3186:	90 e0       	ldi	r25, 0x00	; 0
    3188:	82 1b       	sub	r24, r18
    318a:	93 0b       	sbc	r25, r19
    318c:	e9 89       	ldd	r30, Y+17	; 0x11
    318e:	fa 89       	ldd	r31, Y+18	; 0x12
    3190:	95 87       	std	Z+13, r25	; 0x0d
    3192:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3194:	e9 89       	ldd	r30, Y+17	; 0x11
    3196:	fa 89       	ldd	r31, Y+18	; 0x12
    3198:	89 89       	ldd	r24, Y+17	; 0x11
    319a:	9a 89       	ldd	r25, Y+18	; 0x12
    319c:	93 8b       	std	Z+19, r25	; 0x13
    319e:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    31a0:	e9 89       	ldd	r30, Y+17	; 0x11
    31a2:	fa 89       	ldd	r31, Y+18	; 0x12
    31a4:	16 8e       	std	Z+30, r1	; 0x1e
    31a6:	17 8e       	std	Z+31, r1	; 0x1f
    31a8:	10 a2       	std	Z+32, r1	; 0x20
    31aa:	11 a2       	std	Z+33, r1	; 0x21
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    31ac:	e9 89       	ldd	r30, Y+17	; 0x11
    31ae:	fa 89       	ldd	r31, Y+18	; 0x12
    31b0:	12 a2       	std	Z+34, r1	; 0x22
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    31b2:	8a 81       	ldd	r24, Y+2	; 0x02
    31b4:	9b 81       	ldd	r25, Y+3	; 0x03
    31b6:	2c 81       	ldd	r18, Y+4	; 0x04
    31b8:	3d 81       	ldd	r19, Y+5	; 0x05
    31ba:	4c 85       	ldd	r20, Y+12	; 0x0c
    31bc:	5d 85       	ldd	r21, Y+13	; 0x0d
    31be:	b9 01       	movw	r22, r18
    31c0:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <pxPortInitialiseStack>
    31c4:	e9 89       	ldd	r30, Y+17	; 0x11
    31c6:	fa 89       	ldd	r31, Y+18	; 0x12
    31c8:	91 83       	std	Z+1, r25	; 0x01
    31ca:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    31cc:	8f 85       	ldd	r24, Y+15	; 0x0f
    31ce:	98 89       	ldd	r25, Y+16	; 0x10
    31d0:	00 97       	sbiw	r24, 0x00	; 0
    31d2:	31 f0       	breq	.+12     	; 0x31e0 <prvInitialiseNewTask+0x152>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    31d4:	ef 85       	ldd	r30, Y+15	; 0x0f
    31d6:	f8 89       	ldd	r31, Y+16	; 0x10
    31d8:	89 89       	ldd	r24, Y+17	; 0x11
    31da:	9a 89       	ldd	r25, Y+18	; 0x12
    31dc:	91 83       	std	Z+1, r25	; 0x01
    31de:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    31e0:	64 96       	adiw	r28, 0x14	; 20
    31e2:	0f b6       	in	r0, 0x3f	; 63
    31e4:	f8 94       	cli
    31e6:	de bf       	out	0x3e, r29	; 62
    31e8:	0f be       	out	0x3f, r0	; 63
    31ea:	cd bf       	out	0x3d, r28	; 61
    31ec:	cf 91       	pop	r28
    31ee:	df 91       	pop	r29
    31f0:	1f 91       	pop	r17
    31f2:	0f 91       	pop	r16
    31f4:	ef 90       	pop	r14
    31f6:	df 90       	pop	r13
    31f8:	cf 90       	pop	r12
    31fa:	bf 90       	pop	r11
    31fc:	af 90       	pop	r10
    31fe:	9f 90       	pop	r9
    3200:	8f 90       	pop	r8
    3202:	08 95       	ret

00003204 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3204:	df 93       	push	r29
    3206:	cf 93       	push	r28
    3208:	00 d0       	rcall	.+0      	; 0x320a <prvAddNewTaskToReadyList+0x6>
    320a:	cd b7       	in	r28, 0x3d	; 61
    320c:	de b7       	in	r29, 0x3e	; 62
    320e:	9a 83       	std	Y+2, r25	; 0x02
    3210:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3212:	0f b6       	in	r0, 0x3f	; 63
    3214:	f8 94       	cli
    3216:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3218:	80 91 32 07 	lds	r24, 0x0732
    321c:	8f 5f       	subi	r24, 0xFF	; 255
    321e:	80 93 32 07 	sts	0x0732, r24
		if( pxCurrentTCB == NULL )
    3222:	80 91 30 07 	lds	r24, 0x0730
    3226:	90 91 31 07 	lds	r25, 0x0731
    322a:	00 97       	sbiw	r24, 0x00	; 0
    322c:	69 f4       	brne	.+26     	; 0x3248 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    322e:	89 81       	ldd	r24, Y+1	; 0x01
    3230:	9a 81       	ldd	r25, Y+2	; 0x02
    3232:	90 93 31 07 	sts	0x0731, r25
    3236:	80 93 30 07 	sts	0x0730, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    323a:	80 91 32 07 	lds	r24, 0x0732
    323e:	81 30       	cpi	r24, 0x01	; 1
    3240:	b9 f4       	brne	.+46     	; 0x3270 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3242:	0e 94 19 20 	call	0x4032	; 0x4032 <prvInitialiseTaskLists>
    3246:	14 c0       	rjmp	.+40     	; 0x3270 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3248:	80 91 36 07 	lds	r24, 0x0736
    324c:	88 23       	and	r24, r24
    324e:	81 f4       	brne	.+32     	; 0x3270 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3250:	e0 91 30 07 	lds	r30, 0x0730
    3254:	f0 91 31 07 	lds	r31, 0x0731
    3258:	96 89       	ldd	r25, Z+22	; 0x16
    325a:	e9 81       	ldd	r30, Y+1	; 0x01
    325c:	fa 81       	ldd	r31, Y+2	; 0x02
    325e:	86 89       	ldd	r24, Z+22	; 0x16
    3260:	89 17       	cp	r24, r25
    3262:	30 f0       	brcs	.+12     	; 0x3270 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3264:	89 81       	ldd	r24, Y+1	; 0x01
    3266:	9a 81       	ldd	r25, Y+2	; 0x02
    3268:	90 93 31 07 	sts	0x0731, r25
    326c:	80 93 30 07 	sts	0x0730, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3270:	80 91 3a 07 	lds	r24, 0x073A
    3274:	8f 5f       	subi	r24, 0xFF	; 255
    3276:	80 93 3a 07 	sts	0x073A, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    327a:	e9 81       	ldd	r30, Y+1	; 0x01
    327c:	fa 81       	ldd	r31, Y+2	; 0x02
    327e:	96 89       	ldd	r25, Z+22	; 0x16
    3280:	80 91 35 07 	lds	r24, 0x0735
    3284:	89 17       	cp	r24, r25
    3286:	28 f4       	brcc	.+10     	; 0x3292 <prvAddNewTaskToReadyList+0x8e>
    3288:	e9 81       	ldd	r30, Y+1	; 0x01
    328a:	fa 81       	ldd	r31, Y+2	; 0x02
    328c:	86 89       	ldd	r24, Z+22	; 0x16
    328e:	80 93 35 07 	sts	0x0735, r24
    3292:	e9 81       	ldd	r30, Y+1	; 0x01
    3294:	fa 81       	ldd	r31, Y+2	; 0x02
    3296:	86 89       	ldd	r24, Z+22	; 0x16
    3298:	28 2f       	mov	r18, r24
    329a:	30 e0       	ldi	r19, 0x00	; 0
    329c:	c9 01       	movw	r24, r18
    329e:	88 0f       	add	r24, r24
    32a0:	99 1f       	adc	r25, r25
    32a2:	88 0f       	add	r24, r24
    32a4:	99 1f       	adc	r25, r25
    32a6:	88 0f       	add	r24, r24
    32a8:	99 1f       	adc	r25, r25
    32aa:	82 0f       	add	r24, r18
    32ac:	93 1f       	adc	r25, r19
    32ae:	ac 01       	movw	r20, r24
    32b0:	40 5c       	subi	r20, 0xC0	; 192
    32b2:	58 4f       	sbci	r21, 0xF8	; 248
    32b4:	89 81       	ldd	r24, Y+1	; 0x01
    32b6:	9a 81       	ldd	r25, Y+2	; 0x02
    32b8:	9c 01       	movw	r18, r24
    32ba:	2e 5f       	subi	r18, 0xFE	; 254
    32bc:	3f 4f       	sbci	r19, 0xFF	; 255
    32be:	ca 01       	movw	r24, r20
    32c0:	b9 01       	movw	r22, r18
    32c2:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    32c6:	0f 90       	pop	r0
    32c8:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    32ca:	80 91 36 07 	lds	r24, 0x0736
    32ce:	88 23       	and	r24, r24
    32d0:	61 f0       	breq	.+24     	; 0x32ea <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    32d2:	e0 91 30 07 	lds	r30, 0x0730
    32d6:	f0 91 31 07 	lds	r31, 0x0731
    32da:	96 89       	ldd	r25, Z+22	; 0x16
    32dc:	e9 81       	ldd	r30, Y+1	; 0x01
    32de:	fa 81       	ldd	r31, Y+2	; 0x02
    32e0:	86 89       	ldd	r24, Z+22	; 0x16
    32e2:	98 17       	cp	r25, r24
    32e4:	10 f4       	brcc	.+4      	; 0x32ea <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    32e6:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    32ea:	0f 90       	pop	r0
    32ec:	0f 90       	pop	r0
    32ee:	cf 91       	pop	r28
    32f0:	df 91       	pop	r29
    32f2:	08 95       	ret

000032f4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    32f4:	df 93       	push	r29
    32f6:	cf 93       	push	r28
    32f8:	00 d0       	rcall	.+0      	; 0x32fa <vTaskDelay+0x6>
    32fa:	0f 92       	push	r0
    32fc:	cd b7       	in	r28, 0x3d	; 61
    32fe:	de b7       	in	r29, 0x3e	; 62
    3300:	9b 83       	std	Y+3, r25	; 0x03
    3302:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3304:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3306:	8a 81       	ldd	r24, Y+2	; 0x02
    3308:	9b 81       	ldd	r25, Y+3	; 0x03
    330a:	00 97       	sbiw	r24, 0x00	; 0
    330c:	51 f0       	breq	.+20     	; 0x3322 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    330e:	0e 94 09 1c 	call	0x3812	; 0x3812 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3312:	8a 81       	ldd	r24, Y+2	; 0x02
    3314:	9b 81       	ldd	r25, Y+3	; 0x03
    3316:	60 e0       	ldi	r22, 0x00	; 0
    3318:	0e 94 80 25 	call	0x4b00	; 0x4b00 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    331c:	0e 94 15 1c 	call	0x382a	; 0x382a <xTaskResumeAll>
    3320:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3322:	89 81       	ldd	r24, Y+1	; 0x01
    3324:	88 23       	and	r24, r24
    3326:	11 f4       	brne	.+4      	; 0x332c <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3328:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    332c:	0f 90       	pop	r0
    332e:	0f 90       	pop	r0
    3330:	0f 90       	pop	r0
    3332:	cf 91       	pop	r28
    3334:	df 91       	pop	r29
    3336:	08 95       	ret

00003338 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    3338:	df 93       	push	r29
    333a:	cf 93       	push	r28
    333c:	cd b7       	in	r28, 0x3d	; 61
    333e:	de b7       	in	r29, 0x3e	; 62
    3340:	2a 97       	sbiw	r28, 0x0a	; 10
    3342:	0f b6       	in	r0, 0x3f	; 63
    3344:	f8 94       	cli
    3346:	de bf       	out	0x3e, r29	; 62
    3348:	0f be       	out	0x3f, r0	; 63
    334a:	cd bf       	out	0x3d, r28	; 61
    334c:	9f 83       	std	Y+7, r25	; 0x07
    334e:	8e 83       	std	Y+6, r24	; 0x06
    3350:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    3352:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3354:	88 85       	ldd	r24, Y+8	; 0x08
    3356:	83 30       	cpi	r24, 0x03	; 3
    3358:	10 f0       	brcs	.+4      	; 0x335e <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    335a:	82 e0       	ldi	r24, 0x02	; 2
    335c:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    335e:	0f b6       	in	r0, 0x3f	; 63
    3360:	f8 94       	cli
    3362:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3364:	8e 81       	ldd	r24, Y+6	; 0x06
    3366:	9f 81       	ldd	r25, Y+7	; 0x07
    3368:	00 97       	sbiw	r24, 0x00	; 0
    336a:	39 f4       	brne	.+14     	; 0x337a <vTaskPrioritySet+0x42>
    336c:	80 91 30 07 	lds	r24, 0x0730
    3370:	90 91 31 07 	lds	r25, 0x0731
    3374:	9a 87       	std	Y+10, r25	; 0x0a
    3376:	89 87       	std	Y+9, r24	; 0x09
    3378:	04 c0       	rjmp	.+8      	; 0x3382 <vTaskPrioritySet+0x4a>
    337a:	8e 81       	ldd	r24, Y+6	; 0x06
    337c:	9f 81       	ldd	r25, Y+7	; 0x07
    337e:	9a 87       	std	Y+10, r25	; 0x0a
    3380:	89 87       	std	Y+9, r24	; 0x09
    3382:	89 85       	ldd	r24, Y+9	; 0x09
    3384:	9a 85       	ldd	r25, Y+10	; 0x0a
    3386:	9d 83       	std	Y+5, r25	; 0x05
    3388:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    338a:	ec 81       	ldd	r30, Y+4	; 0x04
    338c:	fd 81       	ldd	r31, Y+5	; 0x05
    338e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3390:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    3392:	9b 81       	ldd	r25, Y+3	; 0x03
    3394:	88 85       	ldd	r24, Y+8	; 0x08
    3396:	98 17       	cp	r25, r24
    3398:	09 f4       	brne	.+2      	; 0x339c <vTaskPrioritySet+0x64>
    339a:	8d c0       	rjmp	.+282    	; 0x34b6 <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    339c:	98 85       	ldd	r25, Y+8	; 0x08
    339e:	8b 81       	ldd	r24, Y+3	; 0x03
    33a0:	89 17       	cp	r24, r25
    33a2:	a0 f4       	brcc	.+40     	; 0x33cc <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    33a4:	20 91 30 07 	lds	r18, 0x0730
    33a8:	30 91 31 07 	lds	r19, 0x0731
    33ac:	8c 81       	ldd	r24, Y+4	; 0x04
    33ae:	9d 81       	ldd	r25, Y+5	; 0x05
    33b0:	82 17       	cp	r24, r18
    33b2:	93 07       	cpc	r25, r19
    33b4:	b1 f0       	breq	.+44     	; 0x33e2 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    33b6:	e0 91 30 07 	lds	r30, 0x0730
    33ba:	f0 91 31 07 	lds	r31, 0x0731
    33be:	96 89       	ldd	r25, Z+22	; 0x16
    33c0:	88 85       	ldd	r24, Y+8	; 0x08
    33c2:	89 17       	cp	r24, r25
    33c4:	70 f0       	brcs	.+28     	; 0x33e2 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    33c6:	81 e0       	ldi	r24, 0x01	; 1
    33c8:	89 83       	std	Y+1, r24	; 0x01
    33ca:	0b c0       	rjmp	.+22     	; 0x33e2 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    33cc:	20 91 30 07 	lds	r18, 0x0730
    33d0:	30 91 31 07 	lds	r19, 0x0731
    33d4:	8c 81       	ldd	r24, Y+4	; 0x04
    33d6:	9d 81       	ldd	r25, Y+5	; 0x05
    33d8:	82 17       	cp	r24, r18
    33da:	93 07       	cpc	r25, r19
    33dc:	11 f4       	brne	.+4      	; 0x33e2 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    33de:	81 e0       	ldi	r24, 0x01	; 1
    33e0:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    33e2:	ec 81       	ldd	r30, Y+4	; 0x04
    33e4:	fd 81       	ldd	r31, Y+5	; 0x05
    33e6:	86 89       	ldd	r24, Z+22	; 0x16
    33e8:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    33ea:	ec 81       	ldd	r30, Y+4	; 0x04
    33ec:	fd 81       	ldd	r31, Y+5	; 0x05
    33ee:	94 8d       	ldd	r25, Z+28	; 0x1c
    33f0:	ec 81       	ldd	r30, Y+4	; 0x04
    33f2:	fd 81       	ldd	r31, Y+5	; 0x05
    33f4:	86 89       	ldd	r24, Z+22	; 0x16
    33f6:	98 17       	cp	r25, r24
    33f8:	21 f4       	brne	.+8      	; 0x3402 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    33fa:	ec 81       	ldd	r30, Y+4	; 0x04
    33fc:	fd 81       	ldd	r31, Y+5	; 0x05
    33fe:	88 85       	ldd	r24, Y+8	; 0x08
    3400:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    3402:	ec 81       	ldd	r30, Y+4	; 0x04
    3404:	fd 81       	ldd	r31, Y+5	; 0x05
    3406:	88 85       	ldd	r24, Y+8	; 0x08
    3408:	84 8f       	std	Z+28, r24	; 0x1c
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    340a:	ec 81       	ldd	r30, Y+4	; 0x04
    340c:	fd 81       	ldd	r31, Y+5	; 0x05
    340e:	84 85       	ldd	r24, Z+12	; 0x0c
    3410:	95 85       	ldd	r25, Z+13	; 0x0d
    3412:	99 23       	and	r25, r25
    3414:	5c f0       	brlt	.+22     	; 0x342c <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3416:	88 85       	ldd	r24, Y+8	; 0x08
    3418:	28 2f       	mov	r18, r24
    341a:	30 e0       	ldi	r19, 0x00	; 0
    341c:	83 e0       	ldi	r24, 0x03	; 3
    341e:	90 e0       	ldi	r25, 0x00	; 0
    3420:	82 1b       	sub	r24, r18
    3422:	93 0b       	sbc	r25, r19
    3424:	ec 81       	ldd	r30, Y+4	; 0x04
    3426:	fd 81       	ldd	r31, Y+5	; 0x05
    3428:	95 87       	std	Z+13, r25	; 0x0d
    342a:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    342c:	ec 81       	ldd	r30, Y+4	; 0x04
    342e:	fd 81       	ldd	r31, Y+5	; 0x05
    3430:	42 85       	ldd	r20, Z+10	; 0x0a
    3432:	53 85       	ldd	r21, Z+11	; 0x0b
    3434:	8a 81       	ldd	r24, Y+2	; 0x02
    3436:	28 2f       	mov	r18, r24
    3438:	30 e0       	ldi	r19, 0x00	; 0
    343a:	c9 01       	movw	r24, r18
    343c:	88 0f       	add	r24, r24
    343e:	99 1f       	adc	r25, r25
    3440:	88 0f       	add	r24, r24
    3442:	99 1f       	adc	r25, r25
    3444:	88 0f       	add	r24, r24
    3446:	99 1f       	adc	r25, r25
    3448:	82 0f       	add	r24, r18
    344a:	93 1f       	adc	r25, r19
    344c:	80 5c       	subi	r24, 0xC0	; 192
    344e:	98 4f       	sbci	r25, 0xF8	; 248
    3450:	48 17       	cp	r20, r24
    3452:	59 07       	cpc	r21, r25
    3454:	59 f5       	brne	.+86     	; 0x34ac <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3456:	8c 81       	ldd	r24, Y+4	; 0x04
    3458:	9d 81       	ldd	r25, Y+5	; 0x05
    345a:	02 96       	adiw	r24, 0x02	; 2
    345c:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    3460:	ec 81       	ldd	r30, Y+4	; 0x04
    3462:	fd 81       	ldd	r31, Y+5	; 0x05
    3464:	96 89       	ldd	r25, Z+22	; 0x16
    3466:	80 91 35 07 	lds	r24, 0x0735
    346a:	89 17       	cp	r24, r25
    346c:	28 f4       	brcc	.+10     	; 0x3478 <vTaskPrioritySet+0x140>
    346e:	ec 81       	ldd	r30, Y+4	; 0x04
    3470:	fd 81       	ldd	r31, Y+5	; 0x05
    3472:	86 89       	ldd	r24, Z+22	; 0x16
    3474:	80 93 35 07 	sts	0x0735, r24
    3478:	ec 81       	ldd	r30, Y+4	; 0x04
    347a:	fd 81       	ldd	r31, Y+5	; 0x05
    347c:	86 89       	ldd	r24, Z+22	; 0x16
    347e:	28 2f       	mov	r18, r24
    3480:	30 e0       	ldi	r19, 0x00	; 0
    3482:	c9 01       	movw	r24, r18
    3484:	88 0f       	add	r24, r24
    3486:	99 1f       	adc	r25, r25
    3488:	88 0f       	add	r24, r24
    348a:	99 1f       	adc	r25, r25
    348c:	88 0f       	add	r24, r24
    348e:	99 1f       	adc	r25, r25
    3490:	82 0f       	add	r24, r18
    3492:	93 1f       	adc	r25, r19
    3494:	ac 01       	movw	r20, r24
    3496:	40 5c       	subi	r20, 0xC0	; 192
    3498:	58 4f       	sbci	r21, 0xF8	; 248
    349a:	8c 81       	ldd	r24, Y+4	; 0x04
    349c:	9d 81       	ldd	r25, Y+5	; 0x05
    349e:	9c 01       	movw	r18, r24
    34a0:	2e 5f       	subi	r18, 0xFE	; 254
    34a2:	3f 4f       	sbci	r19, 0xFF	; 255
    34a4:	ca 01       	movw	r24, r20
    34a6:	b9 01       	movw	r22, r18
    34a8:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    34ac:	89 81       	ldd	r24, Y+1	; 0x01
    34ae:	88 23       	and	r24, r24
    34b0:	11 f0       	breq	.+4      	; 0x34b6 <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    34b2:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    34b6:	0f 90       	pop	r0
    34b8:	0f be       	out	0x3f, r0	; 63
	}
    34ba:	2a 96       	adiw	r28, 0x0a	; 10
    34bc:	0f b6       	in	r0, 0x3f	; 63
    34be:	f8 94       	cli
    34c0:	de bf       	out	0x3e, r29	; 62
    34c2:	0f be       	out	0x3f, r0	; 63
    34c4:	cd bf       	out	0x3d, r28	; 61
    34c6:	cf 91       	pop	r28
    34c8:	df 91       	pop	r29
    34ca:	08 95       	ret

000034cc <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    34cc:	df 93       	push	r29
    34ce:	cf 93       	push	r28
    34d0:	00 d0       	rcall	.+0      	; 0x34d2 <vTaskSuspend+0x6>
    34d2:	00 d0       	rcall	.+0      	; 0x34d4 <vTaskSuspend+0x8>
    34d4:	00 d0       	rcall	.+0      	; 0x34d6 <vTaskSuspend+0xa>
    34d6:	cd b7       	in	r28, 0x3d	; 61
    34d8:	de b7       	in	r29, 0x3e	; 62
    34da:	9c 83       	std	Y+4, r25	; 0x04
    34dc:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    34de:	0f b6       	in	r0, 0x3f	; 63
    34e0:	f8 94       	cli
    34e2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    34e4:	8b 81       	ldd	r24, Y+3	; 0x03
    34e6:	9c 81       	ldd	r25, Y+4	; 0x04
    34e8:	00 97       	sbiw	r24, 0x00	; 0
    34ea:	39 f4       	brne	.+14     	; 0x34fa <vTaskSuspend+0x2e>
    34ec:	80 91 30 07 	lds	r24, 0x0730
    34f0:	90 91 31 07 	lds	r25, 0x0731
    34f4:	9e 83       	std	Y+6, r25	; 0x06
    34f6:	8d 83       	std	Y+5, r24	; 0x05
    34f8:	04 c0       	rjmp	.+8      	; 0x3502 <vTaskSuspend+0x36>
    34fa:	8b 81       	ldd	r24, Y+3	; 0x03
    34fc:	9c 81       	ldd	r25, Y+4	; 0x04
    34fe:	9e 83       	std	Y+6, r25	; 0x06
    3500:	8d 83       	std	Y+5, r24	; 0x05
    3502:	8d 81       	ldd	r24, Y+5	; 0x05
    3504:	9e 81       	ldd	r25, Y+6	; 0x06
    3506:	9a 83       	std	Y+2, r25	; 0x02
    3508:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    350a:	89 81       	ldd	r24, Y+1	; 0x01
    350c:	9a 81       	ldd	r25, Y+2	; 0x02
    350e:	02 96       	adiw	r24, 0x02	; 2
    3510:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3514:	e9 81       	ldd	r30, Y+1	; 0x01
    3516:	fa 81       	ldd	r31, Y+2	; 0x02
    3518:	84 89       	ldd	r24, Z+20	; 0x14
    351a:	95 89       	ldd	r25, Z+21	; 0x15
    351c:	00 97       	sbiw	r24, 0x00	; 0
    351e:	29 f0       	breq	.+10     	; 0x352a <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3520:	89 81       	ldd	r24, Y+1	; 0x01
    3522:	9a 81       	ldd	r25, Y+2	; 0x02
    3524:	0c 96       	adiw	r24, 0x0c	; 12
    3526:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    352a:	89 81       	ldd	r24, Y+1	; 0x01
    352c:	9a 81       	ldd	r25, Y+2	; 0x02
    352e:	9c 01       	movw	r18, r24
    3530:	2e 5f       	subi	r18, 0xFE	; 254
    3532:	3f 4f       	sbci	r19, 0xFF	; 255
    3534:	8a e7       	ldi	r24, 0x7A	; 122
    3536:	97 e0       	ldi	r25, 0x07	; 7
    3538:	b9 01       	movw	r22, r18
    353a:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    353e:	0f 90       	pop	r0
    3540:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3542:	80 91 36 07 	lds	r24, 0x0736
    3546:	88 23       	and	r24, r24
    3548:	39 f0       	breq	.+14     	; 0x3558 <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    354a:	0f b6       	in	r0, 0x3f	; 63
    354c:	f8 94       	cli
    354e:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3550:	0e 94 5d 20 	call	0x40ba	; 0x40ba <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3554:	0f 90       	pop	r0
    3556:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3558:	20 91 30 07 	lds	r18, 0x0730
    355c:	30 91 31 07 	lds	r19, 0x0731
    3560:	89 81       	ldd	r24, Y+1	; 0x01
    3562:	9a 81       	ldd	r25, Y+2	; 0x02
    3564:	82 17       	cp	r24, r18
    3566:	93 07       	cpc	r25, r19
    3568:	a1 f4       	brne	.+40     	; 0x3592 <vTaskSuspend+0xc6>
		{
			if( xSchedulerRunning != pdFALSE )
    356a:	80 91 36 07 	lds	r24, 0x0736
    356e:	88 23       	and	r24, r24
    3570:	19 f0       	breq	.+6      	; 0x3578 <vTaskSuspend+0xac>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3572:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
    3576:	0d c0       	rjmp	.+26     	; 0x3592 <vTaskSuspend+0xc6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    3578:	90 91 7a 07 	lds	r25, 0x077A
    357c:	80 91 32 07 	lds	r24, 0x0732
    3580:	98 17       	cp	r25, r24
    3582:	29 f4       	brne	.+10     	; 0x358e <vTaskSuspend+0xc2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3584:	10 92 31 07 	sts	0x0731, r1
    3588:	10 92 30 07 	sts	0x0730, r1
    358c:	02 c0       	rjmp	.+4      	; 0x3592 <vTaskSuspend+0xc6>
				}
				else
				{
					vTaskSwitchContext();
    358e:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3592:	26 96       	adiw	r28, 0x06	; 6
    3594:	0f b6       	in	r0, 0x3f	; 63
    3596:	f8 94       	cli
    3598:	de bf       	out	0x3e, r29	; 62
    359a:	0f be       	out	0x3f, r0	; 63
    359c:	cd bf       	out	0x3d, r28	; 61
    359e:	cf 91       	pop	r28
    35a0:	df 91       	pop	r29
    35a2:	08 95       	ret

000035a4 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    35a4:	df 93       	push	r29
    35a6:	cf 93       	push	r28
    35a8:	00 d0       	rcall	.+0      	; 0x35aa <prvTaskIsTaskSuspended+0x6>
    35aa:	00 d0       	rcall	.+0      	; 0x35ac <prvTaskIsTaskSuspended+0x8>
    35ac:	0f 92       	push	r0
    35ae:	cd b7       	in	r28, 0x3d	; 61
    35b0:	de b7       	in	r29, 0x3e	; 62
    35b2:	9d 83       	std	Y+5, r25	; 0x05
    35b4:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    35b6:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    35b8:	8c 81       	ldd	r24, Y+4	; 0x04
    35ba:	9d 81       	ldd	r25, Y+5	; 0x05
    35bc:	9a 83       	std	Y+2, r25	; 0x02
    35be:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    35c0:	e9 81       	ldd	r30, Y+1	; 0x01
    35c2:	fa 81       	ldd	r31, Y+2	; 0x02
    35c4:	82 85       	ldd	r24, Z+10	; 0x0a
    35c6:	93 85       	ldd	r25, Z+11	; 0x0b
    35c8:	27 e0       	ldi	r18, 0x07	; 7
    35ca:	8a 37       	cpi	r24, 0x7A	; 122
    35cc:	92 07       	cpc	r25, r18
    35ce:	81 f4       	brne	.+32     	; 0x35f0 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    35d0:	e9 81       	ldd	r30, Y+1	; 0x01
    35d2:	fa 81       	ldd	r31, Y+2	; 0x02
    35d4:	84 89       	ldd	r24, Z+20	; 0x14
    35d6:	95 89       	ldd	r25, Z+21	; 0x15
    35d8:	27 e0       	ldi	r18, 0x07	; 7
    35da:	81 37       	cpi	r24, 0x71	; 113
    35dc:	92 07       	cpc	r25, r18
    35de:	41 f0       	breq	.+16     	; 0x35f0 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    35e0:	e9 81       	ldd	r30, Y+1	; 0x01
    35e2:	fa 81       	ldd	r31, Y+2	; 0x02
    35e4:	84 89       	ldd	r24, Z+20	; 0x14
    35e6:	95 89       	ldd	r25, Z+21	; 0x15
    35e8:	00 97       	sbiw	r24, 0x00	; 0
    35ea:	11 f4       	brne	.+4      	; 0x35f0 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    35ec:	81 e0       	ldi	r24, 0x01	; 1
    35ee:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    35f0:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    35f2:	0f 90       	pop	r0
    35f4:	0f 90       	pop	r0
    35f6:	0f 90       	pop	r0
    35f8:	0f 90       	pop	r0
    35fa:	0f 90       	pop	r0
    35fc:	cf 91       	pop	r28
    35fe:	df 91       	pop	r29
    3600:	08 95       	ret

00003602 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3602:	df 93       	push	r29
    3604:	cf 93       	push	r28
    3606:	00 d0       	rcall	.+0      	; 0x3608 <vTaskResume+0x6>
    3608:	00 d0       	rcall	.+0      	; 0x360a <vTaskResume+0x8>
    360a:	cd b7       	in	r28, 0x3d	; 61
    360c:	de b7       	in	r29, 0x3e	; 62
    360e:	9c 83       	std	Y+4, r25	; 0x04
    3610:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    3612:	8b 81       	ldd	r24, Y+3	; 0x03
    3614:	9c 81       	ldd	r25, Y+4	; 0x04
    3616:	9a 83       	std	Y+2, r25	; 0x02
    3618:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    361a:	89 81       	ldd	r24, Y+1	; 0x01
    361c:	9a 81       	ldd	r25, Y+2	; 0x02
    361e:	00 97       	sbiw	r24, 0x00	; 0
    3620:	09 f4       	brne	.+2      	; 0x3624 <vTaskResume+0x22>
    3622:	4c c0       	rjmp	.+152    	; 0x36bc <vTaskResume+0xba>
    3624:	20 91 30 07 	lds	r18, 0x0730
    3628:	30 91 31 07 	lds	r19, 0x0731
    362c:	89 81       	ldd	r24, Y+1	; 0x01
    362e:	9a 81       	ldd	r25, Y+2	; 0x02
    3630:	82 17       	cp	r24, r18
    3632:	93 07       	cpc	r25, r19
    3634:	09 f4       	brne	.+2      	; 0x3638 <vTaskResume+0x36>
    3636:	42 c0       	rjmp	.+132    	; 0x36bc <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3638:	0f b6       	in	r0, 0x3f	; 63
    363a:	f8 94       	cli
    363c:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    363e:	89 81       	ldd	r24, Y+1	; 0x01
    3640:	9a 81       	ldd	r25, Y+2	; 0x02
    3642:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <prvTaskIsTaskSuspended>
    3646:	88 23       	and	r24, r24
    3648:	b9 f1       	breq	.+110    	; 0x36b8 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    364a:	89 81       	ldd	r24, Y+1	; 0x01
    364c:	9a 81       	ldd	r25, Y+2	; 0x02
    364e:	02 96       	adiw	r24, 0x02	; 2
    3650:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3654:	e9 81       	ldd	r30, Y+1	; 0x01
    3656:	fa 81       	ldd	r31, Y+2	; 0x02
    3658:	96 89       	ldd	r25, Z+22	; 0x16
    365a:	80 91 35 07 	lds	r24, 0x0735
    365e:	89 17       	cp	r24, r25
    3660:	28 f4       	brcc	.+10     	; 0x366c <vTaskResume+0x6a>
    3662:	e9 81       	ldd	r30, Y+1	; 0x01
    3664:	fa 81       	ldd	r31, Y+2	; 0x02
    3666:	86 89       	ldd	r24, Z+22	; 0x16
    3668:	80 93 35 07 	sts	0x0735, r24
    366c:	e9 81       	ldd	r30, Y+1	; 0x01
    366e:	fa 81       	ldd	r31, Y+2	; 0x02
    3670:	86 89       	ldd	r24, Z+22	; 0x16
    3672:	28 2f       	mov	r18, r24
    3674:	30 e0       	ldi	r19, 0x00	; 0
    3676:	c9 01       	movw	r24, r18
    3678:	88 0f       	add	r24, r24
    367a:	99 1f       	adc	r25, r25
    367c:	88 0f       	add	r24, r24
    367e:	99 1f       	adc	r25, r25
    3680:	88 0f       	add	r24, r24
    3682:	99 1f       	adc	r25, r25
    3684:	82 0f       	add	r24, r18
    3686:	93 1f       	adc	r25, r19
    3688:	ac 01       	movw	r20, r24
    368a:	40 5c       	subi	r20, 0xC0	; 192
    368c:	58 4f       	sbci	r21, 0xF8	; 248
    368e:	89 81       	ldd	r24, Y+1	; 0x01
    3690:	9a 81       	ldd	r25, Y+2	; 0x02
    3692:	9c 01       	movw	r18, r24
    3694:	2e 5f       	subi	r18, 0xFE	; 254
    3696:	3f 4f       	sbci	r19, 0xFF	; 255
    3698:	ca 01       	movw	r24, r20
    369a:	b9 01       	movw	r22, r18
    369c:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    36a0:	e9 81       	ldd	r30, Y+1	; 0x01
    36a2:	fa 81       	ldd	r31, Y+2	; 0x02
    36a4:	96 89       	ldd	r25, Z+22	; 0x16
    36a6:	e0 91 30 07 	lds	r30, 0x0730
    36aa:	f0 91 31 07 	lds	r31, 0x0731
    36ae:	86 89       	ldd	r24, Z+22	; 0x16
    36b0:	98 17       	cp	r25, r24
    36b2:	10 f0       	brcs	.+4      	; 0x36b8 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    36b4:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    36b8:	0f 90       	pop	r0
    36ba:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    36bc:	0f 90       	pop	r0
    36be:	0f 90       	pop	r0
    36c0:	0f 90       	pop	r0
    36c2:	0f 90       	pop	r0
    36c4:	cf 91       	pop	r28
    36c6:	df 91       	pop	r29
    36c8:	08 95       	ret

000036ca <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    36ca:	df 93       	push	r29
    36cc:	cf 93       	push	r28
    36ce:	00 d0       	rcall	.+0      	; 0x36d0 <xTaskResumeFromISR+0x6>
    36d0:	00 d0       	rcall	.+0      	; 0x36d2 <xTaskResumeFromISR+0x8>
    36d2:	00 d0       	rcall	.+0      	; 0x36d4 <xTaskResumeFromISR+0xa>
    36d4:	cd b7       	in	r28, 0x3d	; 61
    36d6:	de b7       	in	r29, 0x3e	; 62
    36d8:	9e 83       	std	Y+6, r25	; 0x06
    36da:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    36dc:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    36de:	8d 81       	ldd	r24, Y+5	; 0x05
    36e0:	9e 81       	ldd	r25, Y+6	; 0x06
    36e2:	9b 83       	std	Y+3, r25	; 0x03
    36e4:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    36e6:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    36e8:	8a 81       	ldd	r24, Y+2	; 0x02
    36ea:	9b 81       	ldd	r25, Y+3	; 0x03
    36ec:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <prvTaskIsTaskSuspended>
    36f0:	88 23       	and	r24, r24
    36f2:	09 f4       	brne	.+2      	; 0x36f6 <xTaskResumeFromISR+0x2c>
    36f4:	46 c0       	rjmp	.+140    	; 0x3782 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    36f6:	80 91 3f 07 	lds	r24, 0x073F
    36fa:	88 23       	and	r24, r24
    36fc:	c1 f5       	brne	.+112    	; 0x376e <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    36fe:	ea 81       	ldd	r30, Y+2	; 0x02
    3700:	fb 81       	ldd	r31, Y+3	; 0x03
    3702:	96 89       	ldd	r25, Z+22	; 0x16
    3704:	e0 91 30 07 	lds	r30, 0x0730
    3708:	f0 91 31 07 	lds	r31, 0x0731
    370c:	86 89       	ldd	r24, Z+22	; 0x16
    370e:	98 17       	cp	r25, r24
    3710:	10 f0       	brcs	.+4      	; 0x3716 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    3712:	81 e0       	ldi	r24, 0x01	; 1
    3714:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3716:	8a 81       	ldd	r24, Y+2	; 0x02
    3718:	9b 81       	ldd	r25, Y+3	; 0x03
    371a:	02 96       	adiw	r24, 0x02	; 2
    371c:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3720:	ea 81       	ldd	r30, Y+2	; 0x02
    3722:	fb 81       	ldd	r31, Y+3	; 0x03
    3724:	96 89       	ldd	r25, Z+22	; 0x16
    3726:	80 91 35 07 	lds	r24, 0x0735
    372a:	89 17       	cp	r24, r25
    372c:	28 f4       	brcc	.+10     	; 0x3738 <xTaskResumeFromISR+0x6e>
    372e:	ea 81       	ldd	r30, Y+2	; 0x02
    3730:	fb 81       	ldd	r31, Y+3	; 0x03
    3732:	86 89       	ldd	r24, Z+22	; 0x16
    3734:	80 93 35 07 	sts	0x0735, r24
    3738:	ea 81       	ldd	r30, Y+2	; 0x02
    373a:	fb 81       	ldd	r31, Y+3	; 0x03
    373c:	86 89       	ldd	r24, Z+22	; 0x16
    373e:	28 2f       	mov	r18, r24
    3740:	30 e0       	ldi	r19, 0x00	; 0
    3742:	c9 01       	movw	r24, r18
    3744:	88 0f       	add	r24, r24
    3746:	99 1f       	adc	r25, r25
    3748:	88 0f       	add	r24, r24
    374a:	99 1f       	adc	r25, r25
    374c:	88 0f       	add	r24, r24
    374e:	99 1f       	adc	r25, r25
    3750:	82 0f       	add	r24, r18
    3752:	93 1f       	adc	r25, r19
    3754:	ac 01       	movw	r20, r24
    3756:	40 5c       	subi	r20, 0xC0	; 192
    3758:	58 4f       	sbci	r21, 0xF8	; 248
    375a:	8a 81       	ldd	r24, Y+2	; 0x02
    375c:	9b 81       	ldd	r25, Y+3	; 0x03
    375e:	9c 01       	movw	r18, r24
    3760:	2e 5f       	subi	r18, 0xFE	; 254
    3762:	3f 4f       	sbci	r19, 0xFF	; 255
    3764:	ca 01       	movw	r24, r20
    3766:	b9 01       	movw	r22, r18
    3768:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
    376c:	0a c0       	rjmp	.+20     	; 0x3782 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    376e:	8a 81       	ldd	r24, Y+2	; 0x02
    3770:	9b 81       	ldd	r25, Y+3	; 0x03
    3772:	9c 01       	movw	r18, r24
    3774:	24 5f       	subi	r18, 0xF4	; 244
    3776:	3f 4f       	sbci	r19, 0xFF	; 255
    3778:	81 e7       	ldi	r24, 0x71	; 113
    377a:	97 e0       	ldi	r25, 0x07	; 7
    377c:	b9 01       	movw	r22, r18
    377e:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    3782:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    3784:	26 96       	adiw	r28, 0x06	; 6
    3786:	0f b6       	in	r0, 0x3f	; 63
    3788:	f8 94       	cli
    378a:	de bf       	out	0x3e, r29	; 62
    378c:	0f be       	out	0x3f, r0	; 63
    378e:	cd bf       	out	0x3d, r28	; 61
    3790:	cf 91       	pop	r28
    3792:	df 91       	pop	r29
    3794:	08 95       	ret

00003796 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3796:	ef 92       	push	r14
    3798:	ff 92       	push	r15
    379a:	0f 93       	push	r16
    379c:	df 93       	push	r29
    379e:	cf 93       	push	r28
    37a0:	0f 92       	push	r0
    37a2:	cd b7       	in	r28, 0x3d	; 61
    37a4:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    37a6:	89 e0       	ldi	r24, 0x09	; 9
    37a8:	90 e2       	ldi	r25, 0x20	; 32
    37aa:	20 e6       	ldi	r18, 0x60	; 96
    37ac:	30 e0       	ldi	r19, 0x00	; 0
    37ae:	ed e3       	ldi	r30, 0x3D	; 61
    37b0:	f7 e0       	ldi	r31, 0x07	; 7
    37b2:	b9 01       	movw	r22, r18
    37b4:	40 e5       	ldi	r20, 0x50	; 80
    37b6:	50 e0       	ldi	r21, 0x00	; 0
    37b8:	20 e0       	ldi	r18, 0x00	; 0
    37ba:	30 e0       	ldi	r19, 0x00	; 0
    37bc:	00 e0       	ldi	r16, 0x00	; 0
    37be:	7f 01       	movw	r14, r30
    37c0:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <xTaskCreate>
    37c4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    37c6:	89 81       	ldd	r24, Y+1	; 0x01
    37c8:	81 30       	cpi	r24, 0x01	; 1
    37ca:	81 f4       	brne	.+32     	; 0x37ec <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    37cc:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    37ce:	8f ef       	ldi	r24, 0xFF	; 255
    37d0:	9f ef       	ldi	r25, 0xFF	; 255
    37d2:	90 93 3c 07 	sts	0x073C, r25
    37d6:	80 93 3b 07 	sts	0x073B, r24
		xSchedulerRunning = pdTRUE;
    37da:	81 e0       	ldi	r24, 0x01	; 1
    37dc:	80 93 36 07 	sts	0x0736, r24
		xTickCount = ( TickType_t ) 0U;
    37e0:	10 92 34 07 	sts	0x0734, r1
    37e4:	10 92 33 07 	sts	0x0733, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    37e8:	0e 94 36 10 	call	0x206c	; 0x206c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    37ec:	0f 90       	pop	r0
    37ee:	cf 91       	pop	r28
    37f0:	df 91       	pop	r29
    37f2:	0f 91       	pop	r16
    37f4:	ff 90       	pop	r15
    37f6:	ef 90       	pop	r14
    37f8:	08 95       	ret

000037fa <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    37fa:	df 93       	push	r29
    37fc:	cf 93       	push	r28
    37fe:	cd b7       	in	r28, 0x3d	; 61
    3800:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3802:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3804:	10 92 36 07 	sts	0x0736, r1
	vPortEndScheduler();
    3808:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <vPortEndScheduler>
}
    380c:	cf 91       	pop	r28
    380e:	df 91       	pop	r29
    3810:	08 95       	ret

00003812 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3812:	df 93       	push	r29
    3814:	cf 93       	push	r28
    3816:	cd b7       	in	r28, 0x3d	; 61
    3818:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    381a:	80 91 3f 07 	lds	r24, 0x073F
    381e:	8f 5f       	subi	r24, 0xFF	; 255
    3820:	80 93 3f 07 	sts	0x073F, r24
}
    3824:	cf 91       	pop	r28
    3826:	df 91       	pop	r29
    3828:	08 95       	ret

0000382a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    382a:	df 93       	push	r29
    382c:	cf 93       	push	r28
    382e:	00 d0       	rcall	.+0      	; 0x3830 <xTaskResumeAll+0x6>
    3830:	00 d0       	rcall	.+0      	; 0x3832 <xTaskResumeAll+0x8>
    3832:	cd b7       	in	r28, 0x3d	; 61
    3834:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    3836:	1c 82       	std	Y+4, r1	; 0x04
    3838:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    383a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    383c:	0f b6       	in	r0, 0x3f	; 63
    383e:	f8 94       	cli
    3840:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3842:	80 91 3f 07 	lds	r24, 0x073F
    3846:	81 50       	subi	r24, 0x01	; 1
    3848:	80 93 3f 07 	sts	0x073F, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    384c:	80 91 3f 07 	lds	r24, 0x073F
    3850:	88 23       	and	r24, r24
    3852:	09 f0       	breq	.+2      	; 0x3856 <xTaskResumeAll+0x2c>
    3854:	73 c0       	rjmp	.+230    	; 0x393c <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3856:	80 91 32 07 	lds	r24, 0x0732
    385a:	88 23       	and	r24, r24
    385c:	09 f4       	brne	.+2      	; 0x3860 <xTaskResumeAll+0x36>
    385e:	6e c0       	rjmp	.+220    	; 0x393c <xTaskResumeAll+0x112>
    3860:	45 c0       	rjmp	.+138    	; 0x38ec <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3862:	e0 91 76 07 	lds	r30, 0x0776
    3866:	f0 91 77 07 	lds	r31, 0x0777
    386a:	86 81       	ldd	r24, Z+6	; 0x06
    386c:	97 81       	ldd	r25, Z+7	; 0x07
    386e:	9c 83       	std	Y+4, r25	; 0x04
    3870:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3872:	8b 81       	ldd	r24, Y+3	; 0x03
    3874:	9c 81       	ldd	r25, Y+4	; 0x04
    3876:	0c 96       	adiw	r24, 0x0c	; 12
    3878:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    387c:	8b 81       	ldd	r24, Y+3	; 0x03
    387e:	9c 81       	ldd	r25, Y+4	; 0x04
    3880:	02 96       	adiw	r24, 0x02	; 2
    3882:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3886:	eb 81       	ldd	r30, Y+3	; 0x03
    3888:	fc 81       	ldd	r31, Y+4	; 0x04
    388a:	96 89       	ldd	r25, Z+22	; 0x16
    388c:	80 91 35 07 	lds	r24, 0x0735
    3890:	89 17       	cp	r24, r25
    3892:	28 f4       	brcc	.+10     	; 0x389e <xTaskResumeAll+0x74>
    3894:	eb 81       	ldd	r30, Y+3	; 0x03
    3896:	fc 81       	ldd	r31, Y+4	; 0x04
    3898:	86 89       	ldd	r24, Z+22	; 0x16
    389a:	80 93 35 07 	sts	0x0735, r24
    389e:	eb 81       	ldd	r30, Y+3	; 0x03
    38a0:	fc 81       	ldd	r31, Y+4	; 0x04
    38a2:	86 89       	ldd	r24, Z+22	; 0x16
    38a4:	28 2f       	mov	r18, r24
    38a6:	30 e0       	ldi	r19, 0x00	; 0
    38a8:	c9 01       	movw	r24, r18
    38aa:	88 0f       	add	r24, r24
    38ac:	99 1f       	adc	r25, r25
    38ae:	88 0f       	add	r24, r24
    38b0:	99 1f       	adc	r25, r25
    38b2:	88 0f       	add	r24, r24
    38b4:	99 1f       	adc	r25, r25
    38b6:	82 0f       	add	r24, r18
    38b8:	93 1f       	adc	r25, r19
    38ba:	ac 01       	movw	r20, r24
    38bc:	40 5c       	subi	r20, 0xC0	; 192
    38be:	58 4f       	sbci	r21, 0xF8	; 248
    38c0:	8b 81       	ldd	r24, Y+3	; 0x03
    38c2:	9c 81       	ldd	r25, Y+4	; 0x04
    38c4:	9c 01       	movw	r18, r24
    38c6:	2e 5f       	subi	r18, 0xFE	; 254
    38c8:	3f 4f       	sbci	r19, 0xFF	; 255
    38ca:	ca 01       	movw	r24, r20
    38cc:	b9 01       	movw	r22, r18
    38ce:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    38d2:	eb 81       	ldd	r30, Y+3	; 0x03
    38d4:	fc 81       	ldd	r31, Y+4	; 0x04
    38d6:	96 89       	ldd	r25, Z+22	; 0x16
    38d8:	e0 91 30 07 	lds	r30, 0x0730
    38dc:	f0 91 31 07 	lds	r31, 0x0731
    38e0:	86 89       	ldd	r24, Z+22	; 0x16
    38e2:	98 17       	cp	r25, r24
    38e4:	18 f0       	brcs	.+6      	; 0x38ec <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    38e6:	81 e0       	ldi	r24, 0x01	; 1
    38e8:	80 93 38 07 	sts	0x0738, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    38ec:	80 91 71 07 	lds	r24, 0x0771
    38f0:	88 23       	and	r24, r24
    38f2:	09 f0       	breq	.+2      	; 0x38f6 <xTaskResumeAll+0xcc>
    38f4:	b6 cf       	rjmp	.-148    	; 0x3862 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    38f6:	8b 81       	ldd	r24, Y+3	; 0x03
    38f8:	9c 81       	ldd	r25, Y+4	; 0x04
    38fa:	00 97       	sbiw	r24, 0x00	; 0
    38fc:	11 f0       	breq	.+4      	; 0x3902 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    38fe:	0e 94 5d 20 	call	0x40ba	; 0x40ba <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    3902:	80 91 37 07 	lds	r24, 0x0737
    3906:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    3908:	89 81       	ldd	r24, Y+1	; 0x01
    390a:	88 23       	and	r24, r24
    390c:	79 f0       	breq	.+30     	; 0x392c <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    390e:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <xTaskIncrementTick>
    3912:	88 23       	and	r24, r24
    3914:	19 f0       	breq	.+6      	; 0x391c <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    3916:	81 e0       	ldi	r24, 0x01	; 1
    3918:	80 93 38 07 	sts	0x0738, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    391c:	89 81       	ldd	r24, Y+1	; 0x01
    391e:	81 50       	subi	r24, 0x01	; 1
    3920:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    3922:	89 81       	ldd	r24, Y+1	; 0x01
    3924:	88 23       	and	r24, r24
    3926:	99 f7       	brne	.-26     	; 0x390e <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    3928:	10 92 37 07 	sts	0x0737, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    392c:	80 91 38 07 	lds	r24, 0x0738
    3930:	88 23       	and	r24, r24
    3932:	21 f0       	breq	.+8      	; 0x393c <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3934:	81 e0       	ldi	r24, 0x01	; 1
    3936:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3938:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    393c:	0f 90       	pop	r0
    393e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3940:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3942:	0f 90       	pop	r0
    3944:	0f 90       	pop	r0
    3946:	0f 90       	pop	r0
    3948:	0f 90       	pop	r0
    394a:	cf 91       	pop	r28
    394c:	df 91       	pop	r29
    394e:	08 95       	ret

00003950 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3950:	df 93       	push	r29
    3952:	cf 93       	push	r28
    3954:	00 d0       	rcall	.+0      	; 0x3956 <xTaskGetTickCount+0x6>
    3956:	cd b7       	in	r28, 0x3d	; 61
    3958:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    395a:	0f b6       	in	r0, 0x3f	; 63
    395c:	f8 94       	cli
    395e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3960:	80 91 33 07 	lds	r24, 0x0733
    3964:	90 91 34 07 	lds	r25, 0x0734
    3968:	9a 83       	std	Y+2, r25	; 0x02
    396a:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    396c:	0f 90       	pop	r0
    396e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3974:	0f 90       	pop	r0
    3976:	0f 90       	pop	r0
    3978:	cf 91       	pop	r28
    397a:	df 91       	pop	r29
    397c:	08 95       	ret

0000397e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    397e:	df 93       	push	r29
    3980:	cf 93       	push	r28
    3982:	00 d0       	rcall	.+0      	; 0x3984 <xTaskGetTickCountFromISR+0x6>
    3984:	0f 92       	push	r0
    3986:	cd b7       	in	r28, 0x3d	; 61
    3988:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    398a:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    398c:	80 91 33 07 	lds	r24, 0x0733
    3990:	90 91 34 07 	lds	r25, 0x0734
    3994:	9b 83       	std	Y+3, r25	; 0x03
    3996:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3998:	8a 81       	ldd	r24, Y+2	; 0x02
    399a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    399c:	0f 90       	pop	r0
    399e:	0f 90       	pop	r0
    39a0:	0f 90       	pop	r0
    39a2:	cf 91       	pop	r28
    39a4:	df 91       	pop	r29
    39a6:	08 95       	ret

000039a8 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    39a8:	df 93       	push	r29
    39aa:	cf 93       	push	r28
    39ac:	cd b7       	in	r28, 0x3d	; 61
    39ae:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    39b0:	80 91 32 07 	lds	r24, 0x0732
}
    39b4:	cf 91       	pop	r28
    39b6:	df 91       	pop	r29
    39b8:	08 95       	ret

000039ba <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    39ba:	df 93       	push	r29
    39bc:	cf 93       	push	r28
    39be:	00 d0       	rcall	.+0      	; 0x39c0 <pcTaskGetName+0x6>
    39c0:	00 d0       	rcall	.+0      	; 0x39c2 <pcTaskGetName+0x8>
    39c2:	00 d0       	rcall	.+0      	; 0x39c4 <pcTaskGetName+0xa>
    39c4:	cd b7       	in	r28, 0x3d	; 61
    39c6:	de b7       	in	r29, 0x3e	; 62
    39c8:	9c 83       	std	Y+4, r25	; 0x04
    39ca:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    39cc:	8b 81       	ldd	r24, Y+3	; 0x03
    39ce:	9c 81       	ldd	r25, Y+4	; 0x04
    39d0:	00 97       	sbiw	r24, 0x00	; 0
    39d2:	39 f4       	brne	.+14     	; 0x39e2 <pcTaskGetName+0x28>
    39d4:	80 91 30 07 	lds	r24, 0x0730
    39d8:	90 91 31 07 	lds	r25, 0x0731
    39dc:	9e 83       	std	Y+6, r25	; 0x06
    39de:	8d 83       	std	Y+5, r24	; 0x05
    39e0:	04 c0       	rjmp	.+8      	; 0x39ea <pcTaskGetName+0x30>
    39e2:	8b 81       	ldd	r24, Y+3	; 0x03
    39e4:	9c 81       	ldd	r25, Y+4	; 0x04
    39e6:	9e 83       	std	Y+6, r25	; 0x06
    39e8:	8d 83       	std	Y+5, r24	; 0x05
    39ea:	8d 81       	ldd	r24, Y+5	; 0x05
    39ec:	9e 81       	ldd	r25, Y+6	; 0x06
    39ee:	9a 83       	std	Y+2, r25	; 0x02
    39f0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    39f2:	89 81       	ldd	r24, Y+1	; 0x01
    39f4:	9a 81       	ldd	r25, Y+2	; 0x02
    39f6:	49 96       	adiw	r24, 0x19	; 25
}
    39f8:	26 96       	adiw	r28, 0x06	; 6
    39fa:	0f b6       	in	r0, 0x3f	; 63
    39fc:	f8 94       	cli
    39fe:	de bf       	out	0x3e, r29	; 62
    3a00:	0f be       	out	0x3f, r0	; 63
    3a02:	cd bf       	out	0x3d, r28	; 61
    3a04:	cf 91       	pop	r28
    3a06:	df 91       	pop	r29
    3a08:	08 95       	ret

00003a0a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3a0a:	df 93       	push	r29
    3a0c:	cf 93       	push	r28
    3a0e:	cd b7       	in	r28, 0x3d	; 61
    3a10:	de b7       	in	r29, 0x3e	; 62
    3a12:	29 97       	sbiw	r28, 0x09	; 9
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	f8 94       	cli
    3a18:	de bf       	out	0x3e, r29	; 62
    3a1a:	0f be       	out	0x3f, r0	; 63
    3a1c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3a1e:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a20:	80 91 3f 07 	lds	r24, 0x073F
    3a24:	88 23       	and	r24, r24
    3a26:	09 f0       	breq	.+2      	; 0x3a2a <xTaskIncrementTick+0x20>
    3a28:	c0 c0       	rjmp	.+384    	; 0x3baa <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    3a2a:	80 91 33 07 	lds	r24, 0x0733
    3a2e:	90 91 34 07 	lds	r25, 0x0734
    3a32:	01 96       	adiw	r24, 0x01	; 1
    3a34:	9c 83       	std	Y+4, r25	; 0x04
    3a36:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    3a38:	8b 81       	ldd	r24, Y+3	; 0x03
    3a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a3c:	90 93 34 07 	sts	0x0734, r25
    3a40:	80 93 33 07 	sts	0x0733, r24

		if( xConstTickCount == ( TickType_t ) 0U )
    3a44:	8b 81       	ldd	r24, Y+3	; 0x03
    3a46:	9c 81       	ldd	r25, Y+4	; 0x04
    3a48:	00 97       	sbiw	r24, 0x00	; 0
    3a4a:	d9 f4       	brne	.+54     	; 0x3a82 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    3a4c:	80 91 6d 07 	lds	r24, 0x076D
    3a50:	90 91 6e 07 	lds	r25, 0x076E
    3a54:	9a 83       	std	Y+2, r25	; 0x02
    3a56:	89 83       	std	Y+1, r24	; 0x01
    3a58:	80 91 6f 07 	lds	r24, 0x076F
    3a5c:	90 91 70 07 	lds	r25, 0x0770
    3a60:	90 93 6e 07 	sts	0x076E, r25
    3a64:	80 93 6d 07 	sts	0x076D, r24
    3a68:	89 81       	ldd	r24, Y+1	; 0x01
    3a6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a6c:	90 93 70 07 	sts	0x0770, r25
    3a70:	80 93 6f 07 	sts	0x076F, r24
    3a74:	80 91 39 07 	lds	r24, 0x0739
    3a78:	8f 5f       	subi	r24, 0xFF	; 255
    3a7a:	80 93 39 07 	sts	0x0739, r24
    3a7e:	0e 94 5d 20 	call	0x40ba	; 0x40ba <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    3a82:	20 91 3b 07 	lds	r18, 0x073B
    3a86:	30 91 3c 07 	lds	r19, 0x073C
    3a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a8e:	82 17       	cp	r24, r18
    3a90:	93 07       	cpc	r25, r19
    3a92:	08 f4       	brcc	.+2      	; 0x3a96 <xTaskIncrementTick+0x8c>
    3a94:	71 c0       	rjmp	.+226    	; 0x3b78 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3a96:	e0 91 6d 07 	lds	r30, 0x076D
    3a9a:	f0 91 6e 07 	lds	r31, 0x076E
    3a9e:	80 81       	ld	r24, Z
    3aa0:	88 23       	and	r24, r24
    3aa2:	39 f4       	brne	.+14     	; 0x3ab2 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3aa4:	8f ef       	ldi	r24, 0xFF	; 255
    3aa6:	9f ef       	ldi	r25, 0xFF	; 255
    3aa8:	90 93 3c 07 	sts	0x073C, r25
    3aac:	80 93 3b 07 	sts	0x073B, r24
    3ab0:	63 c0       	rjmp	.+198    	; 0x3b78 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3ab2:	e0 91 6d 07 	lds	r30, 0x076D
    3ab6:	f0 91 6e 07 	lds	r31, 0x076E
    3aba:	05 80       	ldd	r0, Z+5	; 0x05
    3abc:	f6 81       	ldd	r31, Z+6	; 0x06
    3abe:	e0 2d       	mov	r30, r0
    3ac0:	86 81       	ldd	r24, Z+6	; 0x06
    3ac2:	97 81       	ldd	r25, Z+7	; 0x07
    3ac4:	99 87       	std	Y+9, r25	; 0x09
    3ac6:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3ac8:	e8 85       	ldd	r30, Y+8	; 0x08
    3aca:	f9 85       	ldd	r31, Y+9	; 0x09
    3acc:	82 81       	ldd	r24, Z+2	; 0x02
    3ace:	93 81       	ldd	r25, Z+3	; 0x03
    3ad0:	9f 83       	std	Y+7, r25	; 0x07
    3ad2:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    3ad4:	2b 81       	ldd	r18, Y+3	; 0x03
    3ad6:	3c 81       	ldd	r19, Y+4	; 0x04
    3ad8:	8e 81       	ldd	r24, Y+6	; 0x06
    3ada:	9f 81       	ldd	r25, Y+7	; 0x07
    3adc:	28 17       	cp	r18, r24
    3ade:	39 07       	cpc	r19, r25
    3ae0:	38 f4       	brcc	.+14     	; 0x3af0 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    3ae2:	8e 81       	ldd	r24, Y+6	; 0x06
    3ae4:	9f 81       	ldd	r25, Y+7	; 0x07
    3ae6:	90 93 3c 07 	sts	0x073C, r25
    3aea:	80 93 3b 07 	sts	0x073B, r24
    3aee:	44 c0       	rjmp	.+136    	; 0x3b78 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3af0:	88 85       	ldd	r24, Y+8	; 0x08
    3af2:	99 85       	ldd	r25, Y+9	; 0x09
    3af4:	02 96       	adiw	r24, 0x02	; 2
    3af6:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3afa:	e8 85       	ldd	r30, Y+8	; 0x08
    3afc:	f9 85       	ldd	r31, Y+9	; 0x09
    3afe:	84 89       	ldd	r24, Z+20	; 0x14
    3b00:	95 89       	ldd	r25, Z+21	; 0x15
    3b02:	00 97       	sbiw	r24, 0x00	; 0
    3b04:	29 f0       	breq	.+10     	; 0x3b10 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3b06:	88 85       	ldd	r24, Y+8	; 0x08
    3b08:	99 85       	ldd	r25, Y+9	; 0x09
    3b0a:	0c 96       	adiw	r24, 0x0c	; 12
    3b0c:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3b10:	e8 85       	ldd	r30, Y+8	; 0x08
    3b12:	f9 85       	ldd	r31, Y+9	; 0x09
    3b14:	96 89       	ldd	r25, Z+22	; 0x16
    3b16:	80 91 35 07 	lds	r24, 0x0735
    3b1a:	89 17       	cp	r24, r25
    3b1c:	28 f4       	brcc	.+10     	; 0x3b28 <xTaskIncrementTick+0x11e>
    3b1e:	e8 85       	ldd	r30, Y+8	; 0x08
    3b20:	f9 85       	ldd	r31, Y+9	; 0x09
    3b22:	86 89       	ldd	r24, Z+22	; 0x16
    3b24:	80 93 35 07 	sts	0x0735, r24
    3b28:	e8 85       	ldd	r30, Y+8	; 0x08
    3b2a:	f9 85       	ldd	r31, Y+9	; 0x09
    3b2c:	86 89       	ldd	r24, Z+22	; 0x16
    3b2e:	28 2f       	mov	r18, r24
    3b30:	30 e0       	ldi	r19, 0x00	; 0
    3b32:	c9 01       	movw	r24, r18
    3b34:	88 0f       	add	r24, r24
    3b36:	99 1f       	adc	r25, r25
    3b38:	88 0f       	add	r24, r24
    3b3a:	99 1f       	adc	r25, r25
    3b3c:	88 0f       	add	r24, r24
    3b3e:	99 1f       	adc	r25, r25
    3b40:	82 0f       	add	r24, r18
    3b42:	93 1f       	adc	r25, r19
    3b44:	ac 01       	movw	r20, r24
    3b46:	40 5c       	subi	r20, 0xC0	; 192
    3b48:	58 4f       	sbci	r21, 0xF8	; 248
    3b4a:	88 85       	ldd	r24, Y+8	; 0x08
    3b4c:	99 85       	ldd	r25, Y+9	; 0x09
    3b4e:	9c 01       	movw	r18, r24
    3b50:	2e 5f       	subi	r18, 0xFE	; 254
    3b52:	3f 4f       	sbci	r19, 0xFF	; 255
    3b54:	ca 01       	movw	r24, r20
    3b56:	b9 01       	movw	r22, r18
    3b58:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3b5c:	e8 85       	ldd	r30, Y+8	; 0x08
    3b5e:	f9 85       	ldd	r31, Y+9	; 0x09
    3b60:	96 89       	ldd	r25, Z+22	; 0x16
    3b62:	e0 91 30 07 	lds	r30, 0x0730
    3b66:	f0 91 31 07 	lds	r31, 0x0731
    3b6a:	86 89       	ldd	r24, Z+22	; 0x16
    3b6c:	98 17       	cp	r25, r24
    3b6e:	08 f4       	brcc	.+2      	; 0x3b72 <xTaskIncrementTick+0x168>
    3b70:	92 cf       	rjmp	.-220    	; 0x3a96 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    3b72:	81 e0       	ldi	r24, 0x01	; 1
    3b74:	8d 83       	std	Y+5, r24	; 0x05
    3b76:	8f cf       	rjmp	.-226    	; 0x3a96 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3b78:	e0 91 30 07 	lds	r30, 0x0730
    3b7c:	f0 91 31 07 	lds	r31, 0x0731
    3b80:	86 89       	ldd	r24, Z+22	; 0x16
    3b82:	28 2f       	mov	r18, r24
    3b84:	30 e0       	ldi	r19, 0x00	; 0
    3b86:	c9 01       	movw	r24, r18
    3b88:	88 0f       	add	r24, r24
    3b8a:	99 1f       	adc	r25, r25
    3b8c:	88 0f       	add	r24, r24
    3b8e:	99 1f       	adc	r25, r25
    3b90:	88 0f       	add	r24, r24
    3b92:	99 1f       	adc	r25, r25
    3b94:	82 0f       	add	r24, r18
    3b96:	93 1f       	adc	r25, r19
    3b98:	fc 01       	movw	r30, r24
    3b9a:	e0 5c       	subi	r30, 0xC0	; 192
    3b9c:	f8 4f       	sbci	r31, 0xF8	; 248
    3b9e:	80 81       	ld	r24, Z
    3ba0:	82 30       	cpi	r24, 0x02	; 2
    3ba2:	40 f0       	brcs	.+16     	; 0x3bb4 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    3ba4:	81 e0       	ldi	r24, 0x01	; 1
    3ba6:	8d 83       	std	Y+5, r24	; 0x05
    3ba8:	05 c0       	rjmp	.+10     	; 0x3bb4 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3baa:	80 91 37 07 	lds	r24, 0x0737
    3bae:	8f 5f       	subi	r24, 0xFF	; 255
    3bb0:	80 93 37 07 	sts	0x0737, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3bb4:	80 91 38 07 	lds	r24, 0x0738
    3bb8:	88 23       	and	r24, r24
    3bba:	11 f0       	breq	.+4      	; 0x3bc0 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    3bbc:	81 e0       	ldi	r24, 0x01	; 1
    3bbe:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3bc0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3bc2:	29 96       	adiw	r28, 0x09	; 9
    3bc4:	0f b6       	in	r0, 0x3f	; 63
    3bc6:	f8 94       	cli
    3bc8:	de bf       	out	0x3e, r29	; 62
    3bca:	0f be       	out	0x3f, r0	; 63
    3bcc:	cd bf       	out	0x3d, r28	; 61
    3bce:	cf 91       	pop	r28
    3bd0:	df 91       	pop	r29
    3bd2:	08 95       	ret

00003bd4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3bd4:	df 93       	push	r29
    3bd6:	cf 93       	push	r28
    3bd8:	00 d0       	rcall	.+0      	; 0x3bda <vTaskSwitchContext+0x6>
    3bda:	0f 92       	push	r0
    3bdc:	cd b7       	in	r28, 0x3d	; 61
    3bde:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3be0:	80 91 3f 07 	lds	r24, 0x073F
    3be4:	88 23       	and	r24, r24
    3be6:	21 f0       	breq	.+8      	; 0x3bf0 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3be8:	81 e0       	ldi	r24, 0x01	; 1
    3bea:	80 93 38 07 	sts	0x0738, r24
    3bee:	59 c0       	rjmp	.+178    	; 0x3ca2 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3bf0:	10 92 38 07 	sts	0x0738, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3bf4:	80 91 35 07 	lds	r24, 0x0735
    3bf8:	8b 83       	std	Y+3, r24	; 0x03
    3bfa:	03 c0       	rjmp	.+6      	; 0x3c02 <vTaskSwitchContext+0x2e>
    3bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    3bfe:	81 50       	subi	r24, 0x01	; 1
    3c00:	8b 83       	std	Y+3, r24	; 0x03
    3c02:	8b 81       	ldd	r24, Y+3	; 0x03
    3c04:	28 2f       	mov	r18, r24
    3c06:	30 e0       	ldi	r19, 0x00	; 0
    3c08:	c9 01       	movw	r24, r18
    3c0a:	88 0f       	add	r24, r24
    3c0c:	99 1f       	adc	r25, r25
    3c0e:	88 0f       	add	r24, r24
    3c10:	99 1f       	adc	r25, r25
    3c12:	88 0f       	add	r24, r24
    3c14:	99 1f       	adc	r25, r25
    3c16:	82 0f       	add	r24, r18
    3c18:	93 1f       	adc	r25, r19
    3c1a:	fc 01       	movw	r30, r24
    3c1c:	e0 5c       	subi	r30, 0xC0	; 192
    3c1e:	f8 4f       	sbci	r31, 0xF8	; 248
    3c20:	80 81       	ld	r24, Z
    3c22:	88 23       	and	r24, r24
    3c24:	59 f3       	breq	.-42     	; 0x3bfc <vTaskSwitchContext+0x28>
    3c26:	8b 81       	ldd	r24, Y+3	; 0x03
    3c28:	28 2f       	mov	r18, r24
    3c2a:	30 e0       	ldi	r19, 0x00	; 0
    3c2c:	c9 01       	movw	r24, r18
    3c2e:	88 0f       	add	r24, r24
    3c30:	99 1f       	adc	r25, r25
    3c32:	88 0f       	add	r24, r24
    3c34:	99 1f       	adc	r25, r25
    3c36:	88 0f       	add	r24, r24
    3c38:	99 1f       	adc	r25, r25
    3c3a:	82 0f       	add	r24, r18
    3c3c:	93 1f       	adc	r25, r19
    3c3e:	80 5c       	subi	r24, 0xC0	; 192
    3c40:	98 4f       	sbci	r25, 0xF8	; 248
    3c42:	9a 83       	std	Y+2, r25	; 0x02
    3c44:	89 83       	std	Y+1, r24	; 0x01
    3c46:	e9 81       	ldd	r30, Y+1	; 0x01
    3c48:	fa 81       	ldd	r31, Y+2	; 0x02
    3c4a:	01 80       	ldd	r0, Z+1	; 0x01
    3c4c:	f2 81       	ldd	r31, Z+2	; 0x02
    3c4e:	e0 2d       	mov	r30, r0
    3c50:	82 81       	ldd	r24, Z+2	; 0x02
    3c52:	93 81       	ldd	r25, Z+3	; 0x03
    3c54:	e9 81       	ldd	r30, Y+1	; 0x01
    3c56:	fa 81       	ldd	r31, Y+2	; 0x02
    3c58:	92 83       	std	Z+2, r25	; 0x02
    3c5a:	81 83       	std	Z+1, r24	; 0x01
    3c5c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c5e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c60:	21 81       	ldd	r18, Z+1	; 0x01
    3c62:	32 81       	ldd	r19, Z+2	; 0x02
    3c64:	89 81       	ldd	r24, Y+1	; 0x01
    3c66:	9a 81       	ldd	r25, Y+2	; 0x02
    3c68:	03 96       	adiw	r24, 0x03	; 3
    3c6a:	28 17       	cp	r18, r24
    3c6c:	39 07       	cpc	r19, r25
    3c6e:	59 f4       	brne	.+22     	; 0x3c86 <vTaskSwitchContext+0xb2>
    3c70:	e9 81       	ldd	r30, Y+1	; 0x01
    3c72:	fa 81       	ldd	r31, Y+2	; 0x02
    3c74:	01 80       	ldd	r0, Z+1	; 0x01
    3c76:	f2 81       	ldd	r31, Z+2	; 0x02
    3c78:	e0 2d       	mov	r30, r0
    3c7a:	82 81       	ldd	r24, Z+2	; 0x02
    3c7c:	93 81       	ldd	r25, Z+3	; 0x03
    3c7e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c80:	fa 81       	ldd	r31, Y+2	; 0x02
    3c82:	92 83       	std	Z+2, r25	; 0x02
    3c84:	81 83       	std	Z+1, r24	; 0x01
    3c86:	e9 81       	ldd	r30, Y+1	; 0x01
    3c88:	fa 81       	ldd	r31, Y+2	; 0x02
    3c8a:	01 80       	ldd	r0, Z+1	; 0x01
    3c8c:	f2 81       	ldd	r31, Z+2	; 0x02
    3c8e:	e0 2d       	mov	r30, r0
    3c90:	86 81       	ldd	r24, Z+6	; 0x06
    3c92:	97 81       	ldd	r25, Z+7	; 0x07
    3c94:	90 93 31 07 	sts	0x0731, r25
    3c98:	80 93 30 07 	sts	0x0730, r24
    3c9c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c9e:	80 93 35 07 	sts	0x0735, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3ca2:	0f 90       	pop	r0
    3ca4:	0f 90       	pop	r0
    3ca6:	0f 90       	pop	r0
    3ca8:	cf 91       	pop	r28
    3caa:	df 91       	pop	r29
    3cac:	08 95       	ret

00003cae <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3cae:	df 93       	push	r29
    3cb0:	cf 93       	push	r28
    3cb2:	00 d0       	rcall	.+0      	; 0x3cb4 <vTaskPlaceOnEventList+0x6>
    3cb4:	00 d0       	rcall	.+0      	; 0x3cb6 <vTaskPlaceOnEventList+0x8>
    3cb6:	cd b7       	in	r28, 0x3d	; 61
    3cb8:	de b7       	in	r29, 0x3e	; 62
    3cba:	9a 83       	std	Y+2, r25	; 0x02
    3cbc:	89 83       	std	Y+1, r24	; 0x01
    3cbe:	7c 83       	std	Y+4, r23	; 0x04
    3cc0:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3cc2:	80 91 30 07 	lds	r24, 0x0730
    3cc6:	90 91 31 07 	lds	r25, 0x0731
    3cca:	9c 01       	movw	r18, r24
    3ccc:	24 5f       	subi	r18, 0xF4	; 244
    3cce:	3f 4f       	sbci	r19, 0xFF	; 255
    3cd0:	89 81       	ldd	r24, Y+1	; 0x01
    3cd2:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd4:	b9 01       	movw	r22, r18
    3cd6:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3cda:	8b 81       	ldd	r24, Y+3	; 0x03
    3cdc:	9c 81       	ldd	r25, Y+4	; 0x04
    3cde:	61 e0       	ldi	r22, 0x01	; 1
    3ce0:	0e 94 80 25 	call	0x4b00	; 0x4b00 <prvAddCurrentTaskToDelayedList>
}
    3ce4:	0f 90       	pop	r0
    3ce6:	0f 90       	pop	r0
    3ce8:	0f 90       	pop	r0
    3cea:	0f 90       	pop	r0
    3cec:	cf 91       	pop	r28
    3cee:	df 91       	pop	r29
    3cf0:	08 95       	ret

00003cf2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3cf2:	df 93       	push	r29
    3cf4:	cf 93       	push	r28
    3cf6:	00 d0       	rcall	.+0      	; 0x3cf8 <vTaskPlaceOnUnorderedEventList+0x6>
    3cf8:	00 d0       	rcall	.+0      	; 0x3cfa <vTaskPlaceOnUnorderedEventList+0x8>
    3cfa:	00 d0       	rcall	.+0      	; 0x3cfc <vTaskPlaceOnUnorderedEventList+0xa>
    3cfc:	cd b7       	in	r28, 0x3d	; 61
    3cfe:	de b7       	in	r29, 0x3e	; 62
    3d00:	9a 83       	std	Y+2, r25	; 0x02
    3d02:	89 83       	std	Y+1, r24	; 0x01
    3d04:	7c 83       	std	Y+4, r23	; 0x04
    3d06:	6b 83       	std	Y+3, r22	; 0x03
    3d08:	5e 83       	std	Y+6, r21	; 0x06
    3d0a:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3d0c:	e0 91 30 07 	lds	r30, 0x0730
    3d10:	f0 91 31 07 	lds	r31, 0x0731
    3d14:	8b 81       	ldd	r24, Y+3	; 0x03
    3d16:	9c 81       	ldd	r25, Y+4	; 0x04
    3d18:	90 68       	ori	r25, 0x80	; 128
    3d1a:	95 87       	std	Z+13, r25	; 0x0d
    3d1c:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3d1e:	80 91 30 07 	lds	r24, 0x0730
    3d22:	90 91 31 07 	lds	r25, 0x0731
    3d26:	9c 01       	movw	r18, r24
    3d28:	24 5f       	subi	r18, 0xF4	; 244
    3d2a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d2c:	89 81       	ldd	r24, Y+1	; 0x01
    3d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d30:	b9 01       	movw	r22, r18
    3d32:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3d36:	8d 81       	ldd	r24, Y+5	; 0x05
    3d38:	9e 81       	ldd	r25, Y+6	; 0x06
    3d3a:	61 e0       	ldi	r22, 0x01	; 1
    3d3c:	0e 94 80 25 	call	0x4b00	; 0x4b00 <prvAddCurrentTaskToDelayedList>
}
    3d40:	26 96       	adiw	r28, 0x06	; 6
    3d42:	0f b6       	in	r0, 0x3f	; 63
    3d44:	f8 94       	cli
    3d46:	de bf       	out	0x3e, r29	; 62
    3d48:	0f be       	out	0x3f, r0	; 63
    3d4a:	cd bf       	out	0x3d, r28	; 61
    3d4c:	cf 91       	pop	r28
    3d4e:	df 91       	pop	r29
    3d50:	08 95       	ret

00003d52 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3d52:	df 93       	push	r29
    3d54:	cf 93       	push	r28
    3d56:	00 d0       	rcall	.+0      	; 0x3d58 <xTaskRemoveFromEventList+0x6>
    3d58:	00 d0       	rcall	.+0      	; 0x3d5a <xTaskRemoveFromEventList+0x8>
    3d5a:	0f 92       	push	r0
    3d5c:	cd b7       	in	r28, 0x3d	; 61
    3d5e:	de b7       	in	r29, 0x3e	; 62
    3d60:	9d 83       	std	Y+5, r25	; 0x05
    3d62:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3d64:	ec 81       	ldd	r30, Y+4	; 0x04
    3d66:	fd 81       	ldd	r31, Y+5	; 0x05
    3d68:	05 80       	ldd	r0, Z+5	; 0x05
    3d6a:	f6 81       	ldd	r31, Z+6	; 0x06
    3d6c:	e0 2d       	mov	r30, r0
    3d6e:	86 81       	ldd	r24, Z+6	; 0x06
    3d70:	97 81       	ldd	r25, Z+7	; 0x07
    3d72:	9b 83       	std	Y+3, r25	; 0x03
    3d74:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3d76:	8a 81       	ldd	r24, Y+2	; 0x02
    3d78:	9b 81       	ldd	r25, Y+3	; 0x03
    3d7a:	0c 96       	adiw	r24, 0x0c	; 12
    3d7c:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d80:	80 91 3f 07 	lds	r24, 0x073F
    3d84:	88 23       	and	r24, r24
    3d86:	61 f5       	brne	.+88     	; 0x3de0 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3d88:	8a 81       	ldd	r24, Y+2	; 0x02
    3d8a:	9b 81       	ldd	r25, Y+3	; 0x03
    3d8c:	02 96       	adiw	r24, 0x02	; 2
    3d8e:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3d92:	ea 81       	ldd	r30, Y+2	; 0x02
    3d94:	fb 81       	ldd	r31, Y+3	; 0x03
    3d96:	96 89       	ldd	r25, Z+22	; 0x16
    3d98:	80 91 35 07 	lds	r24, 0x0735
    3d9c:	89 17       	cp	r24, r25
    3d9e:	28 f4       	brcc	.+10     	; 0x3daa <xTaskRemoveFromEventList+0x58>
    3da0:	ea 81       	ldd	r30, Y+2	; 0x02
    3da2:	fb 81       	ldd	r31, Y+3	; 0x03
    3da4:	86 89       	ldd	r24, Z+22	; 0x16
    3da6:	80 93 35 07 	sts	0x0735, r24
    3daa:	ea 81       	ldd	r30, Y+2	; 0x02
    3dac:	fb 81       	ldd	r31, Y+3	; 0x03
    3dae:	86 89       	ldd	r24, Z+22	; 0x16
    3db0:	28 2f       	mov	r18, r24
    3db2:	30 e0       	ldi	r19, 0x00	; 0
    3db4:	c9 01       	movw	r24, r18
    3db6:	88 0f       	add	r24, r24
    3db8:	99 1f       	adc	r25, r25
    3dba:	88 0f       	add	r24, r24
    3dbc:	99 1f       	adc	r25, r25
    3dbe:	88 0f       	add	r24, r24
    3dc0:	99 1f       	adc	r25, r25
    3dc2:	82 0f       	add	r24, r18
    3dc4:	93 1f       	adc	r25, r19
    3dc6:	ac 01       	movw	r20, r24
    3dc8:	40 5c       	subi	r20, 0xC0	; 192
    3dca:	58 4f       	sbci	r21, 0xF8	; 248
    3dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    3dce:	9b 81       	ldd	r25, Y+3	; 0x03
    3dd0:	9c 01       	movw	r18, r24
    3dd2:	2e 5f       	subi	r18, 0xFE	; 254
    3dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    3dd6:	ca 01       	movw	r24, r20
    3dd8:	b9 01       	movw	r22, r18
    3dda:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
    3dde:	0a c0       	rjmp	.+20     	; 0x3df4 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3de0:	8a 81       	ldd	r24, Y+2	; 0x02
    3de2:	9b 81       	ldd	r25, Y+3	; 0x03
    3de4:	9c 01       	movw	r18, r24
    3de6:	24 5f       	subi	r18, 0xF4	; 244
    3de8:	3f 4f       	sbci	r19, 0xFF	; 255
    3dea:	81 e7       	ldi	r24, 0x71	; 113
    3dec:	97 e0       	ldi	r25, 0x07	; 7
    3dee:	b9 01       	movw	r22, r18
    3df0:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3df4:	ea 81       	ldd	r30, Y+2	; 0x02
    3df6:	fb 81       	ldd	r31, Y+3	; 0x03
    3df8:	96 89       	ldd	r25, Z+22	; 0x16
    3dfa:	e0 91 30 07 	lds	r30, 0x0730
    3dfe:	f0 91 31 07 	lds	r31, 0x0731
    3e02:	86 89       	ldd	r24, Z+22	; 0x16
    3e04:	89 17       	cp	r24, r25
    3e06:	30 f4       	brcc	.+12     	; 0x3e14 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3e08:	81 e0       	ldi	r24, 0x01	; 1
    3e0a:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3e0c:	81 e0       	ldi	r24, 0x01	; 1
    3e0e:	80 93 38 07 	sts	0x0738, r24
    3e12:	01 c0       	rjmp	.+2      	; 0x3e16 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3e14:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    3e16:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e18:	0f 90       	pop	r0
    3e1a:	0f 90       	pop	r0
    3e1c:	0f 90       	pop	r0
    3e1e:	0f 90       	pop	r0
    3e20:	0f 90       	pop	r0
    3e22:	cf 91       	pop	r28
    3e24:	df 91       	pop	r29
    3e26:	08 95       	ret

00003e28 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3e28:	df 93       	push	r29
    3e2a:	cf 93       	push	r28
    3e2c:	cd b7       	in	r28, 0x3d	; 61
    3e2e:	de b7       	in	r29, 0x3e	; 62
    3e30:	27 97       	sbiw	r28, 0x07	; 7
    3e32:	0f b6       	in	r0, 0x3f	; 63
    3e34:	f8 94       	cli
    3e36:	de bf       	out	0x3e, r29	; 62
    3e38:	0f be       	out	0x3f, r0	; 63
    3e3a:	cd bf       	out	0x3d, r28	; 61
    3e3c:	9d 83       	std	Y+5, r25	; 0x05
    3e3e:	8c 83       	std	Y+4, r24	; 0x04
    3e40:	7f 83       	std	Y+7, r23	; 0x07
    3e42:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3e44:	8e 81       	ldd	r24, Y+6	; 0x06
    3e46:	9f 81       	ldd	r25, Y+7	; 0x07
    3e48:	90 68       	ori	r25, 0x80	; 128
    3e4a:	ec 81       	ldd	r30, Y+4	; 0x04
    3e4c:	fd 81       	ldd	r31, Y+5	; 0x05
    3e4e:	91 83       	std	Z+1, r25	; 0x01
    3e50:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    3e52:	ec 81       	ldd	r30, Y+4	; 0x04
    3e54:	fd 81       	ldd	r31, Y+5	; 0x05
    3e56:	86 81       	ldd	r24, Z+6	; 0x06
    3e58:	97 81       	ldd	r25, Z+7	; 0x07
    3e5a:	9b 83       	std	Y+3, r25	; 0x03
    3e5c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3e5e:	8c 81       	ldd	r24, Y+4	; 0x04
    3e60:	9d 81       	ldd	r25, Y+5	; 0x05
    3e62:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3e66:	8a 81       	ldd	r24, Y+2	; 0x02
    3e68:	9b 81       	ldd	r25, Y+3	; 0x03
    3e6a:	02 96       	adiw	r24, 0x02	; 2
    3e6c:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3e70:	ea 81       	ldd	r30, Y+2	; 0x02
    3e72:	fb 81       	ldd	r31, Y+3	; 0x03
    3e74:	96 89       	ldd	r25, Z+22	; 0x16
    3e76:	80 91 35 07 	lds	r24, 0x0735
    3e7a:	89 17       	cp	r24, r25
    3e7c:	28 f4       	brcc	.+10     	; 0x3e88 <xTaskRemoveFromUnorderedEventList+0x60>
    3e7e:	ea 81       	ldd	r30, Y+2	; 0x02
    3e80:	fb 81       	ldd	r31, Y+3	; 0x03
    3e82:	86 89       	ldd	r24, Z+22	; 0x16
    3e84:	80 93 35 07 	sts	0x0735, r24
    3e88:	ea 81       	ldd	r30, Y+2	; 0x02
    3e8a:	fb 81       	ldd	r31, Y+3	; 0x03
    3e8c:	86 89       	ldd	r24, Z+22	; 0x16
    3e8e:	28 2f       	mov	r18, r24
    3e90:	30 e0       	ldi	r19, 0x00	; 0
    3e92:	c9 01       	movw	r24, r18
    3e94:	88 0f       	add	r24, r24
    3e96:	99 1f       	adc	r25, r25
    3e98:	88 0f       	add	r24, r24
    3e9a:	99 1f       	adc	r25, r25
    3e9c:	88 0f       	add	r24, r24
    3e9e:	99 1f       	adc	r25, r25
    3ea0:	82 0f       	add	r24, r18
    3ea2:	93 1f       	adc	r25, r19
    3ea4:	ac 01       	movw	r20, r24
    3ea6:	40 5c       	subi	r20, 0xC0	; 192
    3ea8:	58 4f       	sbci	r21, 0xF8	; 248
    3eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    3eac:	9b 81       	ldd	r25, Y+3	; 0x03
    3eae:	9c 01       	movw	r18, r24
    3eb0:	2e 5f       	subi	r18, 0xFE	; 254
    3eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    3eb4:	ca 01       	movw	r24, r20
    3eb6:	b9 01       	movw	r22, r18
    3eb8:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3ebc:	ea 81       	ldd	r30, Y+2	; 0x02
    3ebe:	fb 81       	ldd	r31, Y+3	; 0x03
    3ec0:	96 89       	ldd	r25, Z+22	; 0x16
    3ec2:	e0 91 30 07 	lds	r30, 0x0730
    3ec6:	f0 91 31 07 	lds	r31, 0x0731
    3eca:	86 89       	ldd	r24, Z+22	; 0x16
    3ecc:	89 17       	cp	r24, r25
    3ece:	30 f4       	brcc	.+12     	; 0x3edc <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3ed0:	81 e0       	ldi	r24, 0x01	; 1
    3ed2:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3ed4:	81 e0       	ldi	r24, 0x01	; 1
    3ed6:	80 93 38 07 	sts	0x0738, r24
    3eda:	01 c0       	rjmp	.+2      	; 0x3ede <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    3edc:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3ede:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ee0:	27 96       	adiw	r28, 0x07	; 7
    3ee2:	0f b6       	in	r0, 0x3f	; 63
    3ee4:	f8 94       	cli
    3ee6:	de bf       	out	0x3e, r29	; 62
    3ee8:	0f be       	out	0x3f, r0	; 63
    3eea:	cd bf       	out	0x3d, r28	; 61
    3eec:	cf 91       	pop	r28
    3eee:	df 91       	pop	r29
    3ef0:	08 95       	ret

00003ef2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3ef2:	df 93       	push	r29
    3ef4:	cf 93       	push	r28
    3ef6:	00 d0       	rcall	.+0      	; 0x3ef8 <vTaskSetTimeOutState+0x6>
    3ef8:	cd b7       	in	r28, 0x3d	; 61
    3efa:	de b7       	in	r29, 0x3e	; 62
    3efc:	9a 83       	std	Y+2, r25	; 0x02
    3efe:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3f00:	80 91 39 07 	lds	r24, 0x0739
    3f04:	e9 81       	ldd	r30, Y+1	; 0x01
    3f06:	fa 81       	ldd	r31, Y+2	; 0x02
    3f08:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3f0a:	80 91 33 07 	lds	r24, 0x0733
    3f0e:	90 91 34 07 	lds	r25, 0x0734
    3f12:	e9 81       	ldd	r30, Y+1	; 0x01
    3f14:	fa 81       	ldd	r31, Y+2	; 0x02
    3f16:	92 83       	std	Z+2, r25	; 0x02
    3f18:	81 83       	std	Z+1, r24	; 0x01
}
    3f1a:	0f 90       	pop	r0
    3f1c:	0f 90       	pop	r0
    3f1e:	cf 91       	pop	r28
    3f20:	df 91       	pop	r29
    3f22:	08 95       	ret

00003f24 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3f24:	df 93       	push	r29
    3f26:	cf 93       	push	r28
    3f28:	cd b7       	in	r28, 0x3d	; 61
    3f2a:	de b7       	in	r29, 0x3e	; 62
    3f2c:	27 97       	sbiw	r28, 0x07	; 7
    3f2e:	0f b6       	in	r0, 0x3f	; 63
    3f30:	f8 94       	cli
    3f32:	de bf       	out	0x3e, r29	; 62
    3f34:	0f be       	out	0x3f, r0	; 63
    3f36:	cd bf       	out	0x3d, r28	; 61
    3f38:	9d 83       	std	Y+5, r25	; 0x05
    3f3a:	8c 83       	std	Y+4, r24	; 0x04
    3f3c:	7f 83       	std	Y+7, r23	; 0x07
    3f3e:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3f40:	0f b6       	in	r0, 0x3f	; 63
    3f42:	f8 94       	cli
    3f44:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3f46:	80 91 33 07 	lds	r24, 0x0733
    3f4a:	90 91 34 07 	lds	r25, 0x0734
    3f4e:	9a 83       	std	Y+2, r25	; 0x02
    3f50:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3f52:	ee 81       	ldd	r30, Y+6	; 0x06
    3f54:	ff 81       	ldd	r31, Y+7	; 0x07
    3f56:	80 81       	ld	r24, Z
    3f58:	91 81       	ldd	r25, Z+1	; 0x01
    3f5a:	2f ef       	ldi	r18, 0xFF	; 255
    3f5c:	8f 3f       	cpi	r24, 0xFF	; 255
    3f5e:	92 07       	cpc	r25, r18
    3f60:	11 f4       	brne	.+4      	; 0x3f66 <xTaskCheckForTimeOut+0x42>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3f62:	1b 82       	std	Y+3, r1	; 0x03
    3f64:	40 c0       	rjmp	.+128    	; 0x3fe6 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3f66:	ec 81       	ldd	r30, Y+4	; 0x04
    3f68:	fd 81       	ldd	r31, Y+5	; 0x05
    3f6a:	90 81       	ld	r25, Z
    3f6c:	80 91 39 07 	lds	r24, 0x0739
    3f70:	98 17       	cp	r25, r24
    3f72:	61 f0       	breq	.+24     	; 0x3f8c <xTaskCheckForTimeOut+0x68>
    3f74:	ec 81       	ldd	r30, Y+4	; 0x04
    3f76:	fd 81       	ldd	r31, Y+5	; 0x05
    3f78:	21 81       	ldd	r18, Z+1	; 0x01
    3f7a:	32 81       	ldd	r19, Z+2	; 0x02
    3f7c:	89 81       	ldd	r24, Y+1	; 0x01
    3f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f80:	82 17       	cp	r24, r18
    3f82:	93 07       	cpc	r25, r19
    3f84:	18 f0       	brcs	.+6      	; 0x3f8c <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3f86:	81 e0       	ldi	r24, 0x01	; 1
    3f88:	8b 83       	std	Y+3, r24	; 0x03
    3f8a:	2d c0       	rjmp	.+90     	; 0x3fe6 <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3f8c:	ec 81       	ldd	r30, Y+4	; 0x04
    3f8e:	fd 81       	ldd	r31, Y+5	; 0x05
    3f90:	21 81       	ldd	r18, Z+1	; 0x01
    3f92:	32 81       	ldd	r19, Z+2	; 0x02
    3f94:	89 81       	ldd	r24, Y+1	; 0x01
    3f96:	9a 81       	ldd	r25, Y+2	; 0x02
    3f98:	ac 01       	movw	r20, r24
    3f9a:	42 1b       	sub	r20, r18
    3f9c:	53 0b       	sbc	r21, r19
    3f9e:	9a 01       	movw	r18, r20
    3fa0:	ee 81       	ldd	r30, Y+6	; 0x06
    3fa2:	ff 81       	ldd	r31, Y+7	; 0x07
    3fa4:	80 81       	ld	r24, Z
    3fa6:	91 81       	ldd	r25, Z+1	; 0x01
    3fa8:	28 17       	cp	r18, r24
    3faa:	39 07       	cpc	r19, r25
    3fac:	d0 f4       	brcc	.+52     	; 0x3fe2 <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    3fae:	ee 81       	ldd	r30, Y+6	; 0x06
    3fb0:	ff 81       	ldd	r31, Y+7	; 0x07
    3fb2:	40 81       	ld	r20, Z
    3fb4:	51 81       	ldd	r21, Z+1	; 0x01
    3fb6:	ec 81       	ldd	r30, Y+4	; 0x04
    3fb8:	fd 81       	ldd	r31, Y+5	; 0x05
    3fba:	21 81       	ldd	r18, Z+1	; 0x01
    3fbc:	32 81       	ldd	r19, Z+2	; 0x02
    3fbe:	89 81       	ldd	r24, Y+1	; 0x01
    3fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fc2:	b9 01       	movw	r22, r18
    3fc4:	68 1b       	sub	r22, r24
    3fc6:	79 0b       	sbc	r23, r25
    3fc8:	cb 01       	movw	r24, r22
    3fca:	84 0f       	add	r24, r20
    3fcc:	95 1f       	adc	r25, r21
    3fce:	ee 81       	ldd	r30, Y+6	; 0x06
    3fd0:	ff 81       	ldd	r31, Y+7	; 0x07
    3fd2:	91 83       	std	Z+1, r25	; 0x01
    3fd4:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3fd6:	8c 81       	ldd	r24, Y+4	; 0x04
    3fd8:	9d 81       	ldd	r25, Y+5	; 0x05
    3fda:	0e 94 79 1f 	call	0x3ef2	; 0x3ef2 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3fde:	1b 82       	std	Y+3, r1	; 0x03
    3fe0:	02 c0       	rjmp	.+4      	; 0x3fe6 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    3fe2:	81 e0       	ldi	r24, 0x01	; 1
    3fe4:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    3fe6:	0f 90       	pop	r0
    3fe8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3fea:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3fec:	27 96       	adiw	r28, 0x07	; 7
    3fee:	0f b6       	in	r0, 0x3f	; 63
    3ff0:	f8 94       	cli
    3ff2:	de bf       	out	0x3e, r29	; 62
    3ff4:	0f be       	out	0x3f, r0	; 63
    3ff6:	cd bf       	out	0x3d, r28	; 61
    3ff8:	cf 91       	pop	r28
    3ffa:	df 91       	pop	r29
    3ffc:	08 95       	ret

00003ffe <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3ffe:	df 93       	push	r29
    4000:	cf 93       	push	r28
    4002:	cd b7       	in	r28, 0x3d	; 61
    4004:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4006:	81 e0       	ldi	r24, 0x01	; 1
    4008:	80 93 38 07 	sts	0x0738, r24
}
    400c:	cf 91       	pop	r28
    400e:	df 91       	pop	r29
    4010:	08 95       	ret

00004012 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4012:	df 93       	push	r29
    4014:	cf 93       	push	r28
    4016:	00 d0       	rcall	.+0      	; 0x4018 <prvIdleTask+0x6>
    4018:	cd b7       	in	r28, 0x3d	; 61
    401a:	de b7       	in	r29, 0x3e	; 62
    401c:	9a 83       	std	Y+2, r25	; 0x02
    401e:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4020:	0e 94 56 20 	call	0x40ac	; 0x40ac <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4024:	80 91 40 07 	lds	r24, 0x0740
    4028:	82 30       	cpi	r24, 0x02	; 2
    402a:	d0 f3       	brcs	.-12     	; 0x4020 <prvIdleTask+0xe>
			{
				taskYIELD();
    402c:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
    4030:	f7 cf       	rjmp	.-18     	; 0x4020 <prvIdleTask+0xe>

00004032 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4032:	df 93       	push	r29
    4034:	cf 93       	push	r28
    4036:	0f 92       	push	r0
    4038:	cd b7       	in	r28, 0x3d	; 61
    403a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    403c:	19 82       	std	Y+1, r1	; 0x01
    403e:	13 c0       	rjmp	.+38     	; 0x4066 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4040:	89 81       	ldd	r24, Y+1	; 0x01
    4042:	28 2f       	mov	r18, r24
    4044:	30 e0       	ldi	r19, 0x00	; 0
    4046:	c9 01       	movw	r24, r18
    4048:	88 0f       	add	r24, r24
    404a:	99 1f       	adc	r25, r25
    404c:	88 0f       	add	r24, r24
    404e:	99 1f       	adc	r25, r25
    4050:	88 0f       	add	r24, r24
    4052:	99 1f       	adc	r25, r25
    4054:	82 0f       	add	r24, r18
    4056:	93 1f       	adc	r25, r19
    4058:	80 5c       	subi	r24, 0xC0	; 192
    405a:	98 4f       	sbci	r25, 0xF8	; 248
    405c:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4060:	89 81       	ldd	r24, Y+1	; 0x01
    4062:	8f 5f       	subi	r24, 0xFF	; 255
    4064:	89 83       	std	Y+1, r24	; 0x01
    4066:	89 81       	ldd	r24, Y+1	; 0x01
    4068:	83 30       	cpi	r24, 0x03	; 3
    406a:	50 f3       	brcs	.-44     	; 0x4040 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    406c:	8b e5       	ldi	r24, 0x5B	; 91
    406e:	97 e0       	ldi	r25, 0x07	; 7
    4070:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4074:	84 e6       	ldi	r24, 0x64	; 100
    4076:	97 e0       	ldi	r25, 0x07	; 7
    4078:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <vListInitialise>
	vListInitialise( &xPendingReadyList );
    407c:	81 e7       	ldi	r24, 0x71	; 113
    407e:	97 e0       	ldi	r25, 0x07	; 7
    4080:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4084:	8a e7       	ldi	r24, 0x7A	; 122
    4086:	97 e0       	ldi	r25, 0x07	; 7
    4088:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    408c:	8b e5       	ldi	r24, 0x5B	; 91
    408e:	97 e0       	ldi	r25, 0x07	; 7
    4090:	90 93 6e 07 	sts	0x076E, r25
    4094:	80 93 6d 07 	sts	0x076D, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4098:	84 e6       	ldi	r24, 0x64	; 100
    409a:	97 e0       	ldi	r25, 0x07	; 7
    409c:	90 93 70 07 	sts	0x0770, r25
    40a0:	80 93 6f 07 	sts	0x076F, r24
}
    40a4:	0f 90       	pop	r0
    40a6:	cf 91       	pop	r28
    40a8:	df 91       	pop	r29
    40aa:	08 95       	ret

000040ac <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    40ac:	df 93       	push	r29
    40ae:	cf 93       	push	r28
    40b0:	cd b7       	in	r28, 0x3d	; 61
    40b2:	de b7       	in	r29, 0x3e	; 62
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    40b4:	cf 91       	pop	r28
    40b6:	df 91       	pop	r29
    40b8:	08 95       	ret

000040ba <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    40ba:	df 93       	push	r29
    40bc:	cf 93       	push	r28
    40be:	00 d0       	rcall	.+0      	; 0x40c0 <prvResetNextTaskUnblockTime+0x6>
    40c0:	cd b7       	in	r28, 0x3d	; 61
    40c2:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    40c4:	e0 91 6d 07 	lds	r30, 0x076D
    40c8:	f0 91 6e 07 	lds	r31, 0x076E
    40cc:	80 81       	ld	r24, Z
    40ce:	88 23       	and	r24, r24
    40d0:	39 f4       	brne	.+14     	; 0x40e0 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    40d2:	8f ef       	ldi	r24, 0xFF	; 255
    40d4:	9f ef       	ldi	r25, 0xFF	; 255
    40d6:	90 93 3c 07 	sts	0x073C, r25
    40da:	80 93 3b 07 	sts	0x073B, r24
    40de:	13 c0       	rjmp	.+38     	; 0x4106 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    40e0:	e0 91 6d 07 	lds	r30, 0x076D
    40e4:	f0 91 6e 07 	lds	r31, 0x076E
    40e8:	05 80       	ldd	r0, Z+5	; 0x05
    40ea:	f6 81       	ldd	r31, Z+6	; 0x06
    40ec:	e0 2d       	mov	r30, r0
    40ee:	86 81       	ldd	r24, Z+6	; 0x06
    40f0:	97 81       	ldd	r25, Z+7	; 0x07
    40f2:	9a 83       	std	Y+2, r25	; 0x02
    40f4:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    40f6:	e9 81       	ldd	r30, Y+1	; 0x01
    40f8:	fa 81       	ldd	r31, Y+2	; 0x02
    40fa:	82 81       	ldd	r24, Z+2	; 0x02
    40fc:	93 81       	ldd	r25, Z+3	; 0x03
    40fe:	90 93 3c 07 	sts	0x073C, r25
    4102:	80 93 3b 07 	sts	0x073B, r24
	}
}
    4106:	0f 90       	pop	r0
    4108:	0f 90       	pop	r0
    410a:	cf 91       	pop	r28
    410c:	df 91       	pop	r29
    410e:	08 95       	ret

00004110 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4110:	df 93       	push	r29
    4112:	cf 93       	push	r28
    4114:	00 d0       	rcall	.+0      	; 0x4116 <xTaskGetCurrentTaskHandle+0x6>
    4116:	cd b7       	in	r28, 0x3d	; 61
    4118:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    411a:	80 91 30 07 	lds	r24, 0x0730
    411e:	90 91 31 07 	lds	r25, 0x0731
    4122:	9a 83       	std	Y+2, r25	; 0x02
    4124:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4126:	89 81       	ldd	r24, Y+1	; 0x01
    4128:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    412a:	0f 90       	pop	r0
    412c:	0f 90       	pop	r0
    412e:	cf 91       	pop	r28
    4130:	df 91       	pop	r29
    4132:	08 95       	ret

00004134 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    4134:	df 93       	push	r29
    4136:	cf 93       	push	r28
    4138:	00 d0       	rcall	.+0      	; 0x413a <vTaskPriorityInherit+0x6>
    413a:	00 d0       	rcall	.+0      	; 0x413c <vTaskPriorityInherit+0x8>
    413c:	cd b7       	in	r28, 0x3d	; 61
    413e:	de b7       	in	r29, 0x3e	; 62
    4140:	9c 83       	std	Y+4, r25	; 0x04
    4142:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4144:	8b 81       	ldd	r24, Y+3	; 0x03
    4146:	9c 81       	ldd	r25, Y+4	; 0x04
    4148:	9a 83       	std	Y+2, r25	; 0x02
    414a:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    414c:	8b 81       	ldd	r24, Y+3	; 0x03
    414e:	9c 81       	ldd	r25, Y+4	; 0x04
    4150:	00 97       	sbiw	r24, 0x00	; 0
    4152:	09 f4       	brne	.+2      	; 0x4156 <vTaskPriorityInherit+0x22>
    4154:	73 c0       	rjmp	.+230    	; 0x423c <vTaskPriorityInherit+0x108>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    4156:	e9 81       	ldd	r30, Y+1	; 0x01
    4158:	fa 81       	ldd	r31, Y+2	; 0x02
    415a:	96 89       	ldd	r25, Z+22	; 0x16
    415c:	e0 91 30 07 	lds	r30, 0x0730
    4160:	f0 91 31 07 	lds	r31, 0x0731
    4164:	86 89       	ldd	r24, Z+22	; 0x16
    4166:	98 17       	cp	r25, r24
    4168:	08 f0       	brcs	.+2      	; 0x416c <vTaskPriorityInherit+0x38>
    416a:	68 c0       	rjmp	.+208    	; 0x423c <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    416c:	e9 81       	ldd	r30, Y+1	; 0x01
    416e:	fa 81       	ldd	r31, Y+2	; 0x02
    4170:	84 85       	ldd	r24, Z+12	; 0x0c
    4172:	95 85       	ldd	r25, Z+13	; 0x0d
    4174:	99 23       	and	r25, r25
    4176:	7c f0       	brlt	.+30     	; 0x4196 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4178:	e0 91 30 07 	lds	r30, 0x0730
    417c:	f0 91 31 07 	lds	r31, 0x0731
    4180:	86 89       	ldd	r24, Z+22	; 0x16
    4182:	28 2f       	mov	r18, r24
    4184:	30 e0       	ldi	r19, 0x00	; 0
    4186:	83 e0       	ldi	r24, 0x03	; 3
    4188:	90 e0       	ldi	r25, 0x00	; 0
    418a:	82 1b       	sub	r24, r18
    418c:	93 0b       	sbc	r25, r19
    418e:	e9 81       	ldd	r30, Y+1	; 0x01
    4190:	fa 81       	ldd	r31, Y+2	; 0x02
    4192:	95 87       	std	Z+13, r25	; 0x0d
    4194:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    4196:	e9 81       	ldd	r30, Y+1	; 0x01
    4198:	fa 81       	ldd	r31, Y+2	; 0x02
    419a:	42 85       	ldd	r20, Z+10	; 0x0a
    419c:	53 85       	ldd	r21, Z+11	; 0x0b
    419e:	e9 81       	ldd	r30, Y+1	; 0x01
    41a0:	fa 81       	ldd	r31, Y+2	; 0x02
    41a2:	86 89       	ldd	r24, Z+22	; 0x16
    41a4:	28 2f       	mov	r18, r24
    41a6:	30 e0       	ldi	r19, 0x00	; 0
    41a8:	c9 01       	movw	r24, r18
    41aa:	88 0f       	add	r24, r24
    41ac:	99 1f       	adc	r25, r25
    41ae:	88 0f       	add	r24, r24
    41b0:	99 1f       	adc	r25, r25
    41b2:	88 0f       	add	r24, r24
    41b4:	99 1f       	adc	r25, r25
    41b6:	82 0f       	add	r24, r18
    41b8:	93 1f       	adc	r25, r19
    41ba:	80 5c       	subi	r24, 0xC0	; 192
    41bc:	98 4f       	sbci	r25, 0xF8	; 248
    41be:	48 17       	cp	r20, r24
    41c0:	59 07       	cpc	r21, r25
    41c2:	a1 f5       	brne	.+104    	; 0x422c <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    41c4:	89 81       	ldd	r24, Y+1	; 0x01
    41c6:	9a 81       	ldd	r25, Y+2	; 0x02
    41c8:	02 96       	adiw	r24, 0x02	; 2
    41ca:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    41ce:	e0 91 30 07 	lds	r30, 0x0730
    41d2:	f0 91 31 07 	lds	r31, 0x0731
    41d6:	86 89       	ldd	r24, Z+22	; 0x16
    41d8:	e9 81       	ldd	r30, Y+1	; 0x01
    41da:	fa 81       	ldd	r31, Y+2	; 0x02
    41dc:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    41de:	e9 81       	ldd	r30, Y+1	; 0x01
    41e0:	fa 81       	ldd	r31, Y+2	; 0x02
    41e2:	96 89       	ldd	r25, Z+22	; 0x16
    41e4:	80 91 35 07 	lds	r24, 0x0735
    41e8:	89 17       	cp	r24, r25
    41ea:	28 f4       	brcc	.+10     	; 0x41f6 <vTaskPriorityInherit+0xc2>
    41ec:	e9 81       	ldd	r30, Y+1	; 0x01
    41ee:	fa 81       	ldd	r31, Y+2	; 0x02
    41f0:	86 89       	ldd	r24, Z+22	; 0x16
    41f2:	80 93 35 07 	sts	0x0735, r24
    41f6:	e9 81       	ldd	r30, Y+1	; 0x01
    41f8:	fa 81       	ldd	r31, Y+2	; 0x02
    41fa:	86 89       	ldd	r24, Z+22	; 0x16
    41fc:	28 2f       	mov	r18, r24
    41fe:	30 e0       	ldi	r19, 0x00	; 0
    4200:	c9 01       	movw	r24, r18
    4202:	88 0f       	add	r24, r24
    4204:	99 1f       	adc	r25, r25
    4206:	88 0f       	add	r24, r24
    4208:	99 1f       	adc	r25, r25
    420a:	88 0f       	add	r24, r24
    420c:	99 1f       	adc	r25, r25
    420e:	82 0f       	add	r24, r18
    4210:	93 1f       	adc	r25, r19
    4212:	ac 01       	movw	r20, r24
    4214:	40 5c       	subi	r20, 0xC0	; 192
    4216:	58 4f       	sbci	r21, 0xF8	; 248
    4218:	89 81       	ldd	r24, Y+1	; 0x01
    421a:	9a 81       	ldd	r25, Y+2	; 0x02
    421c:	9c 01       	movw	r18, r24
    421e:	2e 5f       	subi	r18, 0xFE	; 254
    4220:	3f 4f       	sbci	r19, 0xFF	; 255
    4222:	ca 01       	movw	r24, r20
    4224:	b9 01       	movw	r22, r18
    4226:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
    422a:	08 c0       	rjmp	.+16     	; 0x423c <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    422c:	e0 91 30 07 	lds	r30, 0x0730
    4230:	f0 91 31 07 	lds	r31, 0x0731
    4234:	86 89       	ldd	r24, Z+22	; 0x16
    4236:	e9 81       	ldd	r30, Y+1	; 0x01
    4238:	fa 81       	ldd	r31, Y+2	; 0x02
    423a:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    423c:	0f 90       	pop	r0
    423e:	0f 90       	pop	r0
    4240:	0f 90       	pop	r0
    4242:	0f 90       	pop	r0
    4244:	cf 91       	pop	r28
    4246:	df 91       	pop	r29
    4248:	08 95       	ret

0000424a <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    424a:	df 93       	push	r29
    424c:	cf 93       	push	r28
    424e:	00 d0       	rcall	.+0      	; 0x4250 <xTaskPriorityDisinherit+0x6>
    4250:	00 d0       	rcall	.+0      	; 0x4252 <xTaskPriorityDisinherit+0x8>
    4252:	0f 92       	push	r0
    4254:	cd b7       	in	r28, 0x3d	; 61
    4256:	de b7       	in	r29, 0x3e	; 62
    4258:	9d 83       	std	Y+5, r25	; 0x05
    425a:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    425c:	8c 81       	ldd	r24, Y+4	; 0x04
    425e:	9d 81       	ldd	r25, Y+5	; 0x05
    4260:	9b 83       	std	Y+3, r25	; 0x03
    4262:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    4264:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    4266:	8c 81       	ldd	r24, Y+4	; 0x04
    4268:	9d 81       	ldd	r25, Y+5	; 0x05
    426a:	00 97       	sbiw	r24, 0x00	; 0
    426c:	09 f4       	brne	.+2      	; 0x4270 <xTaskPriorityDisinherit+0x26>
    426e:	56 c0       	rjmp	.+172    	; 0x431c <xTaskPriorityDisinherit+0xd2>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    4270:	ea 81       	ldd	r30, Y+2	; 0x02
    4272:	fb 81       	ldd	r31, Y+3	; 0x03
    4274:	85 8d       	ldd	r24, Z+29	; 0x1d
    4276:	81 50       	subi	r24, 0x01	; 1
    4278:	ea 81       	ldd	r30, Y+2	; 0x02
    427a:	fb 81       	ldd	r31, Y+3	; 0x03
    427c:	85 8f       	std	Z+29, r24	; 0x1d

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    427e:	ea 81       	ldd	r30, Y+2	; 0x02
    4280:	fb 81       	ldd	r31, Y+3	; 0x03
    4282:	96 89       	ldd	r25, Z+22	; 0x16
    4284:	ea 81       	ldd	r30, Y+2	; 0x02
    4286:	fb 81       	ldd	r31, Y+3	; 0x03
    4288:	84 8d       	ldd	r24, Z+28	; 0x1c
    428a:	98 17       	cp	r25, r24
    428c:	09 f4       	brne	.+2      	; 0x4290 <xTaskPriorityDisinherit+0x46>
    428e:	46 c0       	rjmp	.+140    	; 0x431c <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4290:	ea 81       	ldd	r30, Y+2	; 0x02
    4292:	fb 81       	ldd	r31, Y+3	; 0x03
    4294:	85 8d       	ldd	r24, Z+29	; 0x1d
    4296:	88 23       	and	r24, r24
    4298:	09 f0       	breq	.+2      	; 0x429c <xTaskPriorityDisinherit+0x52>
    429a:	40 c0       	rjmp	.+128    	; 0x431c <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    429c:	8a 81       	ldd	r24, Y+2	; 0x02
    429e:	9b 81       	ldd	r25, Y+3	; 0x03
    42a0:	02 96       	adiw	r24, 0x02	; 2
    42a2:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    42a6:	ea 81       	ldd	r30, Y+2	; 0x02
    42a8:	fb 81       	ldd	r31, Y+3	; 0x03
    42aa:	84 8d       	ldd	r24, Z+28	; 0x1c
    42ac:	ea 81       	ldd	r30, Y+2	; 0x02
    42ae:	fb 81       	ldd	r31, Y+3	; 0x03
    42b0:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    42b2:	ea 81       	ldd	r30, Y+2	; 0x02
    42b4:	fb 81       	ldd	r31, Y+3	; 0x03
    42b6:	86 89       	ldd	r24, Z+22	; 0x16
    42b8:	28 2f       	mov	r18, r24
    42ba:	30 e0       	ldi	r19, 0x00	; 0
    42bc:	83 e0       	ldi	r24, 0x03	; 3
    42be:	90 e0       	ldi	r25, 0x00	; 0
    42c0:	82 1b       	sub	r24, r18
    42c2:	93 0b       	sbc	r25, r19
    42c4:	ea 81       	ldd	r30, Y+2	; 0x02
    42c6:	fb 81       	ldd	r31, Y+3	; 0x03
    42c8:	95 87       	std	Z+13, r25	; 0x0d
    42ca:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    42cc:	ea 81       	ldd	r30, Y+2	; 0x02
    42ce:	fb 81       	ldd	r31, Y+3	; 0x03
    42d0:	96 89       	ldd	r25, Z+22	; 0x16
    42d2:	80 91 35 07 	lds	r24, 0x0735
    42d6:	89 17       	cp	r24, r25
    42d8:	28 f4       	brcc	.+10     	; 0x42e4 <xTaskPriorityDisinherit+0x9a>
    42da:	ea 81       	ldd	r30, Y+2	; 0x02
    42dc:	fb 81       	ldd	r31, Y+3	; 0x03
    42de:	86 89       	ldd	r24, Z+22	; 0x16
    42e0:	80 93 35 07 	sts	0x0735, r24
    42e4:	ea 81       	ldd	r30, Y+2	; 0x02
    42e6:	fb 81       	ldd	r31, Y+3	; 0x03
    42e8:	86 89       	ldd	r24, Z+22	; 0x16
    42ea:	28 2f       	mov	r18, r24
    42ec:	30 e0       	ldi	r19, 0x00	; 0
    42ee:	c9 01       	movw	r24, r18
    42f0:	88 0f       	add	r24, r24
    42f2:	99 1f       	adc	r25, r25
    42f4:	88 0f       	add	r24, r24
    42f6:	99 1f       	adc	r25, r25
    42f8:	88 0f       	add	r24, r24
    42fa:	99 1f       	adc	r25, r25
    42fc:	82 0f       	add	r24, r18
    42fe:	93 1f       	adc	r25, r19
    4300:	ac 01       	movw	r20, r24
    4302:	40 5c       	subi	r20, 0xC0	; 192
    4304:	58 4f       	sbci	r21, 0xF8	; 248
    4306:	8a 81       	ldd	r24, Y+2	; 0x02
    4308:	9b 81       	ldd	r25, Y+3	; 0x03
    430a:	9c 01       	movw	r18, r24
    430c:	2e 5f       	subi	r18, 0xFE	; 254
    430e:	3f 4f       	sbci	r19, 0xFF	; 255
    4310:	ca 01       	movw	r24, r20
    4312:	b9 01       	movw	r22, r18
    4314:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    4318:	81 e0       	ldi	r24, 0x01	; 1
    431a:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    431c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    431e:	0f 90       	pop	r0
    4320:	0f 90       	pop	r0
    4322:	0f 90       	pop	r0
    4324:	0f 90       	pop	r0
    4326:	0f 90       	pop	r0
    4328:	cf 91       	pop	r28
    432a:	df 91       	pop	r29
    432c:	08 95       	ret

0000432e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    432e:	df 93       	push	r29
    4330:	cf 93       	push	r28
    4332:	00 d0       	rcall	.+0      	; 0x4334 <uxTaskResetEventItemValue+0x6>
    4334:	cd b7       	in	r28, 0x3d	; 61
    4336:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4338:	e0 91 30 07 	lds	r30, 0x0730
    433c:	f0 91 31 07 	lds	r31, 0x0731
    4340:	84 85       	ldd	r24, Z+12	; 0x0c
    4342:	95 85       	ldd	r25, Z+13	; 0x0d
    4344:	9a 83       	std	Y+2, r25	; 0x02
    4346:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4348:	a0 91 30 07 	lds	r26, 0x0730
    434c:	b0 91 31 07 	lds	r27, 0x0731
    4350:	e0 91 30 07 	lds	r30, 0x0730
    4354:	f0 91 31 07 	lds	r31, 0x0731
    4358:	86 89       	ldd	r24, Z+22	; 0x16
    435a:	28 2f       	mov	r18, r24
    435c:	30 e0       	ldi	r19, 0x00	; 0
    435e:	83 e0       	ldi	r24, 0x03	; 3
    4360:	90 e0       	ldi	r25, 0x00	; 0
    4362:	82 1b       	sub	r24, r18
    4364:	93 0b       	sbc	r25, r19
    4366:	1d 96       	adiw	r26, 0x0d	; 13
    4368:	9c 93       	st	X, r25
    436a:	8e 93       	st	-X, r24
    436c:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    436e:	89 81       	ldd	r24, Y+1	; 0x01
    4370:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4372:	0f 90       	pop	r0
    4374:	0f 90       	pop	r0
    4376:	cf 91       	pop	r28
    4378:	df 91       	pop	r29
    437a:	08 95       	ret

0000437c <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    437c:	df 93       	push	r29
    437e:	cf 93       	push	r28
    4380:	cd b7       	in	r28, 0x3d	; 61
    4382:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    4384:	80 91 30 07 	lds	r24, 0x0730
    4388:	90 91 31 07 	lds	r25, 0x0731
    438c:	00 97       	sbiw	r24, 0x00	; 0
    438e:	39 f0       	breq	.+14     	; 0x439e <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    4390:	e0 91 30 07 	lds	r30, 0x0730
    4394:	f0 91 31 07 	lds	r31, 0x0731
    4398:	85 8d       	ldd	r24, Z+29	; 0x1d
    439a:	8f 5f       	subi	r24, 0xFF	; 255
    439c:	85 8f       	std	Z+29, r24	; 0x1d
		}

		return pxCurrentTCB;
    439e:	80 91 30 07 	lds	r24, 0x0730
    43a2:	90 91 31 07 	lds	r25, 0x0731
	}
    43a6:	cf 91       	pop	r28
    43a8:	df 91       	pop	r29
    43aa:	08 95       	ret

000043ac <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    43ac:	df 93       	push	r29
    43ae:	cf 93       	push	r28
    43b0:	cd b7       	in	r28, 0x3d	; 61
    43b2:	de b7       	in	r29, 0x3e	; 62
    43b4:	27 97       	sbiw	r28, 0x07	; 7
    43b6:	0f b6       	in	r0, 0x3f	; 63
    43b8:	f8 94       	cli
    43ba:	de bf       	out	0x3e, r29	; 62
    43bc:	0f be       	out	0x3f, r0	; 63
    43be:	cd bf       	out	0x3d, r28	; 61
    43c0:	8d 83       	std	Y+5, r24	; 0x05
    43c2:	7f 83       	std	Y+7, r23	; 0x07
    43c4:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    43c6:	0f b6       	in	r0, 0x3f	; 63
    43c8:	f8 94       	cli
    43ca:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    43cc:	e0 91 30 07 	lds	r30, 0x0730
    43d0:	f0 91 31 07 	lds	r31, 0x0731
    43d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    43d6:	97 8d       	ldd	r25, Z+31	; 0x1f
    43d8:	a0 a1       	ldd	r26, Z+32	; 0x20
    43da:	b1 a1       	ldd	r27, Z+33	; 0x21
    43dc:	00 97       	sbiw	r24, 0x00	; 0
    43de:	a1 05       	cpc	r26, r1
    43e0:	b1 05       	cpc	r27, r1
    43e2:	89 f4       	brne	.+34     	; 0x4406 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    43e4:	e0 91 30 07 	lds	r30, 0x0730
    43e8:	f0 91 31 07 	lds	r31, 0x0731
    43ec:	81 e0       	ldi	r24, 0x01	; 1
    43ee:	82 a3       	std	Z+34, r24	; 0x22

				if( xTicksToWait > ( TickType_t ) 0 )
    43f0:	8e 81       	ldd	r24, Y+6	; 0x06
    43f2:	9f 81       	ldd	r25, Y+7	; 0x07
    43f4:	00 97       	sbiw	r24, 0x00	; 0
    43f6:	39 f0       	breq	.+14     	; 0x4406 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    43f8:	8e 81       	ldd	r24, Y+6	; 0x06
    43fa:	9f 81       	ldd	r25, Y+7	; 0x07
    43fc:	61 e0       	ldi	r22, 0x01	; 1
    43fe:	0e 94 80 25 	call	0x4b00	; 0x4b00 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4402:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4406:	0f 90       	pop	r0
    4408:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    440a:	0f b6       	in	r0, 0x3f	; 63
    440c:	f8 94       	cli
    440e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4410:	e0 91 30 07 	lds	r30, 0x0730
    4414:	f0 91 31 07 	lds	r31, 0x0731
    4418:	86 8d       	ldd	r24, Z+30	; 0x1e
    441a:	97 8d       	ldd	r25, Z+31	; 0x1f
    441c:	a0 a1       	ldd	r26, Z+32	; 0x20
    441e:	b1 a1       	ldd	r27, Z+33	; 0x21
    4420:	89 83       	std	Y+1, r24	; 0x01
    4422:	9a 83       	std	Y+2, r25	; 0x02
    4424:	ab 83       	std	Y+3, r26	; 0x03
    4426:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4428:	89 81       	ldd	r24, Y+1	; 0x01
    442a:	9a 81       	ldd	r25, Y+2	; 0x02
    442c:	ab 81       	ldd	r26, Y+3	; 0x03
    442e:	bc 81       	ldd	r27, Y+4	; 0x04
    4430:	00 97       	sbiw	r24, 0x00	; 0
    4432:	a1 05       	cpc	r26, r1
    4434:	b1 05       	cpc	r27, r1
    4436:	d9 f0       	breq	.+54     	; 0x446e <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4438:	8d 81       	ldd	r24, Y+5	; 0x05
    443a:	88 23       	and	r24, r24
    443c:	49 f0       	breq	.+18     	; 0x4450 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    443e:	e0 91 30 07 	lds	r30, 0x0730
    4442:	f0 91 31 07 	lds	r31, 0x0731
    4446:	16 8e       	std	Z+30, r1	; 0x1e
    4448:	17 8e       	std	Z+31, r1	; 0x1f
    444a:	10 a2       	std	Z+32, r1	; 0x20
    444c:	11 a2       	std	Z+33, r1	; 0x21
    444e:	0f c0       	rjmp	.+30     	; 0x446e <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    4450:	e0 91 30 07 	lds	r30, 0x0730
    4454:	f0 91 31 07 	lds	r31, 0x0731
    4458:	89 81       	ldd	r24, Y+1	; 0x01
    445a:	9a 81       	ldd	r25, Y+2	; 0x02
    445c:	ab 81       	ldd	r26, Y+3	; 0x03
    445e:	bc 81       	ldd	r27, Y+4	; 0x04
    4460:	01 97       	sbiw	r24, 0x01	; 1
    4462:	a1 09       	sbc	r26, r1
    4464:	b1 09       	sbc	r27, r1
    4466:	86 8f       	std	Z+30, r24	; 0x1e
    4468:	97 8f       	std	Z+31, r25	; 0x1f
    446a:	a0 a3       	std	Z+32, r26	; 0x20
    446c:	b1 a3       	std	Z+33, r27	; 0x21
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    446e:	e0 91 30 07 	lds	r30, 0x0730
    4472:	f0 91 31 07 	lds	r31, 0x0731
    4476:	12 a2       	std	Z+34, r1	; 0x22
		}
		taskEXIT_CRITICAL();
    4478:	0f 90       	pop	r0
    447a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    447c:	89 81       	ldd	r24, Y+1	; 0x01
    447e:	9a 81       	ldd	r25, Y+2	; 0x02
    4480:	ab 81       	ldd	r26, Y+3	; 0x03
    4482:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4484:	bc 01       	movw	r22, r24
    4486:	cd 01       	movw	r24, r26
    4488:	27 96       	adiw	r28, 0x07	; 7
    448a:	0f b6       	in	r0, 0x3f	; 63
    448c:	f8 94       	cli
    448e:	de bf       	out	0x3e, r29	; 62
    4490:	0f be       	out	0x3f, r0	; 63
    4492:	cd bf       	out	0x3d, r28	; 61
    4494:	cf 91       	pop	r28
    4496:	df 91       	pop	r29
    4498:	08 95       	ret

0000449a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    449a:	ef 92       	push	r14
    449c:	ff 92       	push	r15
    449e:	0f 93       	push	r16
    44a0:	1f 93       	push	r17
    44a2:	df 93       	push	r29
    44a4:	cf 93       	push	r28
    44a6:	cd b7       	in	r28, 0x3d	; 61
    44a8:	de b7       	in	r29, 0x3e	; 62
    44aa:	2d 97       	sbiw	r28, 0x0d	; 13
    44ac:	0f b6       	in	r0, 0x3f	; 63
    44ae:	f8 94       	cli
    44b0:	de bf       	out	0x3e, r29	; 62
    44b2:	0f be       	out	0x3f, r0	; 63
    44b4:	cd bf       	out	0x3d, r28	; 61
    44b6:	6a 83       	std	Y+2, r22	; 0x02
    44b8:	7b 83       	std	Y+3, r23	; 0x03
    44ba:	8c 83       	std	Y+4, r24	; 0x04
    44bc:	9d 83       	std	Y+5, r25	; 0x05
    44be:	2e 83       	std	Y+6, r18	; 0x06
    44c0:	3f 83       	std	Y+7, r19	; 0x07
    44c2:	48 87       	std	Y+8, r20	; 0x08
    44c4:	59 87       	std	Y+9, r21	; 0x09
    44c6:	1b 87       	std	Y+11, r17	; 0x0b
    44c8:	0a 87       	std	Y+10, r16	; 0x0a
    44ca:	fd 86       	std	Y+13, r15	; 0x0d
    44cc:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    44ce:	0f b6       	in	r0, 0x3f	; 63
    44d0:	f8 94       	cli
    44d2:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    44d4:	e0 91 30 07 	lds	r30, 0x0730
    44d8:	f0 91 31 07 	lds	r31, 0x0731
    44dc:	82 a1       	ldd	r24, Z+34	; 0x22
    44de:	82 30       	cpi	r24, 0x02	; 2
    44e0:	49 f1       	breq	.+82     	; 0x4534 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    44e2:	e0 91 30 07 	lds	r30, 0x0730
    44e6:	f0 91 31 07 	lds	r31, 0x0731
    44ea:	26 8d       	ldd	r18, Z+30	; 0x1e
    44ec:	37 8d       	ldd	r19, Z+31	; 0x1f
    44ee:	40 a1       	ldd	r20, Z+32	; 0x20
    44f0:	51 a1       	ldd	r21, Z+33	; 0x21
    44f2:	8a 81       	ldd	r24, Y+2	; 0x02
    44f4:	9b 81       	ldd	r25, Y+3	; 0x03
    44f6:	ac 81       	ldd	r26, Y+4	; 0x04
    44f8:	bd 81       	ldd	r27, Y+5	; 0x05
    44fa:	80 95       	com	r24
    44fc:	90 95       	com	r25
    44fe:	a0 95       	com	r26
    4500:	b0 95       	com	r27
    4502:	82 23       	and	r24, r18
    4504:	93 23       	and	r25, r19
    4506:	a4 23       	and	r26, r20
    4508:	b5 23       	and	r27, r21
    450a:	86 8f       	std	Z+30, r24	; 0x1e
    450c:	97 8f       	std	Z+31, r25	; 0x1f
    450e:	a0 a3       	std	Z+32, r26	; 0x20
    4510:	b1 a3       	std	Z+33, r27	; 0x21

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4512:	e0 91 30 07 	lds	r30, 0x0730
    4516:	f0 91 31 07 	lds	r31, 0x0731
    451a:	81 e0       	ldi	r24, 0x01	; 1
    451c:	82 a3       	std	Z+34, r24	; 0x22

				if( xTicksToWait > ( TickType_t ) 0 )
    451e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4520:	9d 85       	ldd	r25, Y+13	; 0x0d
    4522:	00 97       	sbiw	r24, 0x00	; 0
    4524:	39 f0       	breq	.+14     	; 0x4534 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4526:	8c 85       	ldd	r24, Y+12	; 0x0c
    4528:	9d 85       	ldd	r25, Y+13	; 0x0d
    452a:	61 e0       	ldi	r22, 0x01	; 1
    452c:	0e 94 80 25 	call	0x4b00	; 0x4b00 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4530:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4534:	0f 90       	pop	r0
    4536:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4538:	0f b6       	in	r0, 0x3f	; 63
    453a:	f8 94       	cli
    453c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    453e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4540:	9b 85       	ldd	r25, Y+11	; 0x0b
    4542:	00 97       	sbiw	r24, 0x00	; 0
    4544:	71 f0       	breq	.+28     	; 0x4562 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4546:	e0 91 30 07 	lds	r30, 0x0730
    454a:	f0 91 31 07 	lds	r31, 0x0731
    454e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4550:	97 8d       	ldd	r25, Z+31	; 0x1f
    4552:	a0 a1       	ldd	r26, Z+32	; 0x20
    4554:	b1 a1       	ldd	r27, Z+33	; 0x21
    4556:	ea 85       	ldd	r30, Y+10	; 0x0a
    4558:	fb 85       	ldd	r31, Y+11	; 0x0b
    455a:	80 83       	st	Z, r24
    455c:	91 83       	std	Z+1, r25	; 0x01
    455e:	a2 83       	std	Z+2, r26	; 0x02
    4560:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4562:	e0 91 30 07 	lds	r30, 0x0730
    4566:	f0 91 31 07 	lds	r31, 0x0731
    456a:	82 a1       	ldd	r24, Z+34	; 0x22
    456c:	81 30       	cpi	r24, 0x01	; 1
    456e:	11 f4       	brne	.+4      	; 0x4574 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4570:	19 82       	std	Y+1, r1	; 0x01
    4572:	1a c0       	rjmp	.+52     	; 0x45a8 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4574:	e0 91 30 07 	lds	r30, 0x0730
    4578:	f0 91 31 07 	lds	r31, 0x0731
    457c:	26 8d       	ldd	r18, Z+30	; 0x1e
    457e:	37 8d       	ldd	r19, Z+31	; 0x1f
    4580:	40 a1       	ldd	r20, Z+32	; 0x20
    4582:	51 a1       	ldd	r21, Z+33	; 0x21
    4584:	8e 81       	ldd	r24, Y+6	; 0x06
    4586:	9f 81       	ldd	r25, Y+7	; 0x07
    4588:	a8 85       	ldd	r26, Y+8	; 0x08
    458a:	b9 85       	ldd	r27, Y+9	; 0x09
    458c:	80 95       	com	r24
    458e:	90 95       	com	r25
    4590:	a0 95       	com	r26
    4592:	b0 95       	com	r27
    4594:	82 23       	and	r24, r18
    4596:	93 23       	and	r25, r19
    4598:	a4 23       	and	r26, r20
    459a:	b5 23       	and	r27, r21
    459c:	86 8f       	std	Z+30, r24	; 0x1e
    459e:	97 8f       	std	Z+31, r25	; 0x1f
    45a0:	a0 a3       	std	Z+32, r26	; 0x20
    45a2:	b1 a3       	std	Z+33, r27	; 0x21
				xReturn = pdTRUE;
    45a4:	81 e0       	ldi	r24, 0x01	; 1
    45a6:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    45a8:	e0 91 30 07 	lds	r30, 0x0730
    45ac:	f0 91 31 07 	lds	r31, 0x0731
    45b0:	12 a2       	std	Z+34, r1	; 0x22
		}
		taskEXIT_CRITICAL();
    45b2:	0f 90       	pop	r0
    45b4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    45b6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    45b8:	2d 96       	adiw	r28, 0x0d	; 13
    45ba:	0f b6       	in	r0, 0x3f	; 63
    45bc:	f8 94       	cli
    45be:	de bf       	out	0x3e, r29	; 62
    45c0:	0f be       	out	0x3f, r0	; 63
    45c2:	cd bf       	out	0x3d, r28	; 61
    45c4:	cf 91       	pop	r28
    45c6:	df 91       	pop	r29
    45c8:	1f 91       	pop	r17
    45ca:	0f 91       	pop	r16
    45cc:	ff 90       	pop	r15
    45ce:	ef 90       	pop	r14
    45d0:	08 95       	ret

000045d2 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    45d2:	0f 93       	push	r16
    45d4:	1f 93       	push	r17
    45d6:	df 93       	push	r29
    45d8:	cf 93       	push	r28
    45da:	cd b7       	in	r28, 0x3d	; 61
    45dc:	de b7       	in	r29, 0x3e	; 62
    45de:	2f 97       	sbiw	r28, 0x0f	; 15
    45e0:	0f b6       	in	r0, 0x3f	; 63
    45e2:	f8 94       	cli
    45e4:	de bf       	out	0x3e, r29	; 62
    45e6:	0f be       	out	0x3f, r0	; 63
    45e8:	cd bf       	out	0x3d, r28	; 61
    45ea:	9e 83       	std	Y+6, r25	; 0x06
    45ec:	8d 83       	std	Y+5, r24	; 0x05
    45ee:	4f 83       	std	Y+7, r20	; 0x07
    45f0:	58 87       	std	Y+8, r21	; 0x08
    45f2:	69 87       	std	Y+9, r22	; 0x09
    45f4:	7a 87       	std	Y+10, r23	; 0x0a
    45f6:	2b 87       	std	Y+11, r18	; 0x0b
    45f8:	1d 87       	std	Y+13, r17	; 0x0d
    45fa:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    45fc:	81 e0       	ldi	r24, 0x01	; 1
    45fe:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    4600:	8d 81       	ldd	r24, Y+5	; 0x05
    4602:	9e 81       	ldd	r25, Y+6	; 0x06
    4604:	9c 83       	std	Y+4, r25	; 0x04
    4606:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4608:	0f b6       	in	r0, 0x3f	; 63
    460a:	f8 94       	cli
    460c:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    460e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4610:	9d 85       	ldd	r25, Y+13	; 0x0d
    4612:	00 97       	sbiw	r24, 0x00	; 0
    4614:	61 f0       	breq	.+24     	; 0x462e <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4616:	eb 81       	ldd	r30, Y+3	; 0x03
    4618:	fc 81       	ldd	r31, Y+4	; 0x04
    461a:	86 8d       	ldd	r24, Z+30	; 0x1e
    461c:	97 8d       	ldd	r25, Z+31	; 0x1f
    461e:	a0 a1       	ldd	r26, Z+32	; 0x20
    4620:	b1 a1       	ldd	r27, Z+33	; 0x21
    4622:	ec 85       	ldd	r30, Y+12	; 0x0c
    4624:	fd 85       	ldd	r31, Y+13	; 0x0d
    4626:	80 83       	st	Z, r24
    4628:	91 83       	std	Z+1, r25	; 0x01
    462a:	a2 83       	std	Z+2, r26	; 0x02
    462c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    462e:	eb 81       	ldd	r30, Y+3	; 0x03
    4630:	fc 81       	ldd	r31, Y+4	; 0x04
    4632:	82 a1       	ldd	r24, Z+34	; 0x22
    4634:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4636:	eb 81       	ldd	r30, Y+3	; 0x03
    4638:	fc 81       	ldd	r31, Y+4	; 0x04
    463a:	82 e0       	ldi	r24, 0x02	; 2
    463c:	82 a3       	std	Z+34, r24	; 0x22

			switch( eAction )
    463e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4640:	28 2f       	mov	r18, r24
    4642:	30 e0       	ldi	r19, 0x00	; 0
    4644:	3f 87       	std	Y+15, r19	; 0x0f
    4646:	2e 87       	std	Y+14, r18	; 0x0e
    4648:	8e 85       	ldd	r24, Y+14	; 0x0e
    464a:	9f 85       	ldd	r25, Y+15	; 0x0f
    464c:	82 30       	cpi	r24, 0x02	; 2
    464e:	91 05       	cpc	r25, r1
    4650:	59 f1       	breq	.+86     	; 0x46a8 <xTaskGenericNotify+0xd6>
    4652:	2e 85       	ldd	r18, Y+14	; 0x0e
    4654:	3f 85       	ldd	r19, Y+15	; 0x0f
    4656:	23 30       	cpi	r18, 0x03	; 3
    4658:	31 05       	cpc	r19, r1
    465a:	34 f4       	brge	.+12     	; 0x4668 <xTaskGenericNotify+0x96>
    465c:	8e 85       	ldd	r24, Y+14	; 0x0e
    465e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4660:	81 30       	cpi	r24, 0x01	; 1
    4662:	91 05       	cpc	r25, r1
    4664:	61 f0       	breq	.+24     	; 0x467e <xTaskGenericNotify+0xac>
    4666:	4a c0       	rjmp	.+148    	; 0x46fc <xTaskGenericNotify+0x12a>
    4668:	2e 85       	ldd	r18, Y+14	; 0x0e
    466a:	3f 85       	ldd	r19, Y+15	; 0x0f
    466c:	23 30       	cpi	r18, 0x03	; 3
    466e:	31 05       	cpc	r19, r1
    4670:	59 f1       	breq	.+86     	; 0x46c8 <xTaskGenericNotify+0xf6>
    4672:	8e 85       	ldd	r24, Y+14	; 0x0e
    4674:	9f 85       	ldd	r25, Y+15	; 0x0f
    4676:	84 30       	cpi	r24, 0x04	; 4
    4678:	91 05       	cpc	r25, r1
    467a:	89 f1       	breq	.+98     	; 0x46de <xTaskGenericNotify+0x10c>
    467c:	3f c0       	rjmp	.+126    	; 0x46fc <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    467e:	eb 81       	ldd	r30, Y+3	; 0x03
    4680:	fc 81       	ldd	r31, Y+4	; 0x04
    4682:	26 8d       	ldd	r18, Z+30	; 0x1e
    4684:	37 8d       	ldd	r19, Z+31	; 0x1f
    4686:	40 a1       	ldd	r20, Z+32	; 0x20
    4688:	51 a1       	ldd	r21, Z+33	; 0x21
    468a:	8f 81       	ldd	r24, Y+7	; 0x07
    468c:	98 85       	ldd	r25, Y+8	; 0x08
    468e:	a9 85       	ldd	r26, Y+9	; 0x09
    4690:	ba 85       	ldd	r27, Y+10	; 0x0a
    4692:	82 2b       	or	r24, r18
    4694:	93 2b       	or	r25, r19
    4696:	a4 2b       	or	r26, r20
    4698:	b5 2b       	or	r27, r21
    469a:	eb 81       	ldd	r30, Y+3	; 0x03
    469c:	fc 81       	ldd	r31, Y+4	; 0x04
    469e:	86 8f       	std	Z+30, r24	; 0x1e
    46a0:	97 8f       	std	Z+31, r25	; 0x1f
    46a2:	a0 a3       	std	Z+32, r26	; 0x20
    46a4:	b1 a3       	std	Z+33, r27	; 0x21
    46a6:	2a c0       	rjmp	.+84     	; 0x46fc <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    46a8:	eb 81       	ldd	r30, Y+3	; 0x03
    46aa:	fc 81       	ldd	r31, Y+4	; 0x04
    46ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    46ae:	97 8d       	ldd	r25, Z+31	; 0x1f
    46b0:	a0 a1       	ldd	r26, Z+32	; 0x20
    46b2:	b1 a1       	ldd	r27, Z+33	; 0x21
    46b4:	01 96       	adiw	r24, 0x01	; 1
    46b6:	a1 1d       	adc	r26, r1
    46b8:	b1 1d       	adc	r27, r1
    46ba:	eb 81       	ldd	r30, Y+3	; 0x03
    46bc:	fc 81       	ldd	r31, Y+4	; 0x04
    46be:	86 8f       	std	Z+30, r24	; 0x1e
    46c0:	97 8f       	std	Z+31, r25	; 0x1f
    46c2:	a0 a3       	std	Z+32, r26	; 0x20
    46c4:	b1 a3       	std	Z+33, r27	; 0x21
    46c6:	1a c0       	rjmp	.+52     	; 0x46fc <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    46c8:	eb 81       	ldd	r30, Y+3	; 0x03
    46ca:	fc 81       	ldd	r31, Y+4	; 0x04
    46cc:	8f 81       	ldd	r24, Y+7	; 0x07
    46ce:	98 85       	ldd	r25, Y+8	; 0x08
    46d0:	a9 85       	ldd	r26, Y+9	; 0x09
    46d2:	ba 85       	ldd	r27, Y+10	; 0x0a
    46d4:	86 8f       	std	Z+30, r24	; 0x1e
    46d6:	97 8f       	std	Z+31, r25	; 0x1f
    46d8:	a0 a3       	std	Z+32, r26	; 0x20
    46da:	b1 a3       	std	Z+33, r27	; 0x21
    46dc:	0f c0       	rjmp	.+30     	; 0x46fc <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    46de:	89 81       	ldd	r24, Y+1	; 0x01
    46e0:	82 30       	cpi	r24, 0x02	; 2
    46e2:	59 f0       	breq	.+22     	; 0x46fa <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    46e4:	eb 81       	ldd	r30, Y+3	; 0x03
    46e6:	fc 81       	ldd	r31, Y+4	; 0x04
    46e8:	8f 81       	ldd	r24, Y+7	; 0x07
    46ea:	98 85       	ldd	r25, Y+8	; 0x08
    46ec:	a9 85       	ldd	r26, Y+9	; 0x09
    46ee:	ba 85       	ldd	r27, Y+10	; 0x0a
    46f0:	86 8f       	std	Z+30, r24	; 0x1e
    46f2:	97 8f       	std	Z+31, r25	; 0x1f
    46f4:	a0 a3       	std	Z+32, r26	; 0x20
    46f6:	b1 a3       	std	Z+33, r27	; 0x21
    46f8:	01 c0       	rjmp	.+2      	; 0x46fc <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    46fa:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    46fc:	89 81       	ldd	r24, Y+1	; 0x01
    46fe:	81 30       	cpi	r24, 0x01	; 1
    4700:	b9 f5       	brne	.+110    	; 0x4770 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4702:	8b 81       	ldd	r24, Y+3	; 0x03
    4704:	9c 81       	ldd	r25, Y+4	; 0x04
    4706:	02 96       	adiw	r24, 0x02	; 2
    4708:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    470c:	eb 81       	ldd	r30, Y+3	; 0x03
    470e:	fc 81       	ldd	r31, Y+4	; 0x04
    4710:	96 89       	ldd	r25, Z+22	; 0x16
    4712:	80 91 35 07 	lds	r24, 0x0735
    4716:	89 17       	cp	r24, r25
    4718:	28 f4       	brcc	.+10     	; 0x4724 <xTaskGenericNotify+0x152>
    471a:	eb 81       	ldd	r30, Y+3	; 0x03
    471c:	fc 81       	ldd	r31, Y+4	; 0x04
    471e:	86 89       	ldd	r24, Z+22	; 0x16
    4720:	80 93 35 07 	sts	0x0735, r24
    4724:	eb 81       	ldd	r30, Y+3	; 0x03
    4726:	fc 81       	ldd	r31, Y+4	; 0x04
    4728:	86 89       	ldd	r24, Z+22	; 0x16
    472a:	28 2f       	mov	r18, r24
    472c:	30 e0       	ldi	r19, 0x00	; 0
    472e:	c9 01       	movw	r24, r18
    4730:	88 0f       	add	r24, r24
    4732:	99 1f       	adc	r25, r25
    4734:	88 0f       	add	r24, r24
    4736:	99 1f       	adc	r25, r25
    4738:	88 0f       	add	r24, r24
    473a:	99 1f       	adc	r25, r25
    473c:	82 0f       	add	r24, r18
    473e:	93 1f       	adc	r25, r19
    4740:	ac 01       	movw	r20, r24
    4742:	40 5c       	subi	r20, 0xC0	; 192
    4744:	58 4f       	sbci	r21, 0xF8	; 248
    4746:	8b 81       	ldd	r24, Y+3	; 0x03
    4748:	9c 81       	ldd	r25, Y+4	; 0x04
    474a:	9c 01       	movw	r18, r24
    474c:	2e 5f       	subi	r18, 0xFE	; 254
    474e:	3f 4f       	sbci	r19, 0xFF	; 255
    4750:	ca 01       	movw	r24, r20
    4752:	b9 01       	movw	r22, r18
    4754:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4758:	eb 81       	ldd	r30, Y+3	; 0x03
    475a:	fc 81       	ldd	r31, Y+4	; 0x04
    475c:	96 89       	ldd	r25, Z+22	; 0x16
    475e:	e0 91 30 07 	lds	r30, 0x0730
    4762:	f0 91 31 07 	lds	r31, 0x0731
    4766:	86 89       	ldd	r24, Z+22	; 0x16
    4768:	89 17       	cp	r24, r25
    476a:	10 f4       	brcc	.+4      	; 0x4770 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    476c:	0e 94 72 10 	call	0x20e4	; 0x20e4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4770:	0f 90       	pop	r0
    4772:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4774:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4776:	2f 96       	adiw	r28, 0x0f	; 15
    4778:	0f b6       	in	r0, 0x3f	; 63
    477a:	f8 94       	cli
    477c:	de bf       	out	0x3e, r29	; 62
    477e:	0f be       	out	0x3f, r0	; 63
    4780:	cd bf       	out	0x3d, r28	; 61
    4782:	cf 91       	pop	r28
    4784:	df 91       	pop	r29
    4786:	1f 91       	pop	r17
    4788:	0f 91       	pop	r16
    478a:	08 95       	ret

0000478c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    478c:	ef 92       	push	r14
    478e:	ff 92       	push	r15
    4790:	0f 93       	push	r16
    4792:	1f 93       	push	r17
    4794:	df 93       	push	r29
    4796:	cf 93       	push	r28
    4798:	cd b7       	in	r28, 0x3d	; 61
    479a:	de b7       	in	r29, 0x3e	; 62
    479c:	62 97       	sbiw	r28, 0x12	; 18
    479e:	0f b6       	in	r0, 0x3f	; 63
    47a0:	f8 94       	cli
    47a2:	de bf       	out	0x3e, r29	; 62
    47a4:	0f be       	out	0x3f, r0	; 63
    47a6:	cd bf       	out	0x3d, r28	; 61
    47a8:	9f 83       	std	Y+7, r25	; 0x07
    47aa:	8e 83       	std	Y+6, r24	; 0x06
    47ac:	48 87       	std	Y+8, r20	; 0x08
    47ae:	59 87       	std	Y+9, r21	; 0x09
    47b0:	6a 87       	std	Y+10, r22	; 0x0a
    47b2:	7b 87       	std	Y+11, r23	; 0x0b
    47b4:	2c 87       	std	Y+12, r18	; 0x0c
    47b6:	1e 87       	std	Y+14, r17	; 0x0e
    47b8:	0d 87       	std	Y+13, r16	; 0x0d
    47ba:	f8 8a       	std	Y+16, r15	; 0x10
    47bc:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    47be:	81 e0       	ldi	r24, 0x01	; 1
    47c0:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    47c2:	8e 81       	ldd	r24, Y+6	; 0x06
    47c4:	9f 81       	ldd	r25, Y+7	; 0x07
    47c6:	9d 83       	std	Y+5, r25	; 0x05
    47c8:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    47ca:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    47cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    47ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    47d0:	00 97       	sbiw	r24, 0x00	; 0
    47d2:	61 f0       	breq	.+24     	; 0x47ec <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    47d4:	ec 81       	ldd	r30, Y+4	; 0x04
    47d6:	fd 81       	ldd	r31, Y+5	; 0x05
    47d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    47da:	97 8d       	ldd	r25, Z+31	; 0x1f
    47dc:	a0 a1       	ldd	r26, Z+32	; 0x20
    47de:	b1 a1       	ldd	r27, Z+33	; 0x21
    47e0:	ed 85       	ldd	r30, Y+13	; 0x0d
    47e2:	fe 85       	ldd	r31, Y+14	; 0x0e
    47e4:	80 83       	st	Z, r24
    47e6:	91 83       	std	Z+1, r25	; 0x01
    47e8:	a2 83       	std	Z+2, r26	; 0x02
    47ea:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    47ec:	ec 81       	ldd	r30, Y+4	; 0x04
    47ee:	fd 81       	ldd	r31, Y+5	; 0x05
    47f0:	82 a1       	ldd	r24, Z+34	; 0x22
    47f2:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    47f4:	ec 81       	ldd	r30, Y+4	; 0x04
    47f6:	fd 81       	ldd	r31, Y+5	; 0x05
    47f8:	82 e0       	ldi	r24, 0x02	; 2
    47fa:	82 a3       	std	Z+34, r24	; 0x22

			switch( eAction )
    47fc:	8c 85       	ldd	r24, Y+12	; 0x0c
    47fe:	28 2f       	mov	r18, r24
    4800:	30 e0       	ldi	r19, 0x00	; 0
    4802:	3a 8b       	std	Y+18, r19	; 0x12
    4804:	29 8b       	std	Y+17, r18	; 0x11
    4806:	89 89       	ldd	r24, Y+17	; 0x11
    4808:	9a 89       	ldd	r25, Y+18	; 0x12
    480a:	82 30       	cpi	r24, 0x02	; 2
    480c:	91 05       	cpc	r25, r1
    480e:	59 f1       	breq	.+86     	; 0x4866 <xTaskGenericNotifyFromISR+0xda>
    4810:	29 89       	ldd	r18, Y+17	; 0x11
    4812:	3a 89       	ldd	r19, Y+18	; 0x12
    4814:	23 30       	cpi	r18, 0x03	; 3
    4816:	31 05       	cpc	r19, r1
    4818:	34 f4       	brge	.+12     	; 0x4826 <xTaskGenericNotifyFromISR+0x9a>
    481a:	89 89       	ldd	r24, Y+17	; 0x11
    481c:	9a 89       	ldd	r25, Y+18	; 0x12
    481e:	81 30       	cpi	r24, 0x01	; 1
    4820:	91 05       	cpc	r25, r1
    4822:	61 f0       	breq	.+24     	; 0x483c <xTaskGenericNotifyFromISR+0xb0>
    4824:	4a c0       	rjmp	.+148    	; 0x48ba <xTaskGenericNotifyFromISR+0x12e>
    4826:	29 89       	ldd	r18, Y+17	; 0x11
    4828:	3a 89       	ldd	r19, Y+18	; 0x12
    482a:	23 30       	cpi	r18, 0x03	; 3
    482c:	31 05       	cpc	r19, r1
    482e:	59 f1       	breq	.+86     	; 0x4886 <xTaskGenericNotifyFromISR+0xfa>
    4830:	89 89       	ldd	r24, Y+17	; 0x11
    4832:	9a 89       	ldd	r25, Y+18	; 0x12
    4834:	84 30       	cpi	r24, 0x04	; 4
    4836:	91 05       	cpc	r25, r1
    4838:	89 f1       	breq	.+98     	; 0x489c <xTaskGenericNotifyFromISR+0x110>
    483a:	3f c0       	rjmp	.+126    	; 0x48ba <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    483c:	ec 81       	ldd	r30, Y+4	; 0x04
    483e:	fd 81       	ldd	r31, Y+5	; 0x05
    4840:	26 8d       	ldd	r18, Z+30	; 0x1e
    4842:	37 8d       	ldd	r19, Z+31	; 0x1f
    4844:	40 a1       	ldd	r20, Z+32	; 0x20
    4846:	51 a1       	ldd	r21, Z+33	; 0x21
    4848:	88 85       	ldd	r24, Y+8	; 0x08
    484a:	99 85       	ldd	r25, Y+9	; 0x09
    484c:	aa 85       	ldd	r26, Y+10	; 0x0a
    484e:	bb 85       	ldd	r27, Y+11	; 0x0b
    4850:	82 2b       	or	r24, r18
    4852:	93 2b       	or	r25, r19
    4854:	a4 2b       	or	r26, r20
    4856:	b5 2b       	or	r27, r21
    4858:	ec 81       	ldd	r30, Y+4	; 0x04
    485a:	fd 81       	ldd	r31, Y+5	; 0x05
    485c:	86 8f       	std	Z+30, r24	; 0x1e
    485e:	97 8f       	std	Z+31, r25	; 0x1f
    4860:	a0 a3       	std	Z+32, r26	; 0x20
    4862:	b1 a3       	std	Z+33, r27	; 0x21
    4864:	2a c0       	rjmp	.+84     	; 0x48ba <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4866:	ec 81       	ldd	r30, Y+4	; 0x04
    4868:	fd 81       	ldd	r31, Y+5	; 0x05
    486a:	86 8d       	ldd	r24, Z+30	; 0x1e
    486c:	97 8d       	ldd	r25, Z+31	; 0x1f
    486e:	a0 a1       	ldd	r26, Z+32	; 0x20
    4870:	b1 a1       	ldd	r27, Z+33	; 0x21
    4872:	01 96       	adiw	r24, 0x01	; 1
    4874:	a1 1d       	adc	r26, r1
    4876:	b1 1d       	adc	r27, r1
    4878:	ec 81       	ldd	r30, Y+4	; 0x04
    487a:	fd 81       	ldd	r31, Y+5	; 0x05
    487c:	86 8f       	std	Z+30, r24	; 0x1e
    487e:	97 8f       	std	Z+31, r25	; 0x1f
    4880:	a0 a3       	std	Z+32, r26	; 0x20
    4882:	b1 a3       	std	Z+33, r27	; 0x21
    4884:	1a c0       	rjmp	.+52     	; 0x48ba <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4886:	ec 81       	ldd	r30, Y+4	; 0x04
    4888:	fd 81       	ldd	r31, Y+5	; 0x05
    488a:	88 85       	ldd	r24, Y+8	; 0x08
    488c:	99 85       	ldd	r25, Y+9	; 0x09
    488e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4890:	bb 85       	ldd	r27, Y+11	; 0x0b
    4892:	86 8f       	std	Z+30, r24	; 0x1e
    4894:	97 8f       	std	Z+31, r25	; 0x1f
    4896:	a0 a3       	std	Z+32, r26	; 0x20
    4898:	b1 a3       	std	Z+33, r27	; 0x21
    489a:	0f c0       	rjmp	.+30     	; 0x48ba <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    489c:	8b 81       	ldd	r24, Y+3	; 0x03
    489e:	82 30       	cpi	r24, 0x02	; 2
    48a0:	59 f0       	breq	.+22     	; 0x48b8 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    48a2:	ec 81       	ldd	r30, Y+4	; 0x04
    48a4:	fd 81       	ldd	r31, Y+5	; 0x05
    48a6:	88 85       	ldd	r24, Y+8	; 0x08
    48a8:	99 85       	ldd	r25, Y+9	; 0x09
    48aa:	aa 85       	ldd	r26, Y+10	; 0x0a
    48ac:	bb 85       	ldd	r27, Y+11	; 0x0b
    48ae:	86 8f       	std	Z+30, r24	; 0x1e
    48b0:	97 8f       	std	Z+31, r25	; 0x1f
    48b2:	a0 a3       	std	Z+32, r26	; 0x20
    48b4:	b1 a3       	std	Z+33, r27	; 0x21
    48b6:	01 c0       	rjmp	.+2      	; 0x48ba <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    48b8:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    48ba:	8b 81       	ldd	r24, Y+3	; 0x03
    48bc:	81 30       	cpi	r24, 0x01	; 1
    48be:	09 f0       	breq	.+2      	; 0x48c2 <xTaskGenericNotifyFromISR+0x136>
    48c0:	50 c0       	rjmp	.+160    	; 0x4962 <xTaskGenericNotifyFromISR+0x1d6>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    48c2:	80 91 3f 07 	lds	r24, 0x073F
    48c6:	88 23       	and	r24, r24
    48c8:	61 f5       	brne	.+88     	; 0x4922 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    48ca:	8c 81       	ldd	r24, Y+4	; 0x04
    48cc:	9d 81       	ldd	r25, Y+5	; 0x05
    48ce:	02 96       	adiw	r24, 0x02	; 2
    48d0:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    48d4:	ec 81       	ldd	r30, Y+4	; 0x04
    48d6:	fd 81       	ldd	r31, Y+5	; 0x05
    48d8:	96 89       	ldd	r25, Z+22	; 0x16
    48da:	80 91 35 07 	lds	r24, 0x0735
    48de:	89 17       	cp	r24, r25
    48e0:	28 f4       	brcc	.+10     	; 0x48ec <xTaskGenericNotifyFromISR+0x160>
    48e2:	ec 81       	ldd	r30, Y+4	; 0x04
    48e4:	fd 81       	ldd	r31, Y+5	; 0x05
    48e6:	86 89       	ldd	r24, Z+22	; 0x16
    48e8:	80 93 35 07 	sts	0x0735, r24
    48ec:	ec 81       	ldd	r30, Y+4	; 0x04
    48ee:	fd 81       	ldd	r31, Y+5	; 0x05
    48f0:	86 89       	ldd	r24, Z+22	; 0x16
    48f2:	28 2f       	mov	r18, r24
    48f4:	30 e0       	ldi	r19, 0x00	; 0
    48f6:	c9 01       	movw	r24, r18
    48f8:	88 0f       	add	r24, r24
    48fa:	99 1f       	adc	r25, r25
    48fc:	88 0f       	add	r24, r24
    48fe:	99 1f       	adc	r25, r25
    4900:	88 0f       	add	r24, r24
    4902:	99 1f       	adc	r25, r25
    4904:	82 0f       	add	r24, r18
    4906:	93 1f       	adc	r25, r19
    4908:	ac 01       	movw	r20, r24
    490a:	40 5c       	subi	r20, 0xC0	; 192
    490c:	58 4f       	sbci	r21, 0xF8	; 248
    490e:	8c 81       	ldd	r24, Y+4	; 0x04
    4910:	9d 81       	ldd	r25, Y+5	; 0x05
    4912:	9c 01       	movw	r18, r24
    4914:	2e 5f       	subi	r18, 0xFE	; 254
    4916:	3f 4f       	sbci	r19, 0xFF	; 255
    4918:	ca 01       	movw	r24, r20
    491a:	b9 01       	movw	r22, r18
    491c:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
    4920:	0a c0       	rjmp	.+20     	; 0x4936 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4922:	8c 81       	ldd	r24, Y+4	; 0x04
    4924:	9d 81       	ldd	r25, Y+5	; 0x05
    4926:	9c 01       	movw	r18, r24
    4928:	24 5f       	subi	r18, 0xF4	; 244
    492a:	3f 4f       	sbci	r19, 0xFF	; 255
    492c:	81 e7       	ldi	r24, 0x71	; 113
    492e:	97 e0       	ldi	r25, 0x07	; 7
    4930:	b9 01       	movw	r22, r18
    4932:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4936:	ec 81       	ldd	r30, Y+4	; 0x04
    4938:	fd 81       	ldd	r31, Y+5	; 0x05
    493a:	96 89       	ldd	r25, Z+22	; 0x16
    493c:	e0 91 30 07 	lds	r30, 0x0730
    4940:	f0 91 31 07 	lds	r31, 0x0731
    4944:	86 89       	ldd	r24, Z+22	; 0x16
    4946:	89 17       	cp	r24, r25
    4948:	60 f4       	brcc	.+24     	; 0x4962 <xTaskGenericNotifyFromISR+0x1d6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    494a:	8f 85       	ldd	r24, Y+15	; 0x0f
    494c:	98 89       	ldd	r25, Y+16	; 0x10
    494e:	00 97       	sbiw	r24, 0x00	; 0
    4950:	29 f0       	breq	.+10     	; 0x495c <xTaskGenericNotifyFromISR+0x1d0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4952:	ef 85       	ldd	r30, Y+15	; 0x0f
    4954:	f8 89       	ldd	r31, Y+16	; 0x10
    4956:	81 e0       	ldi	r24, 0x01	; 1
    4958:	80 83       	st	Z, r24
    495a:	03 c0       	rjmp	.+6      	; 0x4962 <xTaskGenericNotifyFromISR+0x1d6>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    495c:	81 e0       	ldi	r24, 0x01	; 1
    495e:	80 93 38 07 	sts	0x0738, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4962:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4964:	62 96       	adiw	r28, 0x12	; 18
    4966:	0f b6       	in	r0, 0x3f	; 63
    4968:	f8 94       	cli
    496a:	de bf       	out	0x3e, r29	; 62
    496c:	0f be       	out	0x3f, r0	; 63
    496e:	cd bf       	out	0x3d, r28	; 61
    4970:	cf 91       	pop	r28
    4972:	df 91       	pop	r29
    4974:	1f 91       	pop	r17
    4976:	0f 91       	pop	r16
    4978:	ff 90       	pop	r15
    497a:	ef 90       	pop	r14
    497c:	08 95       	ret

0000497e <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    497e:	df 93       	push	r29
    4980:	cf 93       	push	r28
    4982:	cd b7       	in	r28, 0x3d	; 61
    4984:	de b7       	in	r29, 0x3e	; 62
    4986:	28 97       	sbiw	r28, 0x08	; 8
    4988:	0f b6       	in	r0, 0x3f	; 63
    498a:	f8 94       	cli
    498c:	de bf       	out	0x3e, r29	; 62
    498e:	0f be       	out	0x3f, r0	; 63
    4990:	cd bf       	out	0x3d, r28	; 61
    4992:	9e 83       	std	Y+6, r25	; 0x06
    4994:	8d 83       	std	Y+5, r24	; 0x05
    4996:	78 87       	std	Y+8, r23	; 0x08
    4998:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    499a:	8d 81       	ldd	r24, Y+5	; 0x05
    499c:	9e 81       	ldd	r25, Y+6	; 0x06
    499e:	9c 83       	std	Y+4, r25	; 0x04
    49a0:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    49a2:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    49a4:	eb 81       	ldd	r30, Y+3	; 0x03
    49a6:	fc 81       	ldd	r31, Y+4	; 0x04
    49a8:	82 a1       	ldd	r24, Z+34	; 0x22
    49aa:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    49ac:	eb 81       	ldd	r30, Y+3	; 0x03
    49ae:	fc 81       	ldd	r31, Y+4	; 0x04
    49b0:	82 e0       	ldi	r24, 0x02	; 2
    49b2:	82 a3       	std	Z+34, r24	; 0x22

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    49b4:	eb 81       	ldd	r30, Y+3	; 0x03
    49b6:	fc 81       	ldd	r31, Y+4	; 0x04
    49b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    49ba:	97 8d       	ldd	r25, Z+31	; 0x1f
    49bc:	a0 a1       	ldd	r26, Z+32	; 0x20
    49be:	b1 a1       	ldd	r27, Z+33	; 0x21
    49c0:	01 96       	adiw	r24, 0x01	; 1
    49c2:	a1 1d       	adc	r26, r1
    49c4:	b1 1d       	adc	r27, r1
    49c6:	eb 81       	ldd	r30, Y+3	; 0x03
    49c8:	fc 81       	ldd	r31, Y+4	; 0x04
    49ca:	86 8f       	std	Z+30, r24	; 0x1e
    49cc:	97 8f       	std	Z+31, r25	; 0x1f
    49ce:	a0 a3       	std	Z+32, r26	; 0x20
    49d0:	b1 a3       	std	Z+33, r27	; 0x21

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    49d2:	8a 81       	ldd	r24, Y+2	; 0x02
    49d4:	81 30       	cpi	r24, 0x01	; 1
    49d6:	09 f0       	breq	.+2      	; 0x49da <vTaskNotifyGiveFromISR+0x5c>
    49d8:	50 c0       	rjmp	.+160    	; 0x4a7a <vTaskNotifyGiveFromISR+0xfc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    49da:	80 91 3f 07 	lds	r24, 0x073F
    49de:	88 23       	and	r24, r24
    49e0:	61 f5       	brne	.+88     	; 0x4a3a <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    49e2:	8b 81       	ldd	r24, Y+3	; 0x03
    49e4:	9c 81       	ldd	r25, Y+4	; 0x04
    49e6:	02 96       	adiw	r24, 0x02	; 2
    49e8:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    49ec:	eb 81       	ldd	r30, Y+3	; 0x03
    49ee:	fc 81       	ldd	r31, Y+4	; 0x04
    49f0:	96 89       	ldd	r25, Z+22	; 0x16
    49f2:	80 91 35 07 	lds	r24, 0x0735
    49f6:	89 17       	cp	r24, r25
    49f8:	28 f4       	brcc	.+10     	; 0x4a04 <vTaskNotifyGiveFromISR+0x86>
    49fa:	eb 81       	ldd	r30, Y+3	; 0x03
    49fc:	fc 81       	ldd	r31, Y+4	; 0x04
    49fe:	86 89       	ldd	r24, Z+22	; 0x16
    4a00:	80 93 35 07 	sts	0x0735, r24
    4a04:	eb 81       	ldd	r30, Y+3	; 0x03
    4a06:	fc 81       	ldd	r31, Y+4	; 0x04
    4a08:	86 89       	ldd	r24, Z+22	; 0x16
    4a0a:	28 2f       	mov	r18, r24
    4a0c:	30 e0       	ldi	r19, 0x00	; 0
    4a0e:	c9 01       	movw	r24, r18
    4a10:	88 0f       	add	r24, r24
    4a12:	99 1f       	adc	r25, r25
    4a14:	88 0f       	add	r24, r24
    4a16:	99 1f       	adc	r25, r25
    4a18:	88 0f       	add	r24, r24
    4a1a:	99 1f       	adc	r25, r25
    4a1c:	82 0f       	add	r24, r18
    4a1e:	93 1f       	adc	r25, r19
    4a20:	ac 01       	movw	r20, r24
    4a22:	40 5c       	subi	r20, 0xC0	; 192
    4a24:	58 4f       	sbci	r21, 0xF8	; 248
    4a26:	8b 81       	ldd	r24, Y+3	; 0x03
    4a28:	9c 81       	ldd	r25, Y+4	; 0x04
    4a2a:	9c 01       	movw	r18, r24
    4a2c:	2e 5f       	subi	r18, 0xFE	; 254
    4a2e:	3f 4f       	sbci	r19, 0xFF	; 255
    4a30:	ca 01       	movw	r24, r20
    4a32:	b9 01       	movw	r22, r18
    4a34:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
    4a38:	0a c0       	rjmp	.+20     	; 0x4a4e <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4a3a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a3c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a3e:	9c 01       	movw	r18, r24
    4a40:	24 5f       	subi	r18, 0xF4	; 244
    4a42:	3f 4f       	sbci	r19, 0xFF	; 255
    4a44:	81 e7       	ldi	r24, 0x71	; 113
    4a46:	97 e0       	ldi	r25, 0x07	; 7
    4a48:	b9 01       	movw	r22, r18
    4a4a:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4a4e:	eb 81       	ldd	r30, Y+3	; 0x03
    4a50:	fc 81       	ldd	r31, Y+4	; 0x04
    4a52:	96 89       	ldd	r25, Z+22	; 0x16
    4a54:	e0 91 30 07 	lds	r30, 0x0730
    4a58:	f0 91 31 07 	lds	r31, 0x0731
    4a5c:	86 89       	ldd	r24, Z+22	; 0x16
    4a5e:	89 17       	cp	r24, r25
    4a60:	60 f4       	brcc	.+24     	; 0x4a7a <vTaskNotifyGiveFromISR+0xfc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4a62:	8f 81       	ldd	r24, Y+7	; 0x07
    4a64:	98 85       	ldd	r25, Y+8	; 0x08
    4a66:	00 97       	sbiw	r24, 0x00	; 0
    4a68:	29 f0       	breq	.+10     	; 0x4a74 <vTaskNotifyGiveFromISR+0xf6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4a6a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a6c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a6e:	81 e0       	ldi	r24, 0x01	; 1
    4a70:	80 83       	st	Z, r24
    4a72:	03 c0       	rjmp	.+6      	; 0x4a7a <vTaskNotifyGiveFromISR+0xfc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    4a74:	81 e0       	ldi	r24, 0x01	; 1
    4a76:	80 93 38 07 	sts	0x0738, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4a7a:	28 96       	adiw	r28, 0x08	; 8
    4a7c:	0f b6       	in	r0, 0x3f	; 63
    4a7e:	f8 94       	cli
    4a80:	de bf       	out	0x3e, r29	; 62
    4a82:	0f be       	out	0x3f, r0	; 63
    4a84:	cd bf       	out	0x3d, r28	; 61
    4a86:	cf 91       	pop	r28
    4a88:	df 91       	pop	r29
    4a8a:	08 95       	ret

00004a8c <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    4a8c:	df 93       	push	r29
    4a8e:	cf 93       	push	r28
    4a90:	cd b7       	in	r28, 0x3d	; 61
    4a92:	de b7       	in	r29, 0x3e	; 62
    4a94:	27 97       	sbiw	r28, 0x07	; 7
    4a96:	0f b6       	in	r0, 0x3f	; 63
    4a98:	f8 94       	cli
    4a9a:	de bf       	out	0x3e, r29	; 62
    4a9c:	0f be       	out	0x3f, r0	; 63
    4a9e:	cd bf       	out	0x3d, r28	; 61
    4aa0:	9d 83       	std	Y+5, r25	; 0x05
    4aa2:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4aa4:	8c 81       	ldd	r24, Y+4	; 0x04
    4aa6:	9d 81       	ldd	r25, Y+5	; 0x05
    4aa8:	00 97       	sbiw	r24, 0x00	; 0
    4aaa:	39 f4       	brne	.+14     	; 0x4aba <xTaskNotifyStateClear+0x2e>
    4aac:	80 91 30 07 	lds	r24, 0x0730
    4ab0:	90 91 31 07 	lds	r25, 0x0731
    4ab4:	9f 83       	std	Y+7, r25	; 0x07
    4ab6:	8e 83       	std	Y+6, r24	; 0x06
    4ab8:	04 c0       	rjmp	.+8      	; 0x4ac2 <xTaskNotifyStateClear+0x36>
    4aba:	8c 81       	ldd	r24, Y+4	; 0x04
    4abc:	9d 81       	ldd	r25, Y+5	; 0x05
    4abe:	9f 83       	std	Y+7, r25	; 0x07
    4ac0:	8e 83       	std	Y+6, r24	; 0x06
    4ac2:	8e 81       	ldd	r24, Y+6	; 0x06
    4ac4:	9f 81       	ldd	r25, Y+7	; 0x07
    4ac6:	9b 83       	std	Y+3, r25	; 0x03
    4ac8:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4aca:	0f b6       	in	r0, 0x3f	; 63
    4acc:	f8 94       	cli
    4ace:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    4ad0:	ea 81       	ldd	r30, Y+2	; 0x02
    4ad2:	fb 81       	ldd	r31, Y+3	; 0x03
    4ad4:	82 a1       	ldd	r24, Z+34	; 0x22
    4ad6:	82 30       	cpi	r24, 0x02	; 2
    4ad8:	31 f4       	brne	.+12     	; 0x4ae6 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4ada:	ea 81       	ldd	r30, Y+2	; 0x02
    4adc:	fb 81       	ldd	r31, Y+3	; 0x03
    4ade:	12 a2       	std	Z+34, r1	; 0x22
				xReturn = pdPASS;
    4ae0:	81 e0       	ldi	r24, 0x01	; 1
    4ae2:	89 83       	std	Y+1, r24	; 0x01
    4ae4:	01 c0       	rjmp	.+2      	; 0x4ae8 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    4ae6:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    4ae8:	0f 90       	pop	r0
    4aea:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4aec:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4aee:	27 96       	adiw	r28, 0x07	; 7
    4af0:	0f b6       	in	r0, 0x3f	; 63
    4af2:	f8 94       	cli
    4af4:	de bf       	out	0x3e, r29	; 62
    4af6:	0f be       	out	0x3f, r0	; 63
    4af8:	cd bf       	out	0x3d, r28	; 61
    4afa:	cf 91       	pop	r28
    4afc:	df 91       	pop	r29
    4afe:	08 95       	ret

00004b00 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    4b00:	df 93       	push	r29
    4b02:	cf 93       	push	r28
    4b04:	cd b7       	in	r28, 0x3d	; 61
    4b06:	de b7       	in	r29, 0x3e	; 62
    4b08:	27 97       	sbiw	r28, 0x07	; 7
    4b0a:	0f b6       	in	r0, 0x3f	; 63
    4b0c:	f8 94       	cli
    4b0e:	de bf       	out	0x3e, r29	; 62
    4b10:	0f be       	out	0x3f, r0	; 63
    4b12:	cd bf       	out	0x3d, r28	; 61
    4b14:	9e 83       	std	Y+6, r25	; 0x06
    4b16:	8d 83       	std	Y+5, r24	; 0x05
    4b18:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    4b1a:	80 91 33 07 	lds	r24, 0x0733
    4b1e:	90 91 34 07 	lds	r25, 0x0734
    4b22:	9a 83       	std	Y+2, r25	; 0x02
    4b24:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4b26:	80 91 30 07 	lds	r24, 0x0730
    4b2a:	90 91 31 07 	lds	r25, 0x0731
    4b2e:	02 96       	adiw	r24, 0x02	; 2
    4b30:	0e 94 67 0e 	call	0x1cce	; 0x1cce <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    4b34:	8d 81       	ldd	r24, Y+5	; 0x05
    4b36:	9e 81       	ldd	r25, Y+6	; 0x06
    4b38:	2f ef       	ldi	r18, 0xFF	; 255
    4b3a:	8f 3f       	cpi	r24, 0xFF	; 255
    4b3c:	92 07       	cpc	r25, r18
    4b3e:	81 f4       	brne	.+32     	; 0x4b60 <prvAddCurrentTaskToDelayedList+0x60>
    4b40:	8f 81       	ldd	r24, Y+7	; 0x07
    4b42:	88 23       	and	r24, r24
    4b44:	69 f0       	breq	.+26     	; 0x4b60 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4b46:	80 91 30 07 	lds	r24, 0x0730
    4b4a:	90 91 31 07 	lds	r25, 0x0731
    4b4e:	9c 01       	movw	r18, r24
    4b50:	2e 5f       	subi	r18, 0xFE	; 254
    4b52:	3f 4f       	sbci	r19, 0xFF	; 255
    4b54:	8a e7       	ldi	r24, 0x7A	; 122
    4b56:	97 e0       	ldi	r25, 0x07	; 7
    4b58:	b9 01       	movw	r22, r18
    4b5a:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vListInsertEnd>
    4b5e:	43 c0       	rjmp	.+134    	; 0x4be6 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    4b60:	29 81       	ldd	r18, Y+1	; 0x01
    4b62:	3a 81       	ldd	r19, Y+2	; 0x02
    4b64:	8d 81       	ldd	r24, Y+5	; 0x05
    4b66:	9e 81       	ldd	r25, Y+6	; 0x06
    4b68:	82 0f       	add	r24, r18
    4b6a:	93 1f       	adc	r25, r19
    4b6c:	9c 83       	std	Y+4, r25	; 0x04
    4b6e:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4b70:	e0 91 30 07 	lds	r30, 0x0730
    4b74:	f0 91 31 07 	lds	r31, 0x0731
    4b78:	8b 81       	ldd	r24, Y+3	; 0x03
    4b7a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b7c:	93 83       	std	Z+3, r25	; 0x03
    4b7e:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    4b80:	2b 81       	ldd	r18, Y+3	; 0x03
    4b82:	3c 81       	ldd	r19, Y+4	; 0x04
    4b84:	89 81       	ldd	r24, Y+1	; 0x01
    4b86:	9a 81       	ldd	r25, Y+2	; 0x02
    4b88:	28 17       	cp	r18, r24
    4b8a:	39 07       	cpc	r19, r25
    4b8c:	70 f4       	brcc	.+28     	; 0x4baa <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4b8e:	80 91 6f 07 	lds	r24, 0x076F
    4b92:	90 91 70 07 	lds	r25, 0x0770
    4b96:	20 91 30 07 	lds	r18, 0x0730
    4b9a:	30 91 31 07 	lds	r19, 0x0731
    4b9e:	2e 5f       	subi	r18, 0xFE	; 254
    4ba0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ba2:	b9 01       	movw	r22, r18
    4ba4:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <vListInsert>
    4ba8:	1e c0       	rjmp	.+60     	; 0x4be6 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4baa:	40 91 6d 07 	lds	r20, 0x076D
    4bae:	50 91 6e 07 	lds	r21, 0x076E
    4bb2:	80 91 30 07 	lds	r24, 0x0730
    4bb6:	90 91 31 07 	lds	r25, 0x0731
    4bba:	9c 01       	movw	r18, r24
    4bbc:	2e 5f       	subi	r18, 0xFE	; 254
    4bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    4bc0:	ca 01       	movw	r24, r20
    4bc2:	b9 01       	movw	r22, r18
    4bc4:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    4bc8:	20 91 3b 07 	lds	r18, 0x073B
    4bcc:	30 91 3c 07 	lds	r19, 0x073C
    4bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    4bd4:	82 17       	cp	r24, r18
    4bd6:	93 07       	cpc	r25, r19
    4bd8:	30 f4       	brcc	.+12     	; 0x4be6 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    4bda:	8b 81       	ldd	r24, Y+3	; 0x03
    4bdc:	9c 81       	ldd	r25, Y+4	; 0x04
    4bde:	90 93 3c 07 	sts	0x073C, r25
    4be2:	80 93 3b 07 	sts	0x073B, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4be6:	27 96       	adiw	r28, 0x07	; 7
    4be8:	0f b6       	in	r0, 0x3f	; 63
    4bea:	f8 94       	cli
    4bec:	de bf       	out	0x3e, r29	; 62
    4bee:	0f be       	out	0x3f, r0	; 63
    4bf0:	cd bf       	out	0x3d, r28	; 61
    4bf2:	cf 91       	pop	r28
    4bf4:	df 91       	pop	r29
    4bf6:	08 95       	ret

00004bf8 <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
    4bf8:	df 93       	push	r29
    4bfa:	cf 93       	push	r28
    4bfc:	cd b7       	in	r28, 0x3d	; 61
    4bfe:	de b7       	in	r29, 0x3e	; 62
    4c00:	2e 97       	sbiw	r28, 0x0e	; 14
    4c02:	0f b6       	in	r0, 0x3f	; 63
    4c04:	f8 94       	cli
    4c06:	de bf       	out	0x3e, r29	; 62
    4c08:	0f be       	out	0x3f, r0	; 63
    4c0a:	cd bf       	out	0x3d, r28	; 61
  /* Configure the direction for RS and E pins as output pins */
  GPIO_setupPinDirection(LCD_RS_PORT_ID, LCD_RS_PIN_ID, PIN_OUTPUT);
    4c0c:	82 e0       	ldi	r24, 0x02	; 2
    4c0e:	60 e0       	ldi	r22, 0x00	; 0
    4c10:	41 e0       	ldi	r20, 0x01	; 1
    4c12:	0e 94 25 08 	call	0x104a	; 0x104a <GPIO_setupPinDirection>
  GPIO_setupPinDirection(LCD_E_PORT_ID, LCD_E_PIN_ID, PIN_OUTPUT);
    4c16:	82 e0       	ldi	r24, 0x02	; 2
    4c18:	61 e0       	ldi	r22, 0x01	; 1
    4c1a:	41 e0       	ldi	r20, 0x01	; 1
    4c1c:	0e 94 25 08 	call	0x104a	; 0x104a <GPIO_setupPinDirection>
    4c20:	80 e0       	ldi	r24, 0x00	; 0
    4c22:	90 e0       	ldi	r25, 0x00	; 0
    4c24:	a0 ea       	ldi	r26, 0xA0	; 160
    4c26:	b1 e4       	ldi	r27, 0x41	; 65
    4c28:	8b 87       	std	Y+11, r24	; 0x0b
    4c2a:	9c 87       	std	Y+12, r25	; 0x0c
    4c2c:	ad 87       	std	Y+13, r26	; 0x0d
    4c2e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4c30:	6b 85       	ldd	r22, Y+11	; 0x0b
    4c32:	7c 85       	ldd	r23, Y+12	; 0x0c
    4c34:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c36:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c38:	20 e0       	ldi	r18, 0x00	; 0
    4c3a:	30 e0       	ldi	r19, 0x00	; 0
    4c3c:	4a ef       	ldi	r20, 0xFA	; 250
    4c3e:	54 e4       	ldi	r21, 0x44	; 68
    4c40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c44:	dc 01       	movw	r26, r24
    4c46:	cb 01       	movw	r24, r22
    4c48:	8f 83       	std	Y+7, r24	; 0x07
    4c4a:	98 87       	std	Y+8, r25	; 0x08
    4c4c:	a9 87       	std	Y+9, r26	; 0x09
    4c4e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4c50:	6f 81       	ldd	r22, Y+7	; 0x07
    4c52:	78 85       	ldd	r23, Y+8	; 0x08
    4c54:	89 85       	ldd	r24, Y+9	; 0x09
    4c56:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c58:	20 e0       	ldi	r18, 0x00	; 0
    4c5a:	30 e0       	ldi	r19, 0x00	; 0
    4c5c:	40 e8       	ldi	r20, 0x80	; 128
    4c5e:	5f e3       	ldi	r21, 0x3F	; 63
    4c60:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4c64:	88 23       	and	r24, r24
    4c66:	2c f4       	brge	.+10     	; 0x4c72 <LCD_init+0x7a>
		__ticks = 1;
    4c68:	81 e0       	ldi	r24, 0x01	; 1
    4c6a:	90 e0       	ldi	r25, 0x00	; 0
    4c6c:	9e 83       	std	Y+6, r25	; 0x06
    4c6e:	8d 83       	std	Y+5, r24	; 0x05
    4c70:	3f c0       	rjmp	.+126    	; 0x4cf0 <LCD_init+0xf8>
	else if (__tmp > 65535)
    4c72:	6f 81       	ldd	r22, Y+7	; 0x07
    4c74:	78 85       	ldd	r23, Y+8	; 0x08
    4c76:	89 85       	ldd	r24, Y+9	; 0x09
    4c78:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c7a:	20 e0       	ldi	r18, 0x00	; 0
    4c7c:	3f ef       	ldi	r19, 0xFF	; 255
    4c7e:	4f e7       	ldi	r20, 0x7F	; 127
    4c80:	57 e4       	ldi	r21, 0x47	; 71
    4c82:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4c86:	18 16       	cp	r1, r24
    4c88:	4c f5       	brge	.+82     	; 0x4cdc <LCD_init+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4c8a:	6b 85       	ldd	r22, Y+11	; 0x0b
    4c8c:	7c 85       	ldd	r23, Y+12	; 0x0c
    4c8e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c90:	9e 85       	ldd	r25, Y+14	; 0x0e
    4c92:	20 e0       	ldi	r18, 0x00	; 0
    4c94:	30 e0       	ldi	r19, 0x00	; 0
    4c96:	40 e2       	ldi	r20, 0x20	; 32
    4c98:	51 e4       	ldi	r21, 0x41	; 65
    4c9a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c9e:	dc 01       	movw	r26, r24
    4ca0:	cb 01       	movw	r24, r22
    4ca2:	bc 01       	movw	r22, r24
    4ca4:	cd 01       	movw	r24, r26
    4ca6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4caa:	dc 01       	movw	r26, r24
    4cac:	cb 01       	movw	r24, r22
    4cae:	9e 83       	std	Y+6, r25	; 0x06
    4cb0:	8d 83       	std	Y+5, r24	; 0x05
    4cb2:	0f c0       	rjmp	.+30     	; 0x4cd2 <LCD_init+0xda>
    4cb4:	88 ec       	ldi	r24, 0xC8	; 200
    4cb6:	90 e0       	ldi	r25, 0x00	; 0
    4cb8:	9c 83       	std	Y+4, r25	; 0x04
    4cba:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    4cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    4cc0:	01 97       	sbiw	r24, 0x01	; 1
    4cc2:	f1 f7       	brne	.-4      	; 0x4cc0 <LCD_init+0xc8>
    4cc4:	9c 83       	std	Y+4, r25	; 0x04
    4cc6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4cc8:	8d 81       	ldd	r24, Y+5	; 0x05
    4cca:	9e 81       	ldd	r25, Y+6	; 0x06
    4ccc:	01 97       	sbiw	r24, 0x01	; 1
    4cce:	9e 83       	std	Y+6, r25	; 0x06
    4cd0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4cd2:	8d 81       	ldd	r24, Y+5	; 0x05
    4cd4:	9e 81       	ldd	r25, Y+6	; 0x06
    4cd6:	00 97       	sbiw	r24, 0x00	; 0
    4cd8:	69 f7       	brne	.-38     	; 0x4cb4 <LCD_init+0xbc>
    4cda:	14 c0       	rjmp	.+40     	; 0x4d04 <LCD_init+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4cdc:	6f 81       	ldd	r22, Y+7	; 0x07
    4cde:	78 85       	ldd	r23, Y+8	; 0x08
    4ce0:	89 85       	ldd	r24, Y+9	; 0x09
    4ce2:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ce4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4ce8:	dc 01       	movw	r26, r24
    4cea:	cb 01       	movw	r24, r22
    4cec:	9e 83       	std	Y+6, r25	; 0x06
    4cee:	8d 83       	std	Y+5, r24	; 0x05
    4cf0:	8d 81       	ldd	r24, Y+5	; 0x05
    4cf2:	9e 81       	ldd	r25, Y+6	; 0x06
    4cf4:	9a 83       	std	Y+2, r25	; 0x02
    4cf6:	89 83       	std	Y+1, r24	; 0x01
    4cf8:	89 81       	ldd	r24, Y+1	; 0x01
    4cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    4cfc:	01 97       	sbiw	r24, 0x01	; 1
    4cfe:	f1 f7       	brne	.-4      	; 0x4cfc <LCD_init+0x104>
    4d00:	9a 83       	std	Y+2, r25	; 0x02
    4d02:	89 83       	std	Y+1, r24	; 0x01
	/* use 2-lines LCD + 4-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE);

#elif(LCD_DATA_BITS_MODE == 8)
  /* Configure the data port as output port */
  GPIO_setupPortDirection(LCD_DATA_PORT_ID, PORT_OUTPUT);
    4d04:	80 e0       	ldi	r24, 0x00	; 0
    4d06:	6f ef       	ldi	r22, 0xFF	; 255
    4d08:	0e 94 14 0b 	call	0x1628	; 0x1628 <GPIO_setupPortDirection>

  /* use 2-lines LCD + 8-bits Data Mode + 5*7 dot display Mode */
  LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE);
    4d0c:	88 e3       	ldi	r24, 0x38	; 56
    4d0e:	0e 94 98 26 	call	0x4d30	; 0x4d30 <LCD_sendCommand>

#endif

  LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
    4d12:	8c e0       	ldi	r24, 0x0C	; 12
    4d14:	0e 94 98 26 	call	0x4d30	; 0x4d30 <LCD_sendCommand>
  LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
    4d18:	81 e0       	ldi	r24, 0x01	; 1
    4d1a:	0e 94 98 26 	call	0x4d30	; 0x4d30 <LCD_sendCommand>
}
    4d1e:	2e 96       	adiw	r28, 0x0e	; 14
    4d20:	0f b6       	in	r0, 0x3f	; 63
    4d22:	f8 94       	cli
    4d24:	de bf       	out	0x3e, r29	; 62
    4d26:	0f be       	out	0x3f, r0	; 63
    4d28:	cd bf       	out	0x3d, r28	; 61
    4d2a:	cf 91       	pop	r28
    4d2c:	df 91       	pop	r29
    4d2e:	08 95       	ret

00004d30 <LCD_sendCommand>:
 * Description: Sends the specified command to the LCD.
 *
 * @param command: The command to be sent.
 */
void LCD_sendCommand(uint8 command)
{
    4d30:	df 93       	push	r29
    4d32:	cf 93       	push	r28
    4d34:	cd b7       	in	r28, 0x3d	; 61
    4d36:	de b7       	in	r29, 0x3e	; 62
    4d38:	e9 97       	sbiw	r28, 0x39	; 57
    4d3a:	0f b6       	in	r0, 0x3f	; 63
    4d3c:	f8 94       	cli
    4d3e:	de bf       	out	0x3e, r29	; 62
    4d40:	0f be       	out	0x3f, r0	; 63
    4d42:	cd bf       	out	0x3d, r28	; 61
    4d44:	89 af       	std	Y+57, r24	; 0x39
  GPIO_writePin(LCD_RS_PORT_ID, LCD_RS_PIN_ID, LOGIC_LOW); /* Instruction Mode RS=0 */
    4d46:	82 e0       	ldi	r24, 0x02	; 2
    4d48:	60 e0       	ldi	r22, 0x00	; 0
    4d4a:	40 e0       	ldi	r20, 0x00	; 0
    4d4c:	0e 94 10 09 	call	0x1220	; 0x1220 <GPIO_writePin>
    4d50:	80 e0       	ldi	r24, 0x00	; 0
    4d52:	90 e0       	ldi	r25, 0x00	; 0
    4d54:	a0 e8       	ldi	r26, 0x80	; 128
    4d56:	bf e3       	ldi	r27, 0x3F	; 63
    4d58:	8d ab       	std	Y+53, r24	; 0x35
    4d5a:	9e ab       	std	Y+54, r25	; 0x36
    4d5c:	af ab       	std	Y+55, r26	; 0x37
    4d5e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4d60:	6d a9       	ldd	r22, Y+53	; 0x35
    4d62:	7e a9       	ldd	r23, Y+54	; 0x36
    4d64:	8f a9       	ldd	r24, Y+55	; 0x37
    4d66:	98 ad       	ldd	r25, Y+56	; 0x38
    4d68:	20 e0       	ldi	r18, 0x00	; 0
    4d6a:	30 e0       	ldi	r19, 0x00	; 0
    4d6c:	4a ef       	ldi	r20, 0xFA	; 250
    4d6e:	54 e4       	ldi	r21, 0x44	; 68
    4d70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d74:	dc 01       	movw	r26, r24
    4d76:	cb 01       	movw	r24, r22
    4d78:	89 ab       	std	Y+49, r24	; 0x31
    4d7a:	9a ab       	std	Y+50, r25	; 0x32
    4d7c:	ab ab       	std	Y+51, r26	; 0x33
    4d7e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    4d80:	69 a9       	ldd	r22, Y+49	; 0x31
    4d82:	7a a9       	ldd	r23, Y+50	; 0x32
    4d84:	8b a9       	ldd	r24, Y+51	; 0x33
    4d86:	9c a9       	ldd	r25, Y+52	; 0x34
    4d88:	20 e0       	ldi	r18, 0x00	; 0
    4d8a:	30 e0       	ldi	r19, 0x00	; 0
    4d8c:	40 e8       	ldi	r20, 0x80	; 128
    4d8e:	5f e3       	ldi	r21, 0x3F	; 63
    4d90:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4d94:	88 23       	and	r24, r24
    4d96:	2c f4       	brge	.+10     	; 0x4da2 <LCD_sendCommand+0x72>
		__ticks = 1;
    4d98:	81 e0       	ldi	r24, 0x01	; 1
    4d9a:	90 e0       	ldi	r25, 0x00	; 0
    4d9c:	98 ab       	std	Y+48, r25	; 0x30
    4d9e:	8f a7       	std	Y+47, r24	; 0x2f
    4da0:	3f c0       	rjmp	.+126    	; 0x4e20 <LCD_sendCommand+0xf0>
	else if (__tmp > 65535)
    4da2:	69 a9       	ldd	r22, Y+49	; 0x31
    4da4:	7a a9       	ldd	r23, Y+50	; 0x32
    4da6:	8b a9       	ldd	r24, Y+51	; 0x33
    4da8:	9c a9       	ldd	r25, Y+52	; 0x34
    4daa:	20 e0       	ldi	r18, 0x00	; 0
    4dac:	3f ef       	ldi	r19, 0xFF	; 255
    4dae:	4f e7       	ldi	r20, 0x7F	; 127
    4db0:	57 e4       	ldi	r21, 0x47	; 71
    4db2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4db6:	18 16       	cp	r1, r24
    4db8:	4c f5       	brge	.+82     	; 0x4e0c <LCD_sendCommand+0xdc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4dba:	6d a9       	ldd	r22, Y+53	; 0x35
    4dbc:	7e a9       	ldd	r23, Y+54	; 0x36
    4dbe:	8f a9       	ldd	r24, Y+55	; 0x37
    4dc0:	98 ad       	ldd	r25, Y+56	; 0x38
    4dc2:	20 e0       	ldi	r18, 0x00	; 0
    4dc4:	30 e0       	ldi	r19, 0x00	; 0
    4dc6:	40 e2       	ldi	r20, 0x20	; 32
    4dc8:	51 e4       	ldi	r21, 0x41	; 65
    4dca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4dce:	dc 01       	movw	r26, r24
    4dd0:	cb 01       	movw	r24, r22
    4dd2:	bc 01       	movw	r22, r24
    4dd4:	cd 01       	movw	r24, r26
    4dd6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4dda:	dc 01       	movw	r26, r24
    4ddc:	cb 01       	movw	r24, r22
    4dde:	98 ab       	std	Y+48, r25	; 0x30
    4de0:	8f a7       	std	Y+47, r24	; 0x2f
    4de2:	0f c0       	rjmp	.+30     	; 0x4e02 <LCD_sendCommand+0xd2>
    4de4:	88 ec       	ldi	r24, 0xC8	; 200
    4de6:	90 e0       	ldi	r25, 0x00	; 0
    4de8:	9e a7       	std	Y+46, r25	; 0x2e
    4dea:	8d a7       	std	Y+45, r24	; 0x2d
    4dec:	8d a5       	ldd	r24, Y+45	; 0x2d
    4dee:	9e a5       	ldd	r25, Y+46	; 0x2e
    4df0:	01 97       	sbiw	r24, 0x01	; 1
    4df2:	f1 f7       	brne	.-4      	; 0x4df0 <LCD_sendCommand+0xc0>
    4df4:	9e a7       	std	Y+46, r25	; 0x2e
    4df6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4df8:	8f a5       	ldd	r24, Y+47	; 0x2f
    4dfa:	98 a9       	ldd	r25, Y+48	; 0x30
    4dfc:	01 97       	sbiw	r24, 0x01	; 1
    4dfe:	98 ab       	std	Y+48, r25	; 0x30
    4e00:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4e02:	8f a5       	ldd	r24, Y+47	; 0x2f
    4e04:	98 a9       	ldd	r25, Y+48	; 0x30
    4e06:	00 97       	sbiw	r24, 0x00	; 0
    4e08:	69 f7       	brne	.-38     	; 0x4de4 <LCD_sendCommand+0xb4>
    4e0a:	14 c0       	rjmp	.+40     	; 0x4e34 <LCD_sendCommand+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4e0c:	69 a9       	ldd	r22, Y+49	; 0x31
    4e0e:	7a a9       	ldd	r23, Y+50	; 0x32
    4e10:	8b a9       	ldd	r24, Y+51	; 0x33
    4e12:	9c a9       	ldd	r25, Y+52	; 0x34
    4e14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4e18:	dc 01       	movw	r26, r24
    4e1a:	cb 01       	movw	r24, r22
    4e1c:	98 ab       	std	Y+48, r25	; 0x30
    4e1e:	8f a7       	std	Y+47, r24	; 0x2f
    4e20:	8f a5       	ldd	r24, Y+47	; 0x2f
    4e22:	98 a9       	ldd	r25, Y+48	; 0x30
    4e24:	9c a7       	std	Y+44, r25	; 0x2c
    4e26:	8b a7       	std	Y+43, r24	; 0x2b
    4e28:	8b a5       	ldd	r24, Y+43	; 0x2b
    4e2a:	9c a5       	ldd	r25, Y+44	; 0x2c
    4e2c:	01 97       	sbiw	r24, 0x01	; 1
    4e2e:	f1 f7       	brne	.-4      	; 0x4e2c <LCD_sendCommand+0xfc>
    4e30:	9c a7       	std	Y+44, r25	; 0x2c
    4e32:	8b a7       	std	Y+43, r24	; 0x2b
  _delay_ms(1); /* delay for processing Tas = 50ns */
  GPIO_writePin(LCD_E_PORT_ID, LCD_E_PIN_ID, LOGIC_HIGH); /* Enable LCD E=1 */
    4e34:	82 e0       	ldi	r24, 0x02	; 2
    4e36:	61 e0       	ldi	r22, 0x01	; 1
    4e38:	41 e0       	ldi	r20, 0x01	; 1
    4e3a:	0e 94 10 09 	call	0x1220	; 0x1220 <GPIO_writePin>
    4e3e:	80 e0       	ldi	r24, 0x00	; 0
    4e40:	90 e0       	ldi	r25, 0x00	; 0
    4e42:	a0 e8       	ldi	r26, 0x80	; 128
    4e44:	bf e3       	ldi	r27, 0x3F	; 63
    4e46:	8f a3       	std	Y+39, r24	; 0x27
    4e48:	98 a7       	std	Y+40, r25	; 0x28
    4e4a:	a9 a7       	std	Y+41, r26	; 0x29
    4e4c:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4e4e:	6f a1       	ldd	r22, Y+39	; 0x27
    4e50:	78 a5       	ldd	r23, Y+40	; 0x28
    4e52:	89 a5       	ldd	r24, Y+41	; 0x29
    4e54:	9a a5       	ldd	r25, Y+42	; 0x2a
    4e56:	20 e0       	ldi	r18, 0x00	; 0
    4e58:	30 e0       	ldi	r19, 0x00	; 0
    4e5a:	4a ef       	ldi	r20, 0xFA	; 250
    4e5c:	54 e4       	ldi	r21, 0x44	; 68
    4e5e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e62:	dc 01       	movw	r26, r24
    4e64:	cb 01       	movw	r24, r22
    4e66:	8b a3       	std	Y+35, r24	; 0x23
    4e68:	9c a3       	std	Y+36, r25	; 0x24
    4e6a:	ad a3       	std	Y+37, r26	; 0x25
    4e6c:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    4e6e:	6b a1       	ldd	r22, Y+35	; 0x23
    4e70:	7c a1       	ldd	r23, Y+36	; 0x24
    4e72:	8d a1       	ldd	r24, Y+37	; 0x25
    4e74:	9e a1       	ldd	r25, Y+38	; 0x26
    4e76:	20 e0       	ldi	r18, 0x00	; 0
    4e78:	30 e0       	ldi	r19, 0x00	; 0
    4e7a:	40 e8       	ldi	r20, 0x80	; 128
    4e7c:	5f e3       	ldi	r21, 0x3F	; 63
    4e7e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4e82:	88 23       	and	r24, r24
    4e84:	2c f4       	brge	.+10     	; 0x4e90 <LCD_sendCommand+0x160>
		__ticks = 1;
    4e86:	81 e0       	ldi	r24, 0x01	; 1
    4e88:	90 e0       	ldi	r25, 0x00	; 0
    4e8a:	9a a3       	std	Y+34, r25	; 0x22
    4e8c:	89 a3       	std	Y+33, r24	; 0x21
    4e8e:	3f c0       	rjmp	.+126    	; 0x4f0e <LCD_sendCommand+0x1de>
	else if (__tmp > 65535)
    4e90:	6b a1       	ldd	r22, Y+35	; 0x23
    4e92:	7c a1       	ldd	r23, Y+36	; 0x24
    4e94:	8d a1       	ldd	r24, Y+37	; 0x25
    4e96:	9e a1       	ldd	r25, Y+38	; 0x26
    4e98:	20 e0       	ldi	r18, 0x00	; 0
    4e9a:	3f ef       	ldi	r19, 0xFF	; 255
    4e9c:	4f e7       	ldi	r20, 0x7F	; 127
    4e9e:	57 e4       	ldi	r21, 0x47	; 71
    4ea0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4ea4:	18 16       	cp	r1, r24
    4ea6:	4c f5       	brge	.+82     	; 0x4efa <LCD_sendCommand+0x1ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4ea8:	6f a1       	ldd	r22, Y+39	; 0x27
    4eaa:	78 a5       	ldd	r23, Y+40	; 0x28
    4eac:	89 a5       	ldd	r24, Y+41	; 0x29
    4eae:	9a a5       	ldd	r25, Y+42	; 0x2a
    4eb0:	20 e0       	ldi	r18, 0x00	; 0
    4eb2:	30 e0       	ldi	r19, 0x00	; 0
    4eb4:	40 e2       	ldi	r20, 0x20	; 32
    4eb6:	51 e4       	ldi	r21, 0x41	; 65
    4eb8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4ebc:	dc 01       	movw	r26, r24
    4ebe:	cb 01       	movw	r24, r22
    4ec0:	bc 01       	movw	r22, r24
    4ec2:	cd 01       	movw	r24, r26
    4ec4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4ec8:	dc 01       	movw	r26, r24
    4eca:	cb 01       	movw	r24, r22
    4ecc:	9a a3       	std	Y+34, r25	; 0x22
    4ece:	89 a3       	std	Y+33, r24	; 0x21
    4ed0:	0f c0       	rjmp	.+30     	; 0x4ef0 <LCD_sendCommand+0x1c0>
    4ed2:	88 ec       	ldi	r24, 0xC8	; 200
    4ed4:	90 e0       	ldi	r25, 0x00	; 0
    4ed6:	98 a3       	std	Y+32, r25	; 0x20
    4ed8:	8f 8f       	std	Y+31, r24	; 0x1f
    4eda:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4edc:	98 a1       	ldd	r25, Y+32	; 0x20
    4ede:	01 97       	sbiw	r24, 0x01	; 1
    4ee0:	f1 f7       	brne	.-4      	; 0x4ede <LCD_sendCommand+0x1ae>
    4ee2:	98 a3       	std	Y+32, r25	; 0x20
    4ee4:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ee6:	89 a1       	ldd	r24, Y+33	; 0x21
    4ee8:	9a a1       	ldd	r25, Y+34	; 0x22
    4eea:	01 97       	sbiw	r24, 0x01	; 1
    4eec:	9a a3       	std	Y+34, r25	; 0x22
    4eee:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ef0:	89 a1       	ldd	r24, Y+33	; 0x21
    4ef2:	9a a1       	ldd	r25, Y+34	; 0x22
    4ef4:	00 97       	sbiw	r24, 0x00	; 0
    4ef6:	69 f7       	brne	.-38     	; 0x4ed2 <LCD_sendCommand+0x1a2>
    4ef8:	14 c0       	rjmp	.+40     	; 0x4f22 <LCD_sendCommand+0x1f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4efa:	6b a1       	ldd	r22, Y+35	; 0x23
    4efc:	7c a1       	ldd	r23, Y+36	; 0x24
    4efe:	8d a1       	ldd	r24, Y+37	; 0x25
    4f00:	9e a1       	ldd	r25, Y+38	; 0x26
    4f02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4f06:	dc 01       	movw	r26, r24
    4f08:	cb 01       	movw	r24, r22
    4f0a:	9a a3       	std	Y+34, r25	; 0x22
    4f0c:	89 a3       	std	Y+33, r24	; 0x21
    4f0e:	89 a1       	ldd	r24, Y+33	; 0x21
    4f10:	9a a1       	ldd	r25, Y+34	; 0x22
    4f12:	9e 8f       	std	Y+30, r25	; 0x1e
    4f14:	8d 8f       	std	Y+29, r24	; 0x1d
    4f16:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4f18:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4f1a:	01 97       	sbiw	r24, 0x01	; 1
    4f1c:	f1 f7       	brne	.-4      	; 0x4f1a <LCD_sendCommand+0x1ea>
    4f1e:	9e 8f       	std	Y+30, r25	; 0x1e
    4f20:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID, LCD_E_PIN_ID, LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */

#elif(LCD_DATA_BITS_MODE == 8)
  GPIO_writePort(LCD_DATA_PORT_ID, command); /* out the required command to the data bus D0 --> D7 */
    4f22:	80 e0       	ldi	r24, 0x00	; 0
    4f24:	69 ad       	ldd	r22, Y+57	; 0x39
    4f26:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <GPIO_writePort>
    4f2a:	80 e0       	ldi	r24, 0x00	; 0
    4f2c:	90 e0       	ldi	r25, 0x00	; 0
    4f2e:	a0 e8       	ldi	r26, 0x80	; 128
    4f30:	bf e3       	ldi	r27, 0x3F	; 63
    4f32:	89 8f       	std	Y+25, r24	; 0x19
    4f34:	9a 8f       	std	Y+26, r25	; 0x1a
    4f36:	ab 8f       	std	Y+27, r26	; 0x1b
    4f38:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4f3a:	69 8d       	ldd	r22, Y+25	; 0x19
    4f3c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4f3e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4f40:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4f42:	20 e0       	ldi	r18, 0x00	; 0
    4f44:	30 e0       	ldi	r19, 0x00	; 0
    4f46:	4a ef       	ldi	r20, 0xFA	; 250
    4f48:	54 e4       	ldi	r21, 0x44	; 68
    4f4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4f4e:	dc 01       	movw	r26, r24
    4f50:	cb 01       	movw	r24, r22
    4f52:	8d 8b       	std	Y+21, r24	; 0x15
    4f54:	9e 8b       	std	Y+22, r25	; 0x16
    4f56:	af 8b       	std	Y+23, r26	; 0x17
    4f58:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4f5a:	6d 89       	ldd	r22, Y+21	; 0x15
    4f5c:	7e 89       	ldd	r23, Y+22	; 0x16
    4f5e:	8f 89       	ldd	r24, Y+23	; 0x17
    4f60:	98 8d       	ldd	r25, Y+24	; 0x18
    4f62:	20 e0       	ldi	r18, 0x00	; 0
    4f64:	30 e0       	ldi	r19, 0x00	; 0
    4f66:	40 e8       	ldi	r20, 0x80	; 128
    4f68:	5f e3       	ldi	r21, 0x3F	; 63
    4f6a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4f6e:	88 23       	and	r24, r24
    4f70:	2c f4       	brge	.+10     	; 0x4f7c <LCD_sendCommand+0x24c>
		__ticks = 1;
    4f72:	81 e0       	ldi	r24, 0x01	; 1
    4f74:	90 e0       	ldi	r25, 0x00	; 0
    4f76:	9c 8b       	std	Y+20, r25	; 0x14
    4f78:	8b 8b       	std	Y+19, r24	; 0x13
    4f7a:	3f c0       	rjmp	.+126    	; 0x4ffa <LCD_sendCommand+0x2ca>
	else if (__tmp > 65535)
    4f7c:	6d 89       	ldd	r22, Y+21	; 0x15
    4f7e:	7e 89       	ldd	r23, Y+22	; 0x16
    4f80:	8f 89       	ldd	r24, Y+23	; 0x17
    4f82:	98 8d       	ldd	r25, Y+24	; 0x18
    4f84:	20 e0       	ldi	r18, 0x00	; 0
    4f86:	3f ef       	ldi	r19, 0xFF	; 255
    4f88:	4f e7       	ldi	r20, 0x7F	; 127
    4f8a:	57 e4       	ldi	r21, 0x47	; 71
    4f8c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4f90:	18 16       	cp	r1, r24
    4f92:	4c f5       	brge	.+82     	; 0x4fe6 <LCD_sendCommand+0x2b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4f94:	69 8d       	ldd	r22, Y+25	; 0x19
    4f96:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4f98:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4f9a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4f9c:	20 e0       	ldi	r18, 0x00	; 0
    4f9e:	30 e0       	ldi	r19, 0x00	; 0
    4fa0:	40 e2       	ldi	r20, 0x20	; 32
    4fa2:	51 e4       	ldi	r21, 0x41	; 65
    4fa4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4fa8:	dc 01       	movw	r26, r24
    4faa:	cb 01       	movw	r24, r22
    4fac:	bc 01       	movw	r22, r24
    4fae:	cd 01       	movw	r24, r26
    4fb0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4fb4:	dc 01       	movw	r26, r24
    4fb6:	cb 01       	movw	r24, r22
    4fb8:	9c 8b       	std	Y+20, r25	; 0x14
    4fba:	8b 8b       	std	Y+19, r24	; 0x13
    4fbc:	0f c0       	rjmp	.+30     	; 0x4fdc <LCD_sendCommand+0x2ac>
    4fbe:	88 ec       	ldi	r24, 0xC8	; 200
    4fc0:	90 e0       	ldi	r25, 0x00	; 0
    4fc2:	9a 8b       	std	Y+18, r25	; 0x12
    4fc4:	89 8b       	std	Y+17, r24	; 0x11
    4fc6:	89 89       	ldd	r24, Y+17	; 0x11
    4fc8:	9a 89       	ldd	r25, Y+18	; 0x12
    4fca:	01 97       	sbiw	r24, 0x01	; 1
    4fcc:	f1 f7       	brne	.-4      	; 0x4fca <LCD_sendCommand+0x29a>
    4fce:	9a 8b       	std	Y+18, r25	; 0x12
    4fd0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4fd2:	8b 89       	ldd	r24, Y+19	; 0x13
    4fd4:	9c 89       	ldd	r25, Y+20	; 0x14
    4fd6:	01 97       	sbiw	r24, 0x01	; 1
    4fd8:	9c 8b       	std	Y+20, r25	; 0x14
    4fda:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4fdc:	8b 89       	ldd	r24, Y+19	; 0x13
    4fde:	9c 89       	ldd	r25, Y+20	; 0x14
    4fe0:	00 97       	sbiw	r24, 0x00	; 0
    4fe2:	69 f7       	brne	.-38     	; 0x4fbe <LCD_sendCommand+0x28e>
    4fe4:	14 c0       	rjmp	.+40     	; 0x500e <LCD_sendCommand+0x2de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4fe6:	6d 89       	ldd	r22, Y+21	; 0x15
    4fe8:	7e 89       	ldd	r23, Y+22	; 0x16
    4fea:	8f 89       	ldd	r24, Y+23	; 0x17
    4fec:	98 8d       	ldd	r25, Y+24	; 0x18
    4fee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4ff2:	dc 01       	movw	r26, r24
    4ff4:	cb 01       	movw	r24, r22
    4ff6:	9c 8b       	std	Y+20, r25	; 0x14
    4ff8:	8b 8b       	std	Y+19, r24	; 0x13
    4ffa:	8b 89       	ldd	r24, Y+19	; 0x13
    4ffc:	9c 89       	ldd	r25, Y+20	; 0x14
    4ffe:	98 8b       	std	Y+16, r25	; 0x10
    5000:	8f 87       	std	Y+15, r24	; 0x0f
    5002:	8f 85       	ldd	r24, Y+15	; 0x0f
    5004:	98 89       	ldd	r25, Y+16	; 0x10
    5006:	01 97       	sbiw	r24, 0x01	; 1
    5008:	f1 f7       	brne	.-4      	; 0x5006 <LCD_sendCommand+0x2d6>
    500a:	98 8b       	std	Y+16, r25	; 0x10
    500c:	8f 87       	std	Y+15, r24	; 0x0f
  _delay_ms(1); /* delay for processing Tdsw = 100ns */
  GPIO_writePin(LCD_E_PORT_ID, LCD_E_PIN_ID, LOGIC_LOW); /* Disable LCD E=0 */
    500e:	82 e0       	ldi	r24, 0x02	; 2
    5010:	61 e0       	ldi	r22, 0x01	; 1
    5012:	40 e0       	ldi	r20, 0x00	; 0
    5014:	0e 94 10 09 	call	0x1220	; 0x1220 <GPIO_writePin>
    5018:	80 e0       	ldi	r24, 0x00	; 0
    501a:	90 e0       	ldi	r25, 0x00	; 0
    501c:	a0 e8       	ldi	r26, 0x80	; 128
    501e:	bf e3       	ldi	r27, 0x3F	; 63
    5020:	8b 87       	std	Y+11, r24	; 0x0b
    5022:	9c 87       	std	Y+12, r25	; 0x0c
    5024:	ad 87       	std	Y+13, r26	; 0x0d
    5026:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5028:	6b 85       	ldd	r22, Y+11	; 0x0b
    502a:	7c 85       	ldd	r23, Y+12	; 0x0c
    502c:	8d 85       	ldd	r24, Y+13	; 0x0d
    502e:	9e 85       	ldd	r25, Y+14	; 0x0e
    5030:	20 e0       	ldi	r18, 0x00	; 0
    5032:	30 e0       	ldi	r19, 0x00	; 0
    5034:	4a ef       	ldi	r20, 0xFA	; 250
    5036:	54 e4       	ldi	r21, 0x44	; 68
    5038:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    503c:	dc 01       	movw	r26, r24
    503e:	cb 01       	movw	r24, r22
    5040:	8f 83       	std	Y+7, r24	; 0x07
    5042:	98 87       	std	Y+8, r25	; 0x08
    5044:	a9 87       	std	Y+9, r26	; 0x09
    5046:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5048:	6f 81       	ldd	r22, Y+7	; 0x07
    504a:	78 85       	ldd	r23, Y+8	; 0x08
    504c:	89 85       	ldd	r24, Y+9	; 0x09
    504e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5050:	20 e0       	ldi	r18, 0x00	; 0
    5052:	30 e0       	ldi	r19, 0x00	; 0
    5054:	40 e8       	ldi	r20, 0x80	; 128
    5056:	5f e3       	ldi	r21, 0x3F	; 63
    5058:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    505c:	88 23       	and	r24, r24
    505e:	2c f4       	brge	.+10     	; 0x506a <LCD_sendCommand+0x33a>
		__ticks = 1;
    5060:	81 e0       	ldi	r24, 0x01	; 1
    5062:	90 e0       	ldi	r25, 0x00	; 0
    5064:	9e 83       	std	Y+6, r25	; 0x06
    5066:	8d 83       	std	Y+5, r24	; 0x05
    5068:	3f c0       	rjmp	.+126    	; 0x50e8 <LCD_sendCommand+0x3b8>
	else if (__tmp > 65535)
    506a:	6f 81       	ldd	r22, Y+7	; 0x07
    506c:	78 85       	ldd	r23, Y+8	; 0x08
    506e:	89 85       	ldd	r24, Y+9	; 0x09
    5070:	9a 85       	ldd	r25, Y+10	; 0x0a
    5072:	20 e0       	ldi	r18, 0x00	; 0
    5074:	3f ef       	ldi	r19, 0xFF	; 255
    5076:	4f e7       	ldi	r20, 0x7F	; 127
    5078:	57 e4       	ldi	r21, 0x47	; 71
    507a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    507e:	18 16       	cp	r1, r24
    5080:	4c f5       	brge	.+82     	; 0x50d4 <LCD_sendCommand+0x3a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5082:	6b 85       	ldd	r22, Y+11	; 0x0b
    5084:	7c 85       	ldd	r23, Y+12	; 0x0c
    5086:	8d 85       	ldd	r24, Y+13	; 0x0d
    5088:	9e 85       	ldd	r25, Y+14	; 0x0e
    508a:	20 e0       	ldi	r18, 0x00	; 0
    508c:	30 e0       	ldi	r19, 0x00	; 0
    508e:	40 e2       	ldi	r20, 0x20	; 32
    5090:	51 e4       	ldi	r21, 0x41	; 65
    5092:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5096:	dc 01       	movw	r26, r24
    5098:	cb 01       	movw	r24, r22
    509a:	bc 01       	movw	r22, r24
    509c:	cd 01       	movw	r24, r26
    509e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    50a2:	dc 01       	movw	r26, r24
    50a4:	cb 01       	movw	r24, r22
    50a6:	9e 83       	std	Y+6, r25	; 0x06
    50a8:	8d 83       	std	Y+5, r24	; 0x05
    50aa:	0f c0       	rjmp	.+30     	; 0x50ca <LCD_sendCommand+0x39a>
    50ac:	88 ec       	ldi	r24, 0xC8	; 200
    50ae:	90 e0       	ldi	r25, 0x00	; 0
    50b0:	9c 83       	std	Y+4, r25	; 0x04
    50b2:	8b 83       	std	Y+3, r24	; 0x03
    50b4:	8b 81       	ldd	r24, Y+3	; 0x03
    50b6:	9c 81       	ldd	r25, Y+4	; 0x04
    50b8:	01 97       	sbiw	r24, 0x01	; 1
    50ba:	f1 f7       	brne	.-4      	; 0x50b8 <LCD_sendCommand+0x388>
    50bc:	9c 83       	std	Y+4, r25	; 0x04
    50be:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    50c0:	8d 81       	ldd	r24, Y+5	; 0x05
    50c2:	9e 81       	ldd	r25, Y+6	; 0x06
    50c4:	01 97       	sbiw	r24, 0x01	; 1
    50c6:	9e 83       	std	Y+6, r25	; 0x06
    50c8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    50ca:	8d 81       	ldd	r24, Y+5	; 0x05
    50cc:	9e 81       	ldd	r25, Y+6	; 0x06
    50ce:	00 97       	sbiw	r24, 0x00	; 0
    50d0:	69 f7       	brne	.-38     	; 0x50ac <LCD_sendCommand+0x37c>
    50d2:	14 c0       	rjmp	.+40     	; 0x50fc <LCD_sendCommand+0x3cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    50d4:	6f 81       	ldd	r22, Y+7	; 0x07
    50d6:	78 85       	ldd	r23, Y+8	; 0x08
    50d8:	89 85       	ldd	r24, Y+9	; 0x09
    50da:	9a 85       	ldd	r25, Y+10	; 0x0a
    50dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    50e0:	dc 01       	movw	r26, r24
    50e2:	cb 01       	movw	r24, r22
    50e4:	9e 83       	std	Y+6, r25	; 0x06
    50e6:	8d 83       	std	Y+5, r24	; 0x05
    50e8:	8d 81       	ldd	r24, Y+5	; 0x05
    50ea:	9e 81       	ldd	r25, Y+6	; 0x06
    50ec:	9a 83       	std	Y+2, r25	; 0x02
    50ee:	89 83       	std	Y+1, r24	; 0x01
    50f0:	89 81       	ldd	r24, Y+1	; 0x01
    50f2:	9a 81       	ldd	r25, Y+2	; 0x02
    50f4:	01 97       	sbiw	r24, 0x01	; 1
    50f6:	f1 f7       	brne	.-4      	; 0x50f4 <LCD_sendCommand+0x3c4>
    50f8:	9a 83       	std	Y+2, r25	; 0x02
    50fa:	89 83       	std	Y+1, r24	; 0x01
  _delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    50fc:	e9 96       	adiw	r28, 0x39	; 57
    50fe:	0f b6       	in	r0, 0x3f	; 63
    5100:	f8 94       	cli
    5102:	de bf       	out	0x3e, r29	; 62
    5104:	0f be       	out	0x3f, r0	; 63
    5106:	cd bf       	out	0x3d, r28	; 61
    5108:	cf 91       	pop	r28
    510a:	df 91       	pop	r29
    510c:	08 95       	ret

0000510e <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
    510e:	df 93       	push	r29
    5110:	cf 93       	push	r28
    5112:	cd b7       	in	r28, 0x3d	; 61
    5114:	de b7       	in	r29, 0x3e	; 62
    5116:	e9 97       	sbiw	r28, 0x39	; 57
    5118:	0f b6       	in	r0, 0x3f	; 63
    511a:	f8 94       	cli
    511c:	de bf       	out	0x3e, r29	; 62
    511e:	0f be       	out	0x3f, r0	; 63
    5120:	cd bf       	out	0x3d, r28	; 61
    5122:	89 af       	std	Y+57, r24	; 0x39
  GPIO_writePin(LCD_RS_PORT_ID, LCD_RS_PIN_ID, LOGIC_HIGH); /* Data Mode RS=1 */
    5124:	82 e0       	ldi	r24, 0x02	; 2
    5126:	60 e0       	ldi	r22, 0x00	; 0
    5128:	41 e0       	ldi	r20, 0x01	; 1
    512a:	0e 94 10 09 	call	0x1220	; 0x1220 <GPIO_writePin>
    512e:	80 e0       	ldi	r24, 0x00	; 0
    5130:	90 e0       	ldi	r25, 0x00	; 0
    5132:	a0 e8       	ldi	r26, 0x80	; 128
    5134:	bf e3       	ldi	r27, 0x3F	; 63
    5136:	8d ab       	std	Y+53, r24	; 0x35
    5138:	9e ab       	std	Y+54, r25	; 0x36
    513a:	af ab       	std	Y+55, r26	; 0x37
    513c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    513e:	6d a9       	ldd	r22, Y+53	; 0x35
    5140:	7e a9       	ldd	r23, Y+54	; 0x36
    5142:	8f a9       	ldd	r24, Y+55	; 0x37
    5144:	98 ad       	ldd	r25, Y+56	; 0x38
    5146:	20 e0       	ldi	r18, 0x00	; 0
    5148:	30 e0       	ldi	r19, 0x00	; 0
    514a:	4a ef       	ldi	r20, 0xFA	; 250
    514c:	54 e4       	ldi	r21, 0x44	; 68
    514e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5152:	dc 01       	movw	r26, r24
    5154:	cb 01       	movw	r24, r22
    5156:	89 ab       	std	Y+49, r24	; 0x31
    5158:	9a ab       	std	Y+50, r25	; 0x32
    515a:	ab ab       	std	Y+51, r26	; 0x33
    515c:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    515e:	69 a9       	ldd	r22, Y+49	; 0x31
    5160:	7a a9       	ldd	r23, Y+50	; 0x32
    5162:	8b a9       	ldd	r24, Y+51	; 0x33
    5164:	9c a9       	ldd	r25, Y+52	; 0x34
    5166:	20 e0       	ldi	r18, 0x00	; 0
    5168:	30 e0       	ldi	r19, 0x00	; 0
    516a:	40 e8       	ldi	r20, 0x80	; 128
    516c:	5f e3       	ldi	r21, 0x3F	; 63
    516e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5172:	88 23       	and	r24, r24
    5174:	2c f4       	brge	.+10     	; 0x5180 <LCD_displayCharacter+0x72>
		__ticks = 1;
    5176:	81 e0       	ldi	r24, 0x01	; 1
    5178:	90 e0       	ldi	r25, 0x00	; 0
    517a:	98 ab       	std	Y+48, r25	; 0x30
    517c:	8f a7       	std	Y+47, r24	; 0x2f
    517e:	3f c0       	rjmp	.+126    	; 0x51fe <LCD_displayCharacter+0xf0>
	else if (__tmp > 65535)
    5180:	69 a9       	ldd	r22, Y+49	; 0x31
    5182:	7a a9       	ldd	r23, Y+50	; 0x32
    5184:	8b a9       	ldd	r24, Y+51	; 0x33
    5186:	9c a9       	ldd	r25, Y+52	; 0x34
    5188:	20 e0       	ldi	r18, 0x00	; 0
    518a:	3f ef       	ldi	r19, 0xFF	; 255
    518c:	4f e7       	ldi	r20, 0x7F	; 127
    518e:	57 e4       	ldi	r21, 0x47	; 71
    5190:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5194:	18 16       	cp	r1, r24
    5196:	4c f5       	brge	.+82     	; 0x51ea <LCD_displayCharacter+0xdc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5198:	6d a9       	ldd	r22, Y+53	; 0x35
    519a:	7e a9       	ldd	r23, Y+54	; 0x36
    519c:	8f a9       	ldd	r24, Y+55	; 0x37
    519e:	98 ad       	ldd	r25, Y+56	; 0x38
    51a0:	20 e0       	ldi	r18, 0x00	; 0
    51a2:	30 e0       	ldi	r19, 0x00	; 0
    51a4:	40 e2       	ldi	r20, 0x20	; 32
    51a6:	51 e4       	ldi	r21, 0x41	; 65
    51a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    51ac:	dc 01       	movw	r26, r24
    51ae:	cb 01       	movw	r24, r22
    51b0:	bc 01       	movw	r22, r24
    51b2:	cd 01       	movw	r24, r26
    51b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    51b8:	dc 01       	movw	r26, r24
    51ba:	cb 01       	movw	r24, r22
    51bc:	98 ab       	std	Y+48, r25	; 0x30
    51be:	8f a7       	std	Y+47, r24	; 0x2f
    51c0:	0f c0       	rjmp	.+30     	; 0x51e0 <LCD_displayCharacter+0xd2>
    51c2:	88 ec       	ldi	r24, 0xC8	; 200
    51c4:	90 e0       	ldi	r25, 0x00	; 0
    51c6:	9e a7       	std	Y+46, r25	; 0x2e
    51c8:	8d a7       	std	Y+45, r24	; 0x2d
    51ca:	8d a5       	ldd	r24, Y+45	; 0x2d
    51cc:	9e a5       	ldd	r25, Y+46	; 0x2e
    51ce:	01 97       	sbiw	r24, 0x01	; 1
    51d0:	f1 f7       	brne	.-4      	; 0x51ce <LCD_displayCharacter+0xc0>
    51d2:	9e a7       	std	Y+46, r25	; 0x2e
    51d4:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    51d6:	8f a5       	ldd	r24, Y+47	; 0x2f
    51d8:	98 a9       	ldd	r25, Y+48	; 0x30
    51da:	01 97       	sbiw	r24, 0x01	; 1
    51dc:	98 ab       	std	Y+48, r25	; 0x30
    51de:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    51e0:	8f a5       	ldd	r24, Y+47	; 0x2f
    51e2:	98 a9       	ldd	r25, Y+48	; 0x30
    51e4:	00 97       	sbiw	r24, 0x00	; 0
    51e6:	69 f7       	brne	.-38     	; 0x51c2 <LCD_displayCharacter+0xb4>
    51e8:	14 c0       	rjmp	.+40     	; 0x5212 <LCD_displayCharacter+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    51ea:	69 a9       	ldd	r22, Y+49	; 0x31
    51ec:	7a a9       	ldd	r23, Y+50	; 0x32
    51ee:	8b a9       	ldd	r24, Y+51	; 0x33
    51f0:	9c a9       	ldd	r25, Y+52	; 0x34
    51f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    51f6:	dc 01       	movw	r26, r24
    51f8:	cb 01       	movw	r24, r22
    51fa:	98 ab       	std	Y+48, r25	; 0x30
    51fc:	8f a7       	std	Y+47, r24	; 0x2f
    51fe:	8f a5       	ldd	r24, Y+47	; 0x2f
    5200:	98 a9       	ldd	r25, Y+48	; 0x30
    5202:	9c a7       	std	Y+44, r25	; 0x2c
    5204:	8b a7       	std	Y+43, r24	; 0x2b
    5206:	8b a5       	ldd	r24, Y+43	; 0x2b
    5208:	9c a5       	ldd	r25, Y+44	; 0x2c
    520a:	01 97       	sbiw	r24, 0x01	; 1
    520c:	f1 f7       	brne	.-4      	; 0x520a <LCD_displayCharacter+0xfc>
    520e:	9c a7       	std	Y+44, r25	; 0x2c
    5210:	8b a7       	std	Y+43, r24	; 0x2b
  _delay_ms(1); /* delay for processing Tas = 50ns */
  GPIO_writePin(LCD_E_PORT_ID, LCD_E_PIN_ID, LOGIC_HIGH); /* Enable LCD E=1 */
    5212:	82 e0       	ldi	r24, 0x02	; 2
    5214:	61 e0       	ldi	r22, 0x01	; 1
    5216:	41 e0       	ldi	r20, 0x01	; 1
    5218:	0e 94 10 09 	call	0x1220	; 0x1220 <GPIO_writePin>
    521c:	80 e0       	ldi	r24, 0x00	; 0
    521e:	90 e0       	ldi	r25, 0x00	; 0
    5220:	a0 e8       	ldi	r26, 0x80	; 128
    5222:	bf e3       	ldi	r27, 0x3F	; 63
    5224:	8f a3       	std	Y+39, r24	; 0x27
    5226:	98 a7       	std	Y+40, r25	; 0x28
    5228:	a9 a7       	std	Y+41, r26	; 0x29
    522a:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    522c:	6f a1       	ldd	r22, Y+39	; 0x27
    522e:	78 a5       	ldd	r23, Y+40	; 0x28
    5230:	89 a5       	ldd	r24, Y+41	; 0x29
    5232:	9a a5       	ldd	r25, Y+42	; 0x2a
    5234:	20 e0       	ldi	r18, 0x00	; 0
    5236:	30 e0       	ldi	r19, 0x00	; 0
    5238:	4a ef       	ldi	r20, 0xFA	; 250
    523a:	54 e4       	ldi	r21, 0x44	; 68
    523c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5240:	dc 01       	movw	r26, r24
    5242:	cb 01       	movw	r24, r22
    5244:	8b a3       	std	Y+35, r24	; 0x23
    5246:	9c a3       	std	Y+36, r25	; 0x24
    5248:	ad a3       	std	Y+37, r26	; 0x25
    524a:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    524c:	6b a1       	ldd	r22, Y+35	; 0x23
    524e:	7c a1       	ldd	r23, Y+36	; 0x24
    5250:	8d a1       	ldd	r24, Y+37	; 0x25
    5252:	9e a1       	ldd	r25, Y+38	; 0x26
    5254:	20 e0       	ldi	r18, 0x00	; 0
    5256:	30 e0       	ldi	r19, 0x00	; 0
    5258:	40 e8       	ldi	r20, 0x80	; 128
    525a:	5f e3       	ldi	r21, 0x3F	; 63
    525c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5260:	88 23       	and	r24, r24
    5262:	2c f4       	brge	.+10     	; 0x526e <LCD_displayCharacter+0x160>
		__ticks = 1;
    5264:	81 e0       	ldi	r24, 0x01	; 1
    5266:	90 e0       	ldi	r25, 0x00	; 0
    5268:	9a a3       	std	Y+34, r25	; 0x22
    526a:	89 a3       	std	Y+33, r24	; 0x21
    526c:	3f c0       	rjmp	.+126    	; 0x52ec <LCD_displayCharacter+0x1de>
	else if (__tmp > 65535)
    526e:	6b a1       	ldd	r22, Y+35	; 0x23
    5270:	7c a1       	ldd	r23, Y+36	; 0x24
    5272:	8d a1       	ldd	r24, Y+37	; 0x25
    5274:	9e a1       	ldd	r25, Y+38	; 0x26
    5276:	20 e0       	ldi	r18, 0x00	; 0
    5278:	3f ef       	ldi	r19, 0xFF	; 255
    527a:	4f e7       	ldi	r20, 0x7F	; 127
    527c:	57 e4       	ldi	r21, 0x47	; 71
    527e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5282:	18 16       	cp	r1, r24
    5284:	4c f5       	brge	.+82     	; 0x52d8 <LCD_displayCharacter+0x1ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5286:	6f a1       	ldd	r22, Y+39	; 0x27
    5288:	78 a5       	ldd	r23, Y+40	; 0x28
    528a:	89 a5       	ldd	r24, Y+41	; 0x29
    528c:	9a a5       	ldd	r25, Y+42	; 0x2a
    528e:	20 e0       	ldi	r18, 0x00	; 0
    5290:	30 e0       	ldi	r19, 0x00	; 0
    5292:	40 e2       	ldi	r20, 0x20	; 32
    5294:	51 e4       	ldi	r21, 0x41	; 65
    5296:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    529a:	dc 01       	movw	r26, r24
    529c:	cb 01       	movw	r24, r22
    529e:	bc 01       	movw	r22, r24
    52a0:	cd 01       	movw	r24, r26
    52a2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    52a6:	dc 01       	movw	r26, r24
    52a8:	cb 01       	movw	r24, r22
    52aa:	9a a3       	std	Y+34, r25	; 0x22
    52ac:	89 a3       	std	Y+33, r24	; 0x21
    52ae:	0f c0       	rjmp	.+30     	; 0x52ce <LCD_displayCharacter+0x1c0>
    52b0:	88 ec       	ldi	r24, 0xC8	; 200
    52b2:	90 e0       	ldi	r25, 0x00	; 0
    52b4:	98 a3       	std	Y+32, r25	; 0x20
    52b6:	8f 8f       	std	Y+31, r24	; 0x1f
    52b8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    52ba:	98 a1       	ldd	r25, Y+32	; 0x20
    52bc:	01 97       	sbiw	r24, 0x01	; 1
    52be:	f1 f7       	brne	.-4      	; 0x52bc <LCD_displayCharacter+0x1ae>
    52c0:	98 a3       	std	Y+32, r25	; 0x20
    52c2:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    52c4:	89 a1       	ldd	r24, Y+33	; 0x21
    52c6:	9a a1       	ldd	r25, Y+34	; 0x22
    52c8:	01 97       	sbiw	r24, 0x01	; 1
    52ca:	9a a3       	std	Y+34, r25	; 0x22
    52cc:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    52ce:	89 a1       	ldd	r24, Y+33	; 0x21
    52d0:	9a a1       	ldd	r25, Y+34	; 0x22
    52d2:	00 97       	sbiw	r24, 0x00	; 0
    52d4:	69 f7       	brne	.-38     	; 0x52b0 <LCD_displayCharacter+0x1a2>
    52d6:	14 c0       	rjmp	.+40     	; 0x5300 <LCD_displayCharacter+0x1f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    52d8:	6b a1       	ldd	r22, Y+35	; 0x23
    52da:	7c a1       	ldd	r23, Y+36	; 0x24
    52dc:	8d a1       	ldd	r24, Y+37	; 0x25
    52de:	9e a1       	ldd	r25, Y+38	; 0x26
    52e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    52e4:	dc 01       	movw	r26, r24
    52e6:	cb 01       	movw	r24, r22
    52e8:	9a a3       	std	Y+34, r25	; 0x22
    52ea:	89 a3       	std	Y+33, r24	; 0x21
    52ec:	89 a1       	ldd	r24, Y+33	; 0x21
    52ee:	9a a1       	ldd	r25, Y+34	; 0x22
    52f0:	9e 8f       	std	Y+30, r25	; 0x1e
    52f2:	8d 8f       	std	Y+29, r24	; 0x1d
    52f4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    52f6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    52f8:	01 97       	sbiw	r24, 0x01	; 1
    52fa:	f1 f7       	brne	.-4      	; 0x52f8 <LCD_displayCharacter+0x1ea>
    52fc:	9e 8f       	std	Y+30, r25	; 0x1e
    52fe:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID, LCD_E_PIN_ID, LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */

#elif(LCD_DATA_BITS_MODE == 8)
  GPIO_writePort(LCD_DATA_PORT_ID, data); /* out the required command to the data bus D0 --> D7 */
    5300:	80 e0       	ldi	r24, 0x00	; 0
    5302:	69 ad       	ldd	r22, Y+57	; 0x39
    5304:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <GPIO_writePort>
    5308:	80 e0       	ldi	r24, 0x00	; 0
    530a:	90 e0       	ldi	r25, 0x00	; 0
    530c:	a0 e8       	ldi	r26, 0x80	; 128
    530e:	bf e3       	ldi	r27, 0x3F	; 63
    5310:	89 8f       	std	Y+25, r24	; 0x19
    5312:	9a 8f       	std	Y+26, r25	; 0x1a
    5314:	ab 8f       	std	Y+27, r26	; 0x1b
    5316:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5318:	69 8d       	ldd	r22, Y+25	; 0x19
    531a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    531c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    531e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5320:	20 e0       	ldi	r18, 0x00	; 0
    5322:	30 e0       	ldi	r19, 0x00	; 0
    5324:	4a ef       	ldi	r20, 0xFA	; 250
    5326:	54 e4       	ldi	r21, 0x44	; 68
    5328:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    532c:	dc 01       	movw	r26, r24
    532e:	cb 01       	movw	r24, r22
    5330:	8d 8b       	std	Y+21, r24	; 0x15
    5332:	9e 8b       	std	Y+22, r25	; 0x16
    5334:	af 8b       	std	Y+23, r26	; 0x17
    5336:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    5338:	6d 89       	ldd	r22, Y+21	; 0x15
    533a:	7e 89       	ldd	r23, Y+22	; 0x16
    533c:	8f 89       	ldd	r24, Y+23	; 0x17
    533e:	98 8d       	ldd	r25, Y+24	; 0x18
    5340:	20 e0       	ldi	r18, 0x00	; 0
    5342:	30 e0       	ldi	r19, 0x00	; 0
    5344:	40 e8       	ldi	r20, 0x80	; 128
    5346:	5f e3       	ldi	r21, 0x3F	; 63
    5348:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    534c:	88 23       	and	r24, r24
    534e:	2c f4       	brge	.+10     	; 0x535a <LCD_displayCharacter+0x24c>
		__ticks = 1;
    5350:	81 e0       	ldi	r24, 0x01	; 1
    5352:	90 e0       	ldi	r25, 0x00	; 0
    5354:	9c 8b       	std	Y+20, r25	; 0x14
    5356:	8b 8b       	std	Y+19, r24	; 0x13
    5358:	3f c0       	rjmp	.+126    	; 0x53d8 <LCD_displayCharacter+0x2ca>
	else if (__tmp > 65535)
    535a:	6d 89       	ldd	r22, Y+21	; 0x15
    535c:	7e 89       	ldd	r23, Y+22	; 0x16
    535e:	8f 89       	ldd	r24, Y+23	; 0x17
    5360:	98 8d       	ldd	r25, Y+24	; 0x18
    5362:	20 e0       	ldi	r18, 0x00	; 0
    5364:	3f ef       	ldi	r19, 0xFF	; 255
    5366:	4f e7       	ldi	r20, 0x7F	; 127
    5368:	57 e4       	ldi	r21, 0x47	; 71
    536a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    536e:	18 16       	cp	r1, r24
    5370:	4c f5       	brge	.+82     	; 0x53c4 <LCD_displayCharacter+0x2b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5372:	69 8d       	ldd	r22, Y+25	; 0x19
    5374:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5376:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5378:	9c 8d       	ldd	r25, Y+28	; 0x1c
    537a:	20 e0       	ldi	r18, 0x00	; 0
    537c:	30 e0       	ldi	r19, 0x00	; 0
    537e:	40 e2       	ldi	r20, 0x20	; 32
    5380:	51 e4       	ldi	r21, 0x41	; 65
    5382:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5386:	dc 01       	movw	r26, r24
    5388:	cb 01       	movw	r24, r22
    538a:	bc 01       	movw	r22, r24
    538c:	cd 01       	movw	r24, r26
    538e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5392:	dc 01       	movw	r26, r24
    5394:	cb 01       	movw	r24, r22
    5396:	9c 8b       	std	Y+20, r25	; 0x14
    5398:	8b 8b       	std	Y+19, r24	; 0x13
    539a:	0f c0       	rjmp	.+30     	; 0x53ba <LCD_displayCharacter+0x2ac>
    539c:	88 ec       	ldi	r24, 0xC8	; 200
    539e:	90 e0       	ldi	r25, 0x00	; 0
    53a0:	9a 8b       	std	Y+18, r25	; 0x12
    53a2:	89 8b       	std	Y+17, r24	; 0x11
    53a4:	89 89       	ldd	r24, Y+17	; 0x11
    53a6:	9a 89       	ldd	r25, Y+18	; 0x12
    53a8:	01 97       	sbiw	r24, 0x01	; 1
    53aa:	f1 f7       	brne	.-4      	; 0x53a8 <LCD_displayCharacter+0x29a>
    53ac:	9a 8b       	std	Y+18, r25	; 0x12
    53ae:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53b0:	8b 89       	ldd	r24, Y+19	; 0x13
    53b2:	9c 89       	ldd	r25, Y+20	; 0x14
    53b4:	01 97       	sbiw	r24, 0x01	; 1
    53b6:	9c 8b       	std	Y+20, r25	; 0x14
    53b8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53ba:	8b 89       	ldd	r24, Y+19	; 0x13
    53bc:	9c 89       	ldd	r25, Y+20	; 0x14
    53be:	00 97       	sbiw	r24, 0x00	; 0
    53c0:	69 f7       	brne	.-38     	; 0x539c <LCD_displayCharacter+0x28e>
    53c2:	14 c0       	rjmp	.+40     	; 0x53ec <LCD_displayCharacter+0x2de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    53c4:	6d 89       	ldd	r22, Y+21	; 0x15
    53c6:	7e 89       	ldd	r23, Y+22	; 0x16
    53c8:	8f 89       	ldd	r24, Y+23	; 0x17
    53ca:	98 8d       	ldd	r25, Y+24	; 0x18
    53cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    53d0:	dc 01       	movw	r26, r24
    53d2:	cb 01       	movw	r24, r22
    53d4:	9c 8b       	std	Y+20, r25	; 0x14
    53d6:	8b 8b       	std	Y+19, r24	; 0x13
    53d8:	8b 89       	ldd	r24, Y+19	; 0x13
    53da:	9c 89       	ldd	r25, Y+20	; 0x14
    53dc:	98 8b       	std	Y+16, r25	; 0x10
    53de:	8f 87       	std	Y+15, r24	; 0x0f
    53e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    53e2:	98 89       	ldd	r25, Y+16	; 0x10
    53e4:	01 97       	sbiw	r24, 0x01	; 1
    53e6:	f1 f7       	brne	.-4      	; 0x53e4 <LCD_displayCharacter+0x2d6>
    53e8:	98 8b       	std	Y+16, r25	; 0x10
    53ea:	8f 87       	std	Y+15, r24	; 0x0f
  _delay_ms(1); /* delay for processing Tdsw = 100ns */
  GPIO_writePin(LCD_E_PORT_ID, LCD_E_PIN_ID, LOGIC_LOW); /* Disable LCD E=0 */
    53ec:	82 e0       	ldi	r24, 0x02	; 2
    53ee:	61 e0       	ldi	r22, 0x01	; 1
    53f0:	40 e0       	ldi	r20, 0x00	; 0
    53f2:	0e 94 10 09 	call	0x1220	; 0x1220 <GPIO_writePin>
    53f6:	80 e0       	ldi	r24, 0x00	; 0
    53f8:	90 e0       	ldi	r25, 0x00	; 0
    53fa:	a0 e8       	ldi	r26, 0x80	; 128
    53fc:	bf e3       	ldi	r27, 0x3F	; 63
    53fe:	8b 87       	std	Y+11, r24	; 0x0b
    5400:	9c 87       	std	Y+12, r25	; 0x0c
    5402:	ad 87       	std	Y+13, r26	; 0x0d
    5404:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5406:	6b 85       	ldd	r22, Y+11	; 0x0b
    5408:	7c 85       	ldd	r23, Y+12	; 0x0c
    540a:	8d 85       	ldd	r24, Y+13	; 0x0d
    540c:	9e 85       	ldd	r25, Y+14	; 0x0e
    540e:	20 e0       	ldi	r18, 0x00	; 0
    5410:	30 e0       	ldi	r19, 0x00	; 0
    5412:	4a ef       	ldi	r20, 0xFA	; 250
    5414:	54 e4       	ldi	r21, 0x44	; 68
    5416:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    541a:	dc 01       	movw	r26, r24
    541c:	cb 01       	movw	r24, r22
    541e:	8f 83       	std	Y+7, r24	; 0x07
    5420:	98 87       	std	Y+8, r25	; 0x08
    5422:	a9 87       	std	Y+9, r26	; 0x09
    5424:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5426:	6f 81       	ldd	r22, Y+7	; 0x07
    5428:	78 85       	ldd	r23, Y+8	; 0x08
    542a:	89 85       	ldd	r24, Y+9	; 0x09
    542c:	9a 85       	ldd	r25, Y+10	; 0x0a
    542e:	20 e0       	ldi	r18, 0x00	; 0
    5430:	30 e0       	ldi	r19, 0x00	; 0
    5432:	40 e8       	ldi	r20, 0x80	; 128
    5434:	5f e3       	ldi	r21, 0x3F	; 63
    5436:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    543a:	88 23       	and	r24, r24
    543c:	2c f4       	brge	.+10     	; 0x5448 <LCD_displayCharacter+0x33a>
		__ticks = 1;
    543e:	81 e0       	ldi	r24, 0x01	; 1
    5440:	90 e0       	ldi	r25, 0x00	; 0
    5442:	9e 83       	std	Y+6, r25	; 0x06
    5444:	8d 83       	std	Y+5, r24	; 0x05
    5446:	3f c0       	rjmp	.+126    	; 0x54c6 <LCD_displayCharacter+0x3b8>
	else if (__tmp > 65535)
    5448:	6f 81       	ldd	r22, Y+7	; 0x07
    544a:	78 85       	ldd	r23, Y+8	; 0x08
    544c:	89 85       	ldd	r24, Y+9	; 0x09
    544e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5450:	20 e0       	ldi	r18, 0x00	; 0
    5452:	3f ef       	ldi	r19, 0xFF	; 255
    5454:	4f e7       	ldi	r20, 0x7F	; 127
    5456:	57 e4       	ldi	r21, 0x47	; 71
    5458:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    545c:	18 16       	cp	r1, r24
    545e:	4c f5       	brge	.+82     	; 0x54b2 <LCD_displayCharacter+0x3a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5460:	6b 85       	ldd	r22, Y+11	; 0x0b
    5462:	7c 85       	ldd	r23, Y+12	; 0x0c
    5464:	8d 85       	ldd	r24, Y+13	; 0x0d
    5466:	9e 85       	ldd	r25, Y+14	; 0x0e
    5468:	20 e0       	ldi	r18, 0x00	; 0
    546a:	30 e0       	ldi	r19, 0x00	; 0
    546c:	40 e2       	ldi	r20, 0x20	; 32
    546e:	51 e4       	ldi	r21, 0x41	; 65
    5470:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5474:	dc 01       	movw	r26, r24
    5476:	cb 01       	movw	r24, r22
    5478:	bc 01       	movw	r22, r24
    547a:	cd 01       	movw	r24, r26
    547c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5480:	dc 01       	movw	r26, r24
    5482:	cb 01       	movw	r24, r22
    5484:	9e 83       	std	Y+6, r25	; 0x06
    5486:	8d 83       	std	Y+5, r24	; 0x05
    5488:	0f c0       	rjmp	.+30     	; 0x54a8 <LCD_displayCharacter+0x39a>
    548a:	88 ec       	ldi	r24, 0xC8	; 200
    548c:	90 e0       	ldi	r25, 0x00	; 0
    548e:	9c 83       	std	Y+4, r25	; 0x04
    5490:	8b 83       	std	Y+3, r24	; 0x03
    5492:	8b 81       	ldd	r24, Y+3	; 0x03
    5494:	9c 81       	ldd	r25, Y+4	; 0x04
    5496:	01 97       	sbiw	r24, 0x01	; 1
    5498:	f1 f7       	brne	.-4      	; 0x5496 <LCD_displayCharacter+0x388>
    549a:	9c 83       	std	Y+4, r25	; 0x04
    549c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    549e:	8d 81       	ldd	r24, Y+5	; 0x05
    54a0:	9e 81       	ldd	r25, Y+6	; 0x06
    54a2:	01 97       	sbiw	r24, 0x01	; 1
    54a4:	9e 83       	std	Y+6, r25	; 0x06
    54a6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54a8:	8d 81       	ldd	r24, Y+5	; 0x05
    54aa:	9e 81       	ldd	r25, Y+6	; 0x06
    54ac:	00 97       	sbiw	r24, 0x00	; 0
    54ae:	69 f7       	brne	.-38     	; 0x548a <LCD_displayCharacter+0x37c>
    54b0:	14 c0       	rjmp	.+40     	; 0x54da <LCD_displayCharacter+0x3cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    54b2:	6f 81       	ldd	r22, Y+7	; 0x07
    54b4:	78 85       	ldd	r23, Y+8	; 0x08
    54b6:	89 85       	ldd	r24, Y+9	; 0x09
    54b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    54ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    54be:	dc 01       	movw	r26, r24
    54c0:	cb 01       	movw	r24, r22
    54c2:	9e 83       	std	Y+6, r25	; 0x06
    54c4:	8d 83       	std	Y+5, r24	; 0x05
    54c6:	8d 81       	ldd	r24, Y+5	; 0x05
    54c8:	9e 81       	ldd	r25, Y+6	; 0x06
    54ca:	9a 83       	std	Y+2, r25	; 0x02
    54cc:	89 83       	std	Y+1, r24	; 0x01
    54ce:	89 81       	ldd	r24, Y+1	; 0x01
    54d0:	9a 81       	ldd	r25, Y+2	; 0x02
    54d2:	01 97       	sbiw	r24, 0x01	; 1
    54d4:	f1 f7       	brne	.-4      	; 0x54d2 <LCD_displayCharacter+0x3c4>
    54d6:	9a 83       	std	Y+2, r25	; 0x02
    54d8:	89 83       	std	Y+1, r24	; 0x01
  _delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    54da:	e9 96       	adiw	r28, 0x39	; 57
    54dc:	0f b6       	in	r0, 0x3f	; 63
    54de:	f8 94       	cli
    54e0:	de bf       	out	0x3e, r29	; 62
    54e2:	0f be       	out	0x3f, r0	; 63
    54e4:	cd bf       	out	0x3d, r28	; 61
    54e6:	cf 91       	pop	r28
    54e8:	df 91       	pop	r29
    54ea:	08 95       	ret

000054ec <LCD_displayString>:
 * Description: Displays a string on the LCD.
 *
 * @param Str: Pointer to the string to be displayed.
 */
void LCD_displayString(const char *Str)
{
    54ec:	df 93       	push	r29
    54ee:	cf 93       	push	r28
    54f0:	00 d0       	rcall	.+0      	; 0x54f2 <LCD_displayString+0x6>
    54f2:	0f 92       	push	r0
    54f4:	cd b7       	in	r28, 0x3d	; 61
    54f6:	de b7       	in	r29, 0x3e	; 62
    54f8:	9b 83       	std	Y+3, r25	; 0x03
    54fa:	8a 83       	std	Y+2, r24	; 0x02
  uint8 i = 0;
    54fc:	19 82       	std	Y+1, r1	; 0x01
    54fe:	0e c0       	rjmp	.+28     	; 0x551c <LCD_displayString+0x30>
  while (Str[i] != '\0')
    {
      LCD_displayCharacter(Str[i]);
    5500:	89 81       	ldd	r24, Y+1	; 0x01
    5502:	28 2f       	mov	r18, r24
    5504:	30 e0       	ldi	r19, 0x00	; 0
    5506:	8a 81       	ldd	r24, Y+2	; 0x02
    5508:	9b 81       	ldd	r25, Y+3	; 0x03
    550a:	fc 01       	movw	r30, r24
    550c:	e2 0f       	add	r30, r18
    550e:	f3 1f       	adc	r31, r19
    5510:	80 81       	ld	r24, Z
    5512:	0e 94 87 28 	call	0x510e	; 0x510e <LCD_displayCharacter>
      i++;
    5516:	89 81       	ldd	r24, Y+1	; 0x01
    5518:	8f 5f       	subi	r24, 0xFF	; 255
    551a:	89 83       	std	Y+1, r24	; 0x01
 * @param Str: Pointer to the string to be displayed.
 */
void LCD_displayString(const char *Str)
{
  uint8 i = 0;
  while (Str[i] != '\0')
    551c:	89 81       	ldd	r24, Y+1	; 0x01
    551e:	28 2f       	mov	r18, r24
    5520:	30 e0       	ldi	r19, 0x00	; 0
    5522:	8a 81       	ldd	r24, Y+2	; 0x02
    5524:	9b 81       	ldd	r25, Y+3	; 0x03
    5526:	fc 01       	movw	r30, r24
    5528:	e2 0f       	add	r30, r18
    552a:	f3 1f       	adc	r31, r19
    552c:	80 81       	ld	r24, Z
    552e:	88 23       	and	r24, r24
    5530:	39 f7       	brne	.-50     	; 0x5500 <LCD_displayString+0x14>
   {
   LCD_displayCharacter(*Str);
   Str++;
   }
   *********************************************************/
}
    5532:	0f 90       	pop	r0
    5534:	0f 90       	pop	r0
    5536:	0f 90       	pop	r0
    5538:	cf 91       	pop	r28
    553a:	df 91       	pop	r29
    553c:	08 95       	ret

0000553e <LCD_moveCursor>:
 *
 * @param row: The row index (0 or 1).
 * @param col: The column index (0 to 15).
 */
void LCD_moveCursor(uint8 row, uint8 col)
{
    553e:	df 93       	push	r29
    5540:	cf 93       	push	r28
    5542:	00 d0       	rcall	.+0      	; 0x5544 <LCD_moveCursor+0x6>
    5544:	00 d0       	rcall	.+0      	; 0x5546 <LCD_moveCursor+0x8>
    5546:	0f 92       	push	r0
    5548:	cd b7       	in	r28, 0x3d	; 61
    554a:	de b7       	in	r29, 0x3e	; 62
    554c:	8a 83       	std	Y+2, r24	; 0x02
    554e:	6b 83       	std	Y+3, r22	; 0x03
  uint8 lcd_memory_address;

  /* Calculate the required address in the LCD DDRAM */
  switch (row)
    5550:	8a 81       	ldd	r24, Y+2	; 0x02
    5552:	28 2f       	mov	r18, r24
    5554:	30 e0       	ldi	r19, 0x00	; 0
    5556:	3d 83       	std	Y+5, r19	; 0x05
    5558:	2c 83       	std	Y+4, r18	; 0x04
    555a:	8c 81       	ldd	r24, Y+4	; 0x04
    555c:	9d 81       	ldd	r25, Y+5	; 0x05
    555e:	81 30       	cpi	r24, 0x01	; 1
    5560:	91 05       	cpc	r25, r1
    5562:	c1 f0       	breq	.+48     	; 0x5594 <LCD_moveCursor+0x56>
    5564:	2c 81       	ldd	r18, Y+4	; 0x04
    5566:	3d 81       	ldd	r19, Y+5	; 0x05
    5568:	22 30       	cpi	r18, 0x02	; 2
    556a:	31 05       	cpc	r19, r1
    556c:	2c f4       	brge	.+10     	; 0x5578 <LCD_moveCursor+0x3a>
    556e:	8c 81       	ldd	r24, Y+4	; 0x04
    5570:	9d 81       	ldd	r25, Y+5	; 0x05
    5572:	00 97       	sbiw	r24, 0x00	; 0
    5574:	61 f0       	breq	.+24     	; 0x558e <LCD_moveCursor+0x50>
    5576:	19 c0       	rjmp	.+50     	; 0x55aa <LCD_moveCursor+0x6c>
    5578:	2c 81       	ldd	r18, Y+4	; 0x04
    557a:	3d 81       	ldd	r19, Y+5	; 0x05
    557c:	22 30       	cpi	r18, 0x02	; 2
    557e:	31 05       	cpc	r19, r1
    5580:	69 f0       	breq	.+26     	; 0x559c <LCD_moveCursor+0x5e>
    5582:	8c 81       	ldd	r24, Y+4	; 0x04
    5584:	9d 81       	ldd	r25, Y+5	; 0x05
    5586:	83 30       	cpi	r24, 0x03	; 3
    5588:	91 05       	cpc	r25, r1
    558a:	61 f0       	breq	.+24     	; 0x55a4 <LCD_moveCursor+0x66>
    558c:	0e c0       	rjmp	.+28     	; 0x55aa <LCD_moveCursor+0x6c>
    {
    case 0:
      lcd_memory_address = col;
    558e:	8b 81       	ldd	r24, Y+3	; 0x03
    5590:	89 83       	std	Y+1, r24	; 0x01
    5592:	0b c0       	rjmp	.+22     	; 0x55aa <LCD_moveCursor+0x6c>
      break;
    case 1:
      lcd_memory_address = col + 0x40;
    5594:	8b 81       	ldd	r24, Y+3	; 0x03
    5596:	80 5c       	subi	r24, 0xC0	; 192
    5598:	89 83       	std	Y+1, r24	; 0x01
    559a:	07 c0       	rjmp	.+14     	; 0x55aa <LCD_moveCursor+0x6c>
      break;
    case 2:
      lcd_memory_address = col + 0x10;
    559c:	8b 81       	ldd	r24, Y+3	; 0x03
    559e:	80 5f       	subi	r24, 0xF0	; 240
    55a0:	89 83       	std	Y+1, r24	; 0x01
    55a2:	03 c0       	rjmp	.+6      	; 0x55aa <LCD_moveCursor+0x6c>
      break;
    case 3:
      lcd_memory_address = col + 0x50;
    55a4:	8b 81       	ldd	r24, Y+3	; 0x03
    55a6:	80 5b       	subi	r24, 0xB0	; 176
    55a8:	89 83       	std	Y+1, r24	; 0x01
      break;
    }
  /* Move the LCD cursor to this specific address */
  LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    55aa:	89 81       	ldd	r24, Y+1	; 0x01
    55ac:	80 68       	ori	r24, 0x80	; 128
    55ae:	0e 94 98 26 	call	0x4d30	; 0x4d30 <LCD_sendCommand>
}
    55b2:	0f 90       	pop	r0
    55b4:	0f 90       	pop	r0
    55b6:	0f 90       	pop	r0
    55b8:	0f 90       	pop	r0
    55ba:	0f 90       	pop	r0
    55bc:	cf 91       	pop	r28
    55be:	df 91       	pop	r29
    55c0:	08 95       	ret

000055c2 <LCD_displayStringRowColumn>:
 * @param row: The row index (0 or 1).
 * @param col: The column index (0 to 15).
 * @param Str: Pointer to the string to be displayed.
 */
void LCD_displayStringRowColumn(uint8 row, uint8 col, const char *Str)
{
    55c2:	df 93       	push	r29
    55c4:	cf 93       	push	r28
    55c6:	00 d0       	rcall	.+0      	; 0x55c8 <LCD_displayStringRowColumn+0x6>
    55c8:	00 d0       	rcall	.+0      	; 0x55ca <LCD_displayStringRowColumn+0x8>
    55ca:	cd b7       	in	r28, 0x3d	; 61
    55cc:	de b7       	in	r29, 0x3e	; 62
    55ce:	89 83       	std	Y+1, r24	; 0x01
    55d0:	6a 83       	std	Y+2, r22	; 0x02
    55d2:	5c 83       	std	Y+4, r21	; 0x04
    55d4:	4b 83       	std	Y+3, r20	; 0x03
  LCD_moveCursor(row, col); /* go to to the required LCD position */
    55d6:	89 81       	ldd	r24, Y+1	; 0x01
    55d8:	6a 81       	ldd	r22, Y+2	; 0x02
    55da:	0e 94 9f 2a 	call	0x553e	; 0x553e <LCD_moveCursor>
  LCD_displayString(Str); /* display the string */
    55de:	8b 81       	ldd	r24, Y+3	; 0x03
    55e0:	9c 81       	ldd	r25, Y+4	; 0x04
    55e2:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>
}
    55e6:	0f 90       	pop	r0
    55e8:	0f 90       	pop	r0
    55ea:	0f 90       	pop	r0
    55ec:	0f 90       	pop	r0
    55ee:	cf 91       	pop	r28
    55f0:	df 91       	pop	r29
    55f2:	08 95       	ret

000055f4 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    55f4:	df 93       	push	r29
    55f6:	cf 93       	push	r28
    55f8:	cd b7       	in	r28, 0x3d	; 61
    55fa:	de b7       	in	r29, 0x3e	; 62
  LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    55fc:	81 e0       	ldi	r24, 0x01	; 1
    55fe:	0e 94 98 26 	call	0x4d30	; 0x4d30 <LCD_sendCommand>
}
    5602:	cf 91       	pop	r28
    5604:	df 91       	pop	r29
    5606:	08 95       	ret

00005608 <LCD_cursorBlink>:

/*
 * Description: Sends the cursor blink command to the LCD.
 */
void LCD_cursorBlink(void)
{
    5608:	df 93       	push	r29
    560a:	cf 93       	push	r28
    560c:	cd b7       	in	r28, 0x3d	; 61
    560e:	de b7       	in	r29, 0x3e	; 62
  LCD_sendCommand(LCD_CURSOR_BLINK);
    5610:	8d e0       	ldi	r24, 0x0D	; 13
    5612:	0e 94 98 26 	call	0x4d30	; 0x4d30 <LCD_sendCommand>
}
    5616:	cf 91       	pop	r28
    5618:	df 91       	pop	r29
    561a:	08 95       	ret

0000561c <LCD_displayNumber>:
 * Description: Displays a decimal value on the LCD.
 *
 * @param data: The integer value to be displayed.
 */
void LCD_displayNumber(sint32 num)
{
    561c:	df 93       	push	r29
    561e:	cf 93       	push	r28
    5620:	cd b7       	in	r28, 0x3d	; 61
    5622:	de b7       	in	r29, 0x3e	; 62
    5624:	68 97       	sbiw	r28, 0x18	; 24
    5626:	0f b6       	in	r0, 0x3f	; 63
    5628:	f8 94       	cli
    562a:	de bf       	out	0x3e, r29	; 62
    562c:	0f be       	out	0x3f, r0	; 63
    562e:	cd bf       	out	0x3d, r28	; 61
    5630:	6d 8b       	std	Y+21, r22	; 0x15
    5632:	7e 8b       	std	Y+22, r23	; 0x16
    5634:	8f 8b       	std	Y+23, r24	; 0x17
    5636:	98 8f       	std	Y+24, r25	; 0x18
  /* Convert the number to a string and display it */
  char buffer[20]; /* Buffer to hold the converted number */
  ltoa(num, buffer, 10); /* Convert number to string in base 10 */
    5638:	8d 89       	ldd	r24, Y+21	; 0x15
    563a:	9e 89       	ldd	r25, Y+22	; 0x16
    563c:	af 89       	ldd	r26, Y+23	; 0x17
    563e:	b8 8d       	ldd	r27, Y+24	; 0x18
    5640:	bc 01       	movw	r22, r24
    5642:	cd 01       	movw	r24, r26
    5644:	9e 01       	movw	r18, r28
    5646:	2f 5f       	subi	r18, 0xFF	; 255
    5648:	3f 4f       	sbci	r19, 0xFF	; 255
    564a:	a9 01       	movw	r20, r18
    564c:	2a e0       	ldi	r18, 0x0A	; 10
    564e:	30 e0       	ldi	r19, 0x00	; 0
    5650:	0e 94 42 30 	call	0x6084	; 0x6084 <ltoa>
  LCD_displayString(buffer); /* Display the string representation of the number */
    5654:	ce 01       	movw	r24, r28
    5656:	01 96       	adiw	r24, 0x01	; 1
    5658:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>
}
    565c:	68 96       	adiw	r28, 0x18	; 24
    565e:	0f b6       	in	r0, 0x3f	; 63
    5660:	f8 94       	cli
    5662:	de bf       	out	0x3e, r29	; 62
    5664:	0f be       	out	0x3f, r0	; 63
    5666:	cd bf       	out	0x3d, r28	; 61
    5668:	cf 91       	pop	r28
    566a:	df 91       	pop	r29
    566c:	08 95       	ret

0000566e <KEYPAD_init>:
#endif /* STANDARD_KEYPAD */

#endif /* SPECIAL_KEYPAD */


void KEYPAD_init(void) {
    566e:	df 93       	push	r29
    5670:	cf 93       	push	r28
    5672:	00 d0       	rcall	.+0      	; 0x5674 <KEYPAD_init+0x6>
    5674:	cd b7       	in	r28, 0x3d	; 61
    5676:	de b7       	in	r29, 0x3e	; 62
  uint8 col = 0, row = 0;
    5678:	1a 82       	std	Y+2, r1	; 0x02
    567a:	19 82       	std	Y+1, r1	; 0x01
    567c:	08 c0       	rjmp	.+16     	; 0x568e <KEYPAD_init+0x20>

  // Set row pins as input
  for (; row < KEYPAD_NUM_ROWS; row++) {
    GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,
    567e:	81 e0       	ldi	r24, 0x01	; 1
    5680:	69 81       	ldd	r22, Y+1	; 0x01
    5682:	40 e0       	ldi	r20, 0x00	; 0
    5684:	0e 94 25 08 	call	0x104a	; 0x104a <GPIO_setupPinDirection>

void KEYPAD_init(void) {
  uint8 col = 0, row = 0;

  // Set row pins as input
  for (; row < KEYPAD_NUM_ROWS; row++) {
    5688:	89 81       	ldd	r24, Y+1	; 0x01
    568a:	8f 5f       	subi	r24, 0xFF	; 255
    568c:	89 83       	std	Y+1, r24	; 0x01
    568e:	89 81       	ldd	r24, Y+1	; 0x01
    5690:	84 30       	cpi	r24, 0x04	; 4
    5692:	a8 f3       	brcs	.-22     	; 0x567e <KEYPAD_init+0x10>
    5694:	0b c0       	rjmp	.+22     	; 0x56ac <KEYPAD_init+0x3e>
			   PIN_INPUT);
  }

  // Set column pins as input
  for (; col < KEYPAD_NUM_COLS; col++) {
    GPIO_setupPinDirection(KEYPAD_COL_PORT_ID,
    5696:	8a 81       	ldd	r24, Y+2	; 0x02
    5698:	98 2f       	mov	r25, r24
    569a:	9c 5f       	subi	r25, 0xFC	; 252
    569c:	81 e0       	ldi	r24, 0x01	; 1
    569e:	69 2f       	mov	r22, r25
    56a0:	40 e0       	ldi	r20, 0x00	; 0
    56a2:	0e 94 25 08 	call	0x104a	; 0x104a <GPIO_setupPinDirection>
    KEYPAD_FIRST_ROW_PIN_ID + row,
			   PIN_INPUT);
  }

  // Set column pins as input
  for (; col < KEYPAD_NUM_COLS; col++) {
    56a6:	8a 81       	ldd	r24, Y+2	; 0x02
    56a8:	8f 5f       	subi	r24, 0xFF	; 255
    56aa:	8a 83       	std	Y+2, r24	; 0x02
    56ac:	8a 81       	ldd	r24, Y+2	; 0x02
    56ae:	84 30       	cpi	r24, 0x04	; 4
    56b0:	90 f3       	brcs	.-28     	; 0x5696 <KEYPAD_init+0x28>
    GPIO_setupPinDirection(KEYPAD_COL_PORT_ID,
    KEYPAD_FIRST_COL_PIN_ID + col,
			   PIN_INPUT);
  }
}
    56b2:	0f 90       	pop	r0
    56b4:	0f 90       	pop	r0
    56b6:	cf 91       	pop	r28
    56b8:	df 91       	pop	r29
    56ba:	08 95       	ret

000056bc <KEYPAD_setKeys>:

#ifdef SPECIAL_KEYPAD
void KEYPAD_setKeys(const uint8 *keysO) {
    56bc:	df 93       	push	r29
    56be:	cf 93       	push	r28
    56c0:	00 d0       	rcall	.+0      	; 0x56c2 <KEYPAD_setKeys+0x6>
    56c2:	cd b7       	in	r28, 0x3d	; 61
    56c4:	de b7       	in	r29, 0x3e	; 62
    56c6:	9a 83       	std	Y+2, r25	; 0x02
    56c8:	89 83       	std	Y+1, r24	; 0x01
  g_keys = keysO;
    56ca:	89 81       	ldd	r24, Y+1	; 0x01
    56cc:	9a 81       	ldd	r25, Y+2	; 0x02
    56ce:	90 93 84 07 	sts	0x0784, r25
    56d2:	80 93 83 07 	sts	0x0783, r24
}
    56d6:	0f 90       	pop	r0
    56d8:	0f 90       	pop	r0
    56da:	cf 91       	pop	r28
    56dc:	df 91       	pop	r29
    56de:	08 95       	ret

000056e0 <KEYPAD_getPressedKey>:

/*
 * Description: Scans the keypad for any pressed keys. It returns the
 *              corresponding key value or KEYPAD_NO_KEY if no key is pressed.
 */
uint8 KEYPAD_getPressedKey(void) {
    56e0:	df 93       	push	r29
    56e2:	cf 93       	push	r28
    56e4:	cd b7       	in	r28, 0x3d	; 61
    56e6:	de b7       	in	r29, 0x3e	; 62
    56e8:	6f 97       	sbiw	r28, 0x1f	; 31
    56ea:	0f b6       	in	r0, 0x3f	; 63
    56ec:	f8 94       	cli
    56ee:	de bf       	out	0x3e, r29	; 62
    56f0:	0f be       	out	0x3f, r0	; 63
    56f2:	cd bf       	out	0x3d, r28	; 61
  uint8 col = 0, row = 0;
    56f4:	1f 8e       	std	Y+31, r1	; 0x1f
    56f6:	1e 8e       	std	Y+30, r1	; 0x1e
  uint8 key = KEYPAD_NO_KEY; // Initialize key variable
    56f8:	8f ef       	ldi	r24, 0xFF	; 255
    56fa:	8d 8f       	std	Y+29, r24	; 0x1d
    56fc:	29 c1       	rjmp	.+594    	; 0x5950 <KEYPAD_getPressedKey+0x270>
  // Loop through each row to check for key presses
  for (; row < KEYPAD_NUM_ROWS; row++) {
    /*
     * Set the current row as OUTPUT and clear its pin to indicate it is active.
     */
    GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,
    56fe:	81 e0       	ldi	r24, 0x01	; 1
    5700:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5702:	41 e0       	ldi	r20, 0x01	; 1
    5704:	0e 94 25 08 	call	0x104a	; 0x104a <GPIO_setupPinDirection>
    KEYPAD_FIRST_ROW_PIN_ID + row,
			   PIN_OUTPUT);

    // Activate the current row by setting it to LOW
    GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID + row,
    5708:	81 e0       	ldi	r24, 0x01	; 1
    570a:	6e 8d       	ldd	r22, Y+30	; 0x1e
    570c:	40 e0       	ldi	r20, 0x00	; 0
    570e:	0e 94 10 09 	call	0x1220	; 0x1220 <GPIO_writePin>
    KEYPAD_BUTTON_PRESSED);

    // Loop through each column to check if any key is pressed
    for (col = 0; col < KEYPAD_NUM_COLS; col++) {
    5712:	1f 8e       	std	Y+31, r1	; 0x1f
    5714:	9f c0       	rjmp	.+318    	; 0x5854 <KEYPAD_getPressedKey+0x174>
      /* Check if the switch is pressed in this column */
      if (GPIO_readPin(KEYPAD_COL_PORT_ID,
    5716:	8f 8d       	ldd	r24, Y+31	; 0x1f
    5718:	98 2f       	mov	r25, r24
    571a:	9c 5f       	subi	r25, 0xFC	; 252
    571c:	81 e0       	ldi	r24, 0x01	; 1
    571e:	69 2f       	mov	r22, r25
    5720:	0e 94 80 0a 	call	0x1500	; 0x1500 <GPIO_readPin>
    5724:	88 23       	and	r24, r24
    5726:	09 f0       	breq	.+2      	; 0x572a <KEYPAD_getPressedKey+0x4a>
    5728:	92 c0       	rjmp	.+292    	; 0x584e <KEYPAD_getPressedKey+0x16e>
    572a:	80 e0       	ldi	r24, 0x00	; 0
    572c:	90 e0       	ldi	r25, 0x00	; 0
    572e:	a0 ea       	ldi	r26, 0xA0	; 160
    5730:	b1 e4       	ldi	r27, 0x41	; 65
    5732:	89 8f       	std	Y+25, r24	; 0x19
    5734:	9a 8f       	std	Y+26, r25	; 0x1a
    5736:	ab 8f       	std	Y+27, r26	; 0x1b
    5738:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    573a:	69 8d       	ldd	r22, Y+25	; 0x19
    573c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    573e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5740:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5742:	20 e0       	ldi	r18, 0x00	; 0
    5744:	30 e0       	ldi	r19, 0x00	; 0
    5746:	4a ef       	ldi	r20, 0xFA	; 250
    5748:	54 e4       	ldi	r21, 0x44	; 68
    574a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    574e:	dc 01       	movw	r26, r24
    5750:	cb 01       	movw	r24, r22
    5752:	8d 8b       	std	Y+21, r24	; 0x15
    5754:	9e 8b       	std	Y+22, r25	; 0x16
    5756:	af 8b       	std	Y+23, r26	; 0x17
    5758:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    575a:	6d 89       	ldd	r22, Y+21	; 0x15
    575c:	7e 89       	ldd	r23, Y+22	; 0x16
    575e:	8f 89       	ldd	r24, Y+23	; 0x17
    5760:	98 8d       	ldd	r25, Y+24	; 0x18
    5762:	20 e0       	ldi	r18, 0x00	; 0
    5764:	30 e0       	ldi	r19, 0x00	; 0
    5766:	40 e8       	ldi	r20, 0x80	; 128
    5768:	5f e3       	ldi	r21, 0x3F	; 63
    576a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    576e:	88 23       	and	r24, r24
    5770:	2c f4       	brge	.+10     	; 0x577c <KEYPAD_getPressedKey+0x9c>
		__ticks = 1;
    5772:	81 e0       	ldi	r24, 0x01	; 1
    5774:	90 e0       	ldi	r25, 0x00	; 0
    5776:	9c 8b       	std	Y+20, r25	; 0x14
    5778:	8b 8b       	std	Y+19, r24	; 0x13
    577a:	3f c0       	rjmp	.+126    	; 0x57fa <KEYPAD_getPressedKey+0x11a>
	else if (__tmp > 65535)
    577c:	6d 89       	ldd	r22, Y+21	; 0x15
    577e:	7e 89       	ldd	r23, Y+22	; 0x16
    5780:	8f 89       	ldd	r24, Y+23	; 0x17
    5782:	98 8d       	ldd	r25, Y+24	; 0x18
    5784:	20 e0       	ldi	r18, 0x00	; 0
    5786:	3f ef       	ldi	r19, 0xFF	; 255
    5788:	4f e7       	ldi	r20, 0x7F	; 127
    578a:	57 e4       	ldi	r21, 0x47	; 71
    578c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5790:	18 16       	cp	r1, r24
    5792:	4c f5       	brge	.+82     	; 0x57e6 <KEYPAD_getPressedKey+0x106>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5794:	69 8d       	ldd	r22, Y+25	; 0x19
    5796:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5798:	8b 8d       	ldd	r24, Y+27	; 0x1b
    579a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    579c:	20 e0       	ldi	r18, 0x00	; 0
    579e:	30 e0       	ldi	r19, 0x00	; 0
    57a0:	40 e2       	ldi	r20, 0x20	; 32
    57a2:	51 e4       	ldi	r21, 0x41	; 65
    57a4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    57a8:	dc 01       	movw	r26, r24
    57aa:	cb 01       	movw	r24, r22
    57ac:	bc 01       	movw	r22, r24
    57ae:	cd 01       	movw	r24, r26
    57b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    57b4:	dc 01       	movw	r26, r24
    57b6:	cb 01       	movw	r24, r22
    57b8:	9c 8b       	std	Y+20, r25	; 0x14
    57ba:	8b 8b       	std	Y+19, r24	; 0x13
    57bc:	0f c0       	rjmp	.+30     	; 0x57dc <KEYPAD_getPressedKey+0xfc>
    57be:	88 ec       	ldi	r24, 0xC8	; 200
    57c0:	90 e0       	ldi	r25, 0x00	; 0
    57c2:	9a 8b       	std	Y+18, r25	; 0x12
    57c4:	89 8b       	std	Y+17, r24	; 0x11
    57c6:	89 89       	ldd	r24, Y+17	; 0x11
    57c8:	9a 89       	ldd	r25, Y+18	; 0x12
    57ca:	01 97       	sbiw	r24, 0x01	; 1
    57cc:	f1 f7       	brne	.-4      	; 0x57ca <KEYPAD_getPressedKey+0xea>
    57ce:	9a 8b       	std	Y+18, r25	; 0x12
    57d0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    57d2:	8b 89       	ldd	r24, Y+19	; 0x13
    57d4:	9c 89       	ldd	r25, Y+20	; 0x14
    57d6:	01 97       	sbiw	r24, 0x01	; 1
    57d8:	9c 8b       	std	Y+20, r25	; 0x14
    57da:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57dc:	8b 89       	ldd	r24, Y+19	; 0x13
    57de:	9c 89       	ldd	r25, Y+20	; 0x14
    57e0:	00 97       	sbiw	r24, 0x00	; 0
    57e2:	69 f7       	brne	.-38     	; 0x57be <KEYPAD_getPressedKey+0xde>
    57e4:	14 c0       	rjmp	.+40     	; 0x580e <KEYPAD_getPressedKey+0x12e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57e6:	6d 89       	ldd	r22, Y+21	; 0x15
    57e8:	7e 89       	ldd	r23, Y+22	; 0x16
    57ea:	8f 89       	ldd	r24, Y+23	; 0x17
    57ec:	98 8d       	ldd	r25, Y+24	; 0x18
    57ee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    57f2:	dc 01       	movw	r26, r24
    57f4:	cb 01       	movw	r24, r22
    57f6:	9c 8b       	std	Y+20, r25	; 0x14
    57f8:	8b 8b       	std	Y+19, r24	; 0x13
    57fa:	8b 89       	ldd	r24, Y+19	; 0x13
    57fc:	9c 89       	ldd	r25, Y+20	; 0x14
    57fe:	98 8b       	std	Y+16, r25	; 0x10
    5800:	8f 87       	std	Y+15, r24	; 0x0f
    5802:	8f 85       	ldd	r24, Y+15	; 0x0f
    5804:	98 89       	ldd	r25, Y+16	; 0x10
    5806:	01 97       	sbiw	r24, 0x01	; 1
    5808:	f1 f7       	brne	.-4      	; 0x5806 <KEYPAD_getPressedKey+0x126>
    580a:	98 8b       	std	Y+16, r25	; 0x10
    580c:	8f 87       	std	Y+15, r24	; 0x0f
      KEYPAD_FIRST_COL_PIN_ID + col) == KEYPAD_BUTTON_PRESSED) {
	_delay_ms(20); // Delay for debouncing
	// Wait until the key is released
	while (GPIO_readPin(KEYPAD_COL_PORT_ID,
    580e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    5810:	98 2f       	mov	r25, r24
    5812:	9c 5f       	subi	r25, 0xFC	; 252
    5814:	81 e0       	ldi	r24, 0x01	; 1
    5816:	69 2f       	mov	r22, r25
    5818:	0e 94 80 0a 	call	0x1500	; 0x1500 <GPIO_readPin>
    581c:	88 23       	and	r24, r24
    581e:	b9 f3       	breq	.-18     	; 0x580e <KEYPAD_getPressedKey+0x12e>
	KEYPAD_FIRST_COL_PIN_ID + col) == KEYPAD_BUTTON_PRESSED)
	  ;
#ifdef SPECIAL_KEYPAD
	key = g_keys[(row * KEYPAD_NUM_COLS) + col];
    5820:	40 91 83 07 	lds	r20, 0x0783
    5824:	50 91 84 07 	lds	r21, 0x0784
    5828:	8e 8d       	ldd	r24, Y+30	; 0x1e
    582a:	88 2f       	mov	r24, r24
    582c:	90 e0       	ldi	r25, 0x00	; 0
    582e:	9c 01       	movw	r18, r24
    5830:	22 0f       	add	r18, r18
    5832:	33 1f       	adc	r19, r19
    5834:	22 0f       	add	r18, r18
    5836:	33 1f       	adc	r19, r19
    5838:	8f 8d       	ldd	r24, Y+31	; 0x1f
    583a:	88 2f       	mov	r24, r24
    583c:	90 e0       	ldi	r25, 0x00	; 0
    583e:	82 0f       	add	r24, r18
    5840:	93 1f       	adc	r25, r19
    5842:	fa 01       	movw	r30, r20
    5844:	e8 0f       	add	r30, r24
    5846:	f9 1f       	adc	r31, r25
    5848:	80 81       	ld	r24, Z
    584a:	8d 8f       	std	Y+29, r24	; 0x1d
    584c:	07 c0       	rjmp	.+14     	; 0x585c <KEYPAD_getPressedKey+0x17c>
    // Activate the current row by setting it to LOW
    GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID + row,
    KEYPAD_BUTTON_PRESSED);

    // Loop through each column to check if any key is pressed
    for (col = 0; col < KEYPAD_NUM_COLS; col++) {
    584e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    5850:	8f 5f       	subi	r24, 0xFF	; 255
    5852:	8f 8f       	std	Y+31, r24	; 0x1f
    5854:	8f 8d       	ldd	r24, Y+31	; 0x1f
    5856:	84 30       	cpi	r24, 0x04	; 4
    5858:	08 f4       	brcc	.+2      	; 0x585c <KEYPAD_getPressedKey+0x17c>
    585a:	5d cf       	rjmp	.-326    	; 0x5716 <KEYPAD_getPressedKey+0x36>
#endif /* SPECIAL_KEYPAD */
	break;
      }
    }
    // Reset the row pin direction to INPUT after scanning
    GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,
    585c:	81 e0       	ldi	r24, 0x01	; 1
    585e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    5860:	40 e0       	ldi	r20, 0x00	; 0
    5862:	0e 94 25 08 	call	0x104a	; 0x104a <GPIO_setupPinDirection>
    5866:	80 e0       	ldi	r24, 0x00	; 0
    5868:	90 e0       	ldi	r25, 0x00	; 0
    586a:	a0 ea       	ldi	r26, 0xA0	; 160
    586c:	b0 e4       	ldi	r27, 0x40	; 64
    586e:	8b 87       	std	Y+11, r24	; 0x0b
    5870:	9c 87       	std	Y+12, r25	; 0x0c
    5872:	ad 87       	std	Y+13, r26	; 0x0d
    5874:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5876:	6b 85       	ldd	r22, Y+11	; 0x0b
    5878:	7c 85       	ldd	r23, Y+12	; 0x0c
    587a:	8d 85       	ldd	r24, Y+13	; 0x0d
    587c:	9e 85       	ldd	r25, Y+14	; 0x0e
    587e:	20 e0       	ldi	r18, 0x00	; 0
    5880:	30 e0       	ldi	r19, 0x00	; 0
    5882:	4a ef       	ldi	r20, 0xFA	; 250
    5884:	54 e4       	ldi	r21, 0x44	; 68
    5886:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    588a:	dc 01       	movw	r26, r24
    588c:	cb 01       	movw	r24, r22
    588e:	8f 83       	std	Y+7, r24	; 0x07
    5890:	98 87       	std	Y+8, r25	; 0x08
    5892:	a9 87       	std	Y+9, r26	; 0x09
    5894:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5896:	6f 81       	ldd	r22, Y+7	; 0x07
    5898:	78 85       	ldd	r23, Y+8	; 0x08
    589a:	89 85       	ldd	r24, Y+9	; 0x09
    589c:	9a 85       	ldd	r25, Y+10	; 0x0a
    589e:	20 e0       	ldi	r18, 0x00	; 0
    58a0:	30 e0       	ldi	r19, 0x00	; 0
    58a2:	40 e8       	ldi	r20, 0x80	; 128
    58a4:	5f e3       	ldi	r21, 0x3F	; 63
    58a6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    58aa:	88 23       	and	r24, r24
    58ac:	2c f4       	brge	.+10     	; 0x58b8 <KEYPAD_getPressedKey+0x1d8>
		__ticks = 1;
    58ae:	81 e0       	ldi	r24, 0x01	; 1
    58b0:	90 e0       	ldi	r25, 0x00	; 0
    58b2:	9e 83       	std	Y+6, r25	; 0x06
    58b4:	8d 83       	std	Y+5, r24	; 0x05
    58b6:	3f c0       	rjmp	.+126    	; 0x5936 <KEYPAD_getPressedKey+0x256>
	else if (__tmp > 65535)
    58b8:	6f 81       	ldd	r22, Y+7	; 0x07
    58ba:	78 85       	ldd	r23, Y+8	; 0x08
    58bc:	89 85       	ldd	r24, Y+9	; 0x09
    58be:	9a 85       	ldd	r25, Y+10	; 0x0a
    58c0:	20 e0       	ldi	r18, 0x00	; 0
    58c2:	3f ef       	ldi	r19, 0xFF	; 255
    58c4:	4f e7       	ldi	r20, 0x7F	; 127
    58c6:	57 e4       	ldi	r21, 0x47	; 71
    58c8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    58cc:	18 16       	cp	r1, r24
    58ce:	4c f5       	brge	.+82     	; 0x5922 <KEYPAD_getPressedKey+0x242>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    58d0:	6b 85       	ldd	r22, Y+11	; 0x0b
    58d2:	7c 85       	ldd	r23, Y+12	; 0x0c
    58d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    58d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    58d8:	20 e0       	ldi	r18, 0x00	; 0
    58da:	30 e0       	ldi	r19, 0x00	; 0
    58dc:	40 e2       	ldi	r20, 0x20	; 32
    58de:	51 e4       	ldi	r21, 0x41	; 65
    58e0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    58e4:	dc 01       	movw	r26, r24
    58e6:	cb 01       	movw	r24, r22
    58e8:	bc 01       	movw	r22, r24
    58ea:	cd 01       	movw	r24, r26
    58ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    58f0:	dc 01       	movw	r26, r24
    58f2:	cb 01       	movw	r24, r22
    58f4:	9e 83       	std	Y+6, r25	; 0x06
    58f6:	8d 83       	std	Y+5, r24	; 0x05
    58f8:	0f c0       	rjmp	.+30     	; 0x5918 <KEYPAD_getPressedKey+0x238>
    58fa:	88 ec       	ldi	r24, 0xC8	; 200
    58fc:	90 e0       	ldi	r25, 0x00	; 0
    58fe:	9c 83       	std	Y+4, r25	; 0x04
    5900:	8b 83       	std	Y+3, r24	; 0x03
    5902:	8b 81       	ldd	r24, Y+3	; 0x03
    5904:	9c 81       	ldd	r25, Y+4	; 0x04
    5906:	01 97       	sbiw	r24, 0x01	; 1
    5908:	f1 f7       	brne	.-4      	; 0x5906 <KEYPAD_getPressedKey+0x226>
    590a:	9c 83       	std	Y+4, r25	; 0x04
    590c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    590e:	8d 81       	ldd	r24, Y+5	; 0x05
    5910:	9e 81       	ldd	r25, Y+6	; 0x06
    5912:	01 97       	sbiw	r24, 0x01	; 1
    5914:	9e 83       	std	Y+6, r25	; 0x06
    5916:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5918:	8d 81       	ldd	r24, Y+5	; 0x05
    591a:	9e 81       	ldd	r25, Y+6	; 0x06
    591c:	00 97       	sbiw	r24, 0x00	; 0
    591e:	69 f7       	brne	.-38     	; 0x58fa <KEYPAD_getPressedKey+0x21a>
    5920:	14 c0       	rjmp	.+40     	; 0x594a <KEYPAD_getPressedKey+0x26a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5922:	6f 81       	ldd	r22, Y+7	; 0x07
    5924:	78 85       	ldd	r23, Y+8	; 0x08
    5926:	89 85       	ldd	r24, Y+9	; 0x09
    5928:	9a 85       	ldd	r25, Y+10	; 0x0a
    592a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    592e:	dc 01       	movw	r26, r24
    5930:	cb 01       	movw	r24, r22
    5932:	9e 83       	std	Y+6, r25	; 0x06
    5934:	8d 83       	std	Y+5, r24	; 0x05
    5936:	8d 81       	ldd	r24, Y+5	; 0x05
    5938:	9e 81       	ldd	r25, Y+6	; 0x06
    593a:	9a 83       	std	Y+2, r25	; 0x02
    593c:	89 83       	std	Y+1, r24	; 0x01
    593e:	89 81       	ldd	r24, Y+1	; 0x01
    5940:	9a 81       	ldd	r25, Y+2	; 0x02
    5942:	01 97       	sbiw	r24, 0x01	; 1
    5944:	f1 f7       	brne	.-4      	; 0x5942 <KEYPAD_getPressedKey+0x262>
    5946:	9a 83       	std	Y+2, r25	; 0x02
    5948:	89 83       	std	Y+1, r24	; 0x01
uint8 KEYPAD_getPressedKey(void) {
  uint8 col = 0, row = 0;
  uint8 key = KEYPAD_NO_KEY; // Initialize key variable

  // Loop through each row to check for key presses
  for (; row < KEYPAD_NUM_ROWS; row++) {
    594a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    594c:	8f 5f       	subi	r24, 0xFF	; 255
    594e:	8e 8f       	std	Y+30, r24	; 0x1e
    5950:	8e 8d       	ldd	r24, Y+30	; 0x1e
    5952:	84 30       	cpi	r24, 0x04	; 4
    5954:	08 f4       	brcc	.+2      	; 0x5958 <KEYPAD_getPressedKey+0x278>
    5956:	d3 ce       	rjmp	.-602    	; 0x56fe <KEYPAD_getPressedKey+0x1e>
    KEYPAD_FIRST_ROW_PIN_ID + row,
			   PIN_INPUT);
    _delay_ms(5); /* Small delay to fix CPU load issue in Proteus */
  }

  return key; // Return the detected key value
    5958:	8d 8d       	ldd	r24, Y+29	; 0x1d
}
    595a:	6f 96       	adiw	r28, 0x1f	; 31
    595c:	0f b6       	in	r0, 0x3f	; 63
    595e:	f8 94       	cli
    5960:	de bf       	out	0x3e, r29	; 62
    5962:	0f be       	out	0x3f, r0	; 63
    5964:	cd bf       	out	0x3d, r28	; 61
    5966:	cf 91       	pop	r28
    5968:	df 91       	pop	r29
    596a:	08 95       	ret

0000596c <KEYPAD_getPressedKeyBlocking>:
/*
 * Description: Blocks execution until a key is pressed on the keypad.
 *              This function continuously checks for key presses and
 *              returns the detected key value when one is pressed.
 */
uint8 KEYPAD_getPressedKeyBlocking(void) {
    596c:	df 93       	push	r29
    596e:	cf 93       	push	r28
    5970:	0f 92       	push	r0
    5972:	cd b7       	in	r28, 0x3d	; 61
    5974:	de b7       	in	r29, 0x3e	; 62
  uint8 input = KEYPAD_NO_KEY; // Initialize input variable
    5976:	8f ef       	ldi	r24, 0xFF	; 255
    5978:	89 83       	std	Y+1, r24	; 0x01
    597a:	03 c0       	rjmp	.+6      	; 0x5982 <KEYPAD_getPressedKeyBlocking+0x16>
  while (input == KEYPAD_NO_KEY) { // Loop until a key is detected
    input = KEYPAD_getPressedKey(); // Get the pressed key
    597c:	0e 94 70 2b 	call	0x56e0	; 0x56e0 <KEYPAD_getPressedKey>
    5980:	89 83       	std	Y+1, r24	; 0x01
 *              This function continuously checks for key presses and
 *              returns the detected key value when one is pressed.
 */
uint8 KEYPAD_getPressedKeyBlocking(void) {
  uint8 input = KEYPAD_NO_KEY; // Initialize input variable
  while (input == KEYPAD_NO_KEY) { // Loop until a key is detected
    5982:	89 81       	ldd	r24, Y+1	; 0x01
    5984:	8f 3f       	cpi	r24, 0xFF	; 255
    5986:	d1 f3       	breq	.-12     	; 0x597c <KEYPAD_getPressedKeyBlocking+0x10>
    input = KEYPAD_getPressedKey(); // Get the pressed key
  }
  return input; // Return the detected key value
    5988:	89 81       	ldd	r24, Y+1	; 0x01
}
    598a:	0f 90       	pop	r0
    598c:	cf 91       	pop	r28
    598e:	df 91       	pop	r29
    5990:	08 95       	ret

00005992 <HI_task>:

/* Manage door control based on conditions */
static void HI_handleDoor(void);


void HI_task(void *pvParameters) {
    5992:	df 93       	push	r29
    5994:	cf 93       	push	r28
    5996:	00 d0       	rcall	.+0      	; 0x5998 <HI_task+0x6>
    5998:	00 d0       	rcall	.+0      	; 0x599a <HI_task+0x8>
    599a:	cd b7       	in	r28, 0x3d	; 61
    599c:	de b7       	in	r29, 0x3e	; 62
    599e:	9b 83       	std	Y+3, r25	; 0x03
    59a0:	8a 83       	std	Y+2, r24	; 0x02
	/** Initialize task components such as the LCD and keypad. */
	HI_taskInit();
    59a2:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <HI_taskInit>

	/** Check if a password exists and log in if necessary. */
	HI_checkPassExistAndLogIn();
    59a6:	0e 94 b2 2e 	call	0x5d64	; 0x5d64 <HI_checkPassExistAndLogIn>

	/** Infinite loop to handle user interactions. */
	for (;;) {

		/** Display options for the user on the LCD. */
		LCD_clearScreen();
    59aa:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>
		LCD_displayStringRowColumn(0, 1, "+ : Open Door");
    59ae:	25 e6       	ldi	r18, 0x65	; 101
    59b0:	30 e0       	ldi	r19, 0x00	; 0
    59b2:	80 e0       	ldi	r24, 0x00	; 0
    59b4:	61 e0       	ldi	r22, 0x01	; 1
    59b6:	a9 01       	movw	r20, r18
    59b8:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <LCD_displayStringRowColumn>
		LCD_displayStringRowColumn(1, 1, "- : Change Pass");
    59bc:	23 e7       	ldi	r18, 0x73	; 115
    59be:	30 e0       	ldi	r19, 0x00	; 0
    59c0:	81 e0       	ldi	r24, 0x01	; 1
    59c2:	61 e0       	ldi	r22, 0x01	; 1
    59c4:	a9 01       	movw	r20, r18
    59c6:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <LCD_displayStringRowColumn>

		/** Wait for a key press from the keypad. */
		key = KEYPAD_getPressedKeyBlocking();
    59ca:	0e 94 b6 2c 	call	0x596c	; 0x596c <KEYPAD_getPressedKeyBlocking>
    59ce:	80 93 87 07 	sts	0x0787, r24

		/** Check if the pressed key is for opening the door or changing the password. */
		if (key == '-' || key == '+') {
    59d2:	80 91 87 07 	lds	r24, 0x0787
    59d6:	8d 32       	cpi	r24, 0x2D	; 45
    59d8:	21 f0       	breq	.+8      	; 0x59e2 <HI_task+0x50>
    59da:	80 91 87 07 	lds	r24, 0x0787
    59de:	8b 32       	cpi	r24, 0x2B	; 43
    59e0:	21 f7       	brne	.-56     	; 0x59aa <HI_task+0x18>
			/** Set the action based on the pressed key. */
			g_sendValue = (key == '+') ? SHARED_OPEN_DOOR : SHARED_CHANGE_PASS;
    59e2:	80 91 87 07 	lds	r24, 0x0787
    59e6:	8b 32       	cpi	r24, 0x2B	; 43
    59e8:	19 f4       	brne	.+6      	; 0x59f0 <HI_task+0x5e>
    59ea:	8b e2       	ldi	r24, 0x2B	; 43
    59ec:	8c 83       	std	Y+4, r24	; 0x04
    59ee:	02 c0       	rjmp	.+4      	; 0x59f4 <HI_task+0x62>
    59f0:	8d e2       	ldi	r24, 0x2D	; 45
    59f2:	8c 83       	std	Y+4, r24	; 0x04
    59f4:	8c 81       	ldd	r24, Y+4	; 0x04
    59f6:	80 93 85 07 	sts	0x0785, r24
			uint8 keyTemp = key;
    59fa:	80 91 87 07 	lds	r24, 0x0787
    59fe:	89 83       	std	Y+1, r24	; 0x01
			/** Send the action to the queue. */
			if (xQueueSend(g_xQueueSend, &g_sendValue, (TickType_t)20) == pdPASS) {
    5a00:	80 91 8a 07 	lds	r24, 0x078A
    5a04:	90 91 8b 07 	lds	r25, 0x078B
    5a08:	25 e8       	ldi	r18, 0x85	; 133
    5a0a:	37 e0       	ldi	r19, 0x07	; 7
    5a0c:	b9 01       	movw	r22, r18
    5a0e:	44 e1       	ldi	r20, 0x14	; 20
    5a10:	50 e0       	ldi	r21, 0x00	; 0
    5a12:	20 e0       	ldi	r18, 0x00	; 0
    5a14:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <xQueueGenericSend>
				/** Message sent successfully */
			}

			/** Check if the entered password is correct. */
			if (HI_getAndCheckPass() == TRUE) {
    5a18:	0e 94 cf 2d 	call	0x5b9e	; 0x5b9e <HI_getAndCheckPass>
    5a1c:	81 30       	cpi	r24, 0x01	; 1
    5a1e:	29 f6       	brne	.-118    	; 0x59aa <HI_task+0x18>
				if (keyTemp == '+') {
    5a20:	89 81       	ldd	r24, Y+1	; 0x01
    5a22:	8b 32       	cpi	r24, 0x2B	; 43
    5a24:	19 f4       	brne	.+6      	; 0x5a2c <HI_task+0x9a>
					HI_handleDoor();
    5a26:	0e 94 eb 2e 	call	0x5dd6	; 0x5dd6 <HI_handleDoor>
    5a2a:	bf cf       	rjmp	.-130    	; 0x59aa <HI_task+0x18>
				} else {
					if (HI_updatePass() == TRUE) {
    5a2c:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <HI_updatePass>
    5a30:	81 30       	cpi	r24, 0x01	; 1
    5a32:	09 f0       	breq	.+2      	; 0x5a36 <HI_task+0xa4>
    5a34:	ba cf       	rjmp	.-140    	; 0x59aa <HI_task+0x18>
						/** Notify the user that the password has been successfully changed. */
						LCD_displayString("Pass Changed");
    5a36:	83 e8       	ldi	r24, 0x83	; 131
    5a38:	90 e0       	ldi	r25, 0x00	; 0
    5a3a:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>
						/** Delay to allow the user to read the message. */
						vTaskDelay(DELAY_TIME);
    5a3e:	84 ef       	ldi	r24, 0xF4	; 244
    5a40:	91 e0       	ldi	r25, 0x01	; 1
    5a42:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <vTaskDelay>
    5a46:	b1 cf       	rjmp	.-158    	; 0x59aa <HI_task+0x18>

00005a48 <HI_passTimesOut>:
/**
 * @brief Handles the timeout situation for password attempts.
 *
 * This function activates the buzzer and displays a locked message for a defined time period.
 */
static void HI_passTimesOut(void) {
    5a48:	df 93       	push	r29
    5a4a:	cf 93       	push	r28
    5a4c:	0f 92       	push	r0
    5a4e:	cd b7       	in	r28, 0x3d	; 61
    5a50:	de b7       	in	r29, 0x3e	; 62
	/** Set the value to indicate the buzzer should be turned on. */
	g_sendValue = SHARED_BUZZER_ON;
    5a52:	88 e0       	ldi	r24, 0x08	; 8
    5a54:	80 93 85 07 	sts	0x0785, r24

	/** Attempt to send the buzzer on message to the queue. */
	if (xQueueSend(g_xQueueSend, &g_sendValue, (TickType_t)20) == pdPASS) {
    5a58:	80 91 8a 07 	lds	r24, 0x078A
    5a5c:	90 91 8b 07 	lds	r25, 0x078B
    5a60:	25 e8       	ldi	r18, 0x85	; 133
    5a62:	37 e0       	ldi	r19, 0x07	; 7
    5a64:	b9 01       	movw	r22, r18
    5a66:	44 e1       	ldi	r20, 0x14	; 20
    5a68:	50 e0       	ldi	r21, 0x00	; 0
    5a6a:	20 e0       	ldi	r18, 0x00	; 0
    5a6c:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <xQueueGenericSend>
		/** Message sent successfully */
	}

	/** Display a message indicating that the system is locked. */
	LCD_clearScreen();
    5a70:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>
	LCD_displayString("System Locked");
    5a74:	80 e9       	ldi	r24, 0x90	; 144
    5a76:	90 e0       	ldi	r25, 0x00	; 0
    5a78:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>
	LCD_displayStringRowColumn(1, 0, "Wait For");
    5a7c:	2e e9       	ldi	r18, 0x9E	; 158
    5a7e:	30 e0       	ldi	r19, 0x00	; 0
    5a80:	81 e0       	ldi	r24, 0x01	; 1
    5a82:	60 e0       	ldi	r22, 0x00	; 0
    5a84:	a9 01       	movw	r20, r18
    5a86:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <LCD_displayStringRowColumn>

	uint8 timeToWait = PASS_TIME_TO_WAIT; 	/* Time to wait during certain operations 	*/
    5a8a:	8c e3       	ldi	r24, 0x3C	; 60
    5a8c:	89 83       	std	Y+1, r24	; 0x01
    5a8e:	18 c0       	rjmp	.+48     	; 0x5ac0 <HI_passTimesOut+0x78>

	/** Countdown while timeToWait is not zero. */
	while (timeToWait != 0) {
		/** Display the remaining time on the LCD. */
		LCD_moveCursor(1, 9);
    5a90:	81 e0       	ldi	r24, 0x01	; 1
    5a92:	69 e0       	ldi	r22, 0x09	; 9
    5a94:	0e 94 9f 2a 	call	0x553e	; 0x553e <LCD_moveCursor>
		LCD_displayNumber(timeToWait);
    5a98:	89 81       	ldd	r24, Y+1	; 0x01
    5a9a:	88 2f       	mov	r24, r24
    5a9c:	90 e0       	ldi	r25, 0x00	; 0
    5a9e:	a0 e0       	ldi	r26, 0x00	; 0
    5aa0:	b0 e0       	ldi	r27, 0x00	; 0
    5aa2:	bc 01       	movw	r22, r24
    5aa4:	cd 01       	movw	r24, r26
    5aa6:	0e 94 0e 2b 	call	0x561c	; 0x561c <LCD_displayNumber>
		LCD_displayString(" Sec ");
    5aaa:	87 ea       	ldi	r24, 0xA7	; 167
    5aac:	90 e0       	ldi	r25, 0x00	; 0
    5aae:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

		/** Delay for a predefined period to manage the countdown timing. */
		vTaskDelay(LOCK_DELAY_TIME);
    5ab2:	88 ee       	ldi	r24, 0xE8	; 232
    5ab4:	93 e0       	ldi	r25, 0x03	; 3
    5ab6:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <vTaskDelay>

		/** Decrement the countdown timer. */
		timeToWait--;
    5aba:	89 81       	ldd	r24, Y+1	; 0x01
    5abc:	81 50       	subi	r24, 0x01	; 1
    5abe:	89 83       	std	Y+1, r24	; 0x01
	LCD_displayStringRowColumn(1, 0, "Wait For");

	uint8 timeToWait = PASS_TIME_TO_WAIT; 	/* Time to wait during certain operations 	*/

	/** Countdown while timeToWait is not zero. */
	while (timeToWait != 0) {
    5ac0:	89 81       	ldd	r24, Y+1	; 0x01
    5ac2:	88 23       	and	r24, r24
    5ac4:	29 f7       	brne	.-54     	; 0x5a90 <HI_passTimesOut+0x48>
		/** Decrement the countdown timer. */
		timeToWait--;
	}

	/** Set the value to indicate the buzzer should be turned off. */
	g_sendValue = SHARED_BUZZER_OFF;
    5ac6:	89 e0       	ldi	r24, 0x09	; 9
    5ac8:	80 93 85 07 	sts	0x0785, r24

	/** Attempt to send the buzzer off message to the queue. */
	if (xQueueSend(g_xQueueSend, &g_sendValue, (TickType_t)20) == pdPASS) {
    5acc:	80 91 8a 07 	lds	r24, 0x078A
    5ad0:	90 91 8b 07 	lds	r25, 0x078B
    5ad4:	25 e8       	ldi	r18, 0x85	; 133
    5ad6:	37 e0       	ldi	r19, 0x07	; 7
    5ad8:	b9 01       	movw	r22, r18
    5ada:	44 e1       	ldi	r20, 0x14	; 20
    5adc:	50 e0       	ldi	r21, 0x00	; 0
    5ade:	20 e0       	ldi	r18, 0x00	; 0
    5ae0:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <xQueueGenericSend>
		/** Message sent successfully */
	}
}
    5ae4:	0f 90       	pop	r0
    5ae6:	cf 91       	pop	r28
    5ae8:	df 91       	pop	r29
    5aea:	08 95       	ret

00005aec <HI_showControlError>:
/**
 * @brief Displays a control error message.
 *
 * This function indicates a control error to the user.
 */
static void HI_showControlError(void) {
    5aec:	df 93       	push	r29
    5aee:	cf 93       	push	r28
    5af0:	cd b7       	in	r28, 0x3d	; 61
    5af2:	de b7       	in	r29, 0x3e	; 62
	/** Display a message indicating there was a control error. */
	LCD_displayString("Control Error");
    5af4:	8d ea       	ldi	r24, 0xAD	; 173
    5af6:	90 e0       	ldi	r25, 0x00	; 0
    5af8:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

	/** Delay for a predefined period to allow the user to read the message. */
	vTaskDelay(DELAY_TIME);
    5afc:	84 ef       	ldi	r24, 0xF4	; 244
    5afe:	91 e0       	ldi	r25, 0x01	; 1
    5b00:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <vTaskDelay>
}
    5b04:	cf 91       	pop	r28
    5b06:	df 91       	pop	r29
    5b08:	08 95       	ret

00005b0a <HI_enterPassword>:
/**
 * @brief Prompts the user to enter a password.
 *
 * This function displays a prompt for the user to enter a password using the keypad.
 */
static void HI_enterPassword(void) {
    5b0a:	df 93       	push	r29
    5b0c:	cf 93       	push	r28
    5b0e:	0f 92       	push	r0
    5b10:	cd b7       	in	r28, 0x3d	; 61
    5b12:	de b7       	in	r29, 0x3e	; 62
	/** Display the password entry prompt on the LCD. */
	LCD_displayStringRowColumn(1, 0, "Pass:");
    5b14:	2b eb       	ldi	r18, 0xBB	; 187
    5b16:	30 e0       	ldi	r19, 0x00	; 0
    5b18:	81 e0       	ldi	r24, 0x01	; 1
    5b1a:	60 e0       	ldi	r22, 0x00	; 0
    5b1c:	a9 01       	movw	r20, r18
    5b1e:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <LCD_displayStringRowColumn>

	/** Move the cursor to the password entry position. */
	LCD_moveCursor(1, 5);
    5b22:	81 e0       	ldi	r24, 0x01	; 1
    5b24:	65 e0       	ldi	r22, 0x05	; 5
    5b26:	0e 94 9f 2a 	call	0x553e	; 0x553e <LCD_moveCursor>

	/** Initialize the iterator to track the number of entered characters. */
	uint8 iterator = 0;
    5b2a:	19 82       	std	Y+1, r1	; 0x01
    5b2c:	21 c0       	rjmp	.+66     	; 0x5b70 <HI_enterPassword+0x66>

	/** Loop until the maximum password length is reached. */
	while (iterator < SHARED_PASS_LENGTH) {
		/** Wait for a key press from the keypad. */
		key = KEYPAD_getPressedKeyBlocking();
    5b2e:	0e 94 b6 2c 	call	0x596c	; 0x596c <KEYPAD_getPressedKeyBlocking>
    5b32:	80 93 87 07 	sts	0x0787, r24

		/** Check if the pressed key is a digit. */
		if (key >= '0' && key <= '9') {
    5b36:	80 91 87 07 	lds	r24, 0x0787
    5b3a:	80 33       	cpi	r24, 0x30	; 48
    5b3c:	c8 f0       	brcs	.+50     	; 0x5b70 <HI_enterPassword+0x66>
    5b3e:	80 91 87 07 	lds	r24, 0x0787
    5b42:	8a 33       	cpi	r24, 0x3A	; 58
    5b44:	a8 f4       	brcc	.+42     	; 0x5b70 <HI_enterPassword+0x66>
			/** Increment the iterator for valid password characters. */
			iterator++;
    5b46:	89 81       	ldd	r24, Y+1	; 0x01
    5b48:	8f 5f       	subi	r24, 0xFF	; 255
    5b4a:	89 83       	std	Y+1, r24	; 0x01
			/** Display asterisk for each entered character on the LCD. */
			LCD_displayCharacter('*');
    5b4c:	8a e2       	ldi	r24, 0x2A	; 42
    5b4e:	0e 94 87 28 	call	0x510e	; 0x510e <LCD_displayCharacter>

			/** If not at the maximum length, send the key to the queue. */
			if (iterator < SHARED_PASS_LENGTH) {
    5b52:	89 81       	ldd	r24, Y+1	; 0x01
    5b54:	85 30       	cpi	r24, 0x05	; 5
    5b56:	60 f4       	brcc	.+24     	; 0x5b70 <HI_enterPassword+0x66>
				if (xQueueSend(g_xQueueSend, &key, (TickType_t)20) == pdPASS) {
    5b58:	80 91 8a 07 	lds	r24, 0x078A
    5b5c:	90 91 8b 07 	lds	r25, 0x078B
    5b60:	27 e8       	ldi	r18, 0x87	; 135
    5b62:	37 e0       	ldi	r19, 0x07	; 7
    5b64:	b9 01       	movw	r22, r18
    5b66:	44 e1       	ldi	r20, 0x14	; 20
    5b68:	50 e0       	ldi	r21, 0x00	; 0
    5b6a:	20 e0       	ldi	r18, 0x00	; 0
    5b6c:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <xQueueGenericSend>

	/** Initialize the iterator to track the number of entered characters. */
	uint8 iterator = 0;

	/** Loop until the maximum password length is reached. */
	while (iterator < SHARED_PASS_LENGTH) {
    5b70:	89 81       	ldd	r24, Y+1	; 0x01
    5b72:	85 30       	cpi	r24, 0x05	; 5
    5b74:	e0 f2       	brcs	.-72     	; 0x5b2e <HI_enterPassword+0x24>
			}
		}
	}

	/** Wait until the Enter key is pressed to confirm the password entry. */
	while (KEYPAD_ENTER_ASCII != KEYPAD_getPressedKeyBlocking()) {
    5b76:	0e 94 b6 2c 	call	0x596c	; 0x596c <KEYPAD_getPressedKeyBlocking>
    5b7a:	8d 30       	cpi	r24, 0x0D	; 13
    5b7c:	e1 f7       	brne	.-8      	; 0x5b76 <HI_enterPassword+0x6c>
		/** Loop until the Enter key is detected. */
	}

	/** Send the last key to the queue to indicate password entry completion. */
	if (xQueueSend(g_xQueueSend, &key, (TickType_t)20) == pdPASS) {
    5b7e:	80 91 8a 07 	lds	r24, 0x078A
    5b82:	90 91 8b 07 	lds	r25, 0x078B
    5b86:	27 e8       	ldi	r18, 0x87	; 135
    5b88:	37 e0       	ldi	r19, 0x07	; 7
    5b8a:	b9 01       	movw	r22, r18
    5b8c:	44 e1       	ldi	r20, 0x14	; 20
    5b8e:	50 e0       	ldi	r21, 0x00	; 0
    5b90:	20 e0       	ldi	r18, 0x00	; 0
    5b92:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <xQueueGenericSend>
		/** Message sent successfully. */
	}
}
    5b96:	0f 90       	pop	r0
    5b98:	cf 91       	pop	r28
    5b9a:	df 91       	pop	r29
    5b9c:	08 95       	ret

00005b9e <HI_getAndCheckPass>:
/**
 * @brief Validates the entered password against the stored password.
 *
 * @return uint8 Returns TRUE if the password is correct, otherwise FALSE.
 */
static uint8 HI_getAndCheckPass(void) {
    5b9e:	df 93       	push	r29
    5ba0:	cf 93       	push	r28
    5ba2:	00 d0       	rcall	.+0      	; 0x5ba4 <HI_getAndCheckPass+0x6>
    5ba4:	00 d0       	rcall	.+0      	; 0x5ba6 <HI_getAndCheckPass+0x8>
    5ba6:	cd b7       	in	r28, 0x3d	; 61
    5ba8:	de b7       	in	r29, 0x3e	; 62
	/** Initialize the number of allowed password attempts. */
	uint8 passTimes = 3;
    5baa:	83 e0       	ldi	r24, 0x03	; 3
    5bac:	89 83       	std	Y+1, r24	; 0x01

	/** Loop until the maximum password attempts are exhausted or success is achieved. */
	do {

		/** Prompt the user to enter the password. */
		LCD_clearScreen();
    5bae:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>
		LCD_displayString("Enter the Pass");
    5bb2:	81 ec       	ldi	r24, 0xC1	; 193
    5bb4:	90 e0       	ldi	r25, 0x00	; 0
    5bb6:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

		/** Call the function to enter the password. */
		HI_enterPassword();
    5bba:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <HI_enterPassword>

		/** Set the default receive value to indicate a failed attempt. */
		g_receiveValue = SHARED_FAIL;
    5bbe:	84 e0       	ldi	r24, 0x04	; 4
    5bc0:	80 93 86 07 	sts	0x0786, r24

		/** Check if a message is received in the queue. */
		if (xQueueReceive(g_xQueueReceive, &g_receiveValue, DELAY_TIME) == pdPASS) {
    5bc4:	80 91 8c 07 	lds	r24, 0x078C
    5bc8:	90 91 8d 07 	lds	r25, 0x078D
    5bcc:	26 e8       	ldi	r18, 0x86	; 134
    5bce:	37 e0       	ldi	r19, 0x07	; 7
    5bd0:	b9 01       	movw	r22, r18
    5bd2:	44 ef       	ldi	r20, 0xF4	; 244
    5bd4:	51 e0       	ldi	r21, 0x01	; 1
    5bd6:	20 e0       	ldi	r18, 0x00	; 0
    5bd8:	0e 94 2e 14 	call	0x285c	; 0x285c <xQueueGenericReceive>
			/** Message received successfully. */
		}

		/** Clear the LCD screen for feedback. */
		LCD_clearScreen();
    5bdc:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>

		/** Handle the received value based on the authentication result. */
		switch (g_receiveValue) {
    5be0:	80 91 86 07 	lds	r24, 0x0786
    5be4:	28 2f       	mov	r18, r24
    5be6:	30 e0       	ldi	r19, 0x00	; 0
    5be8:	3c 83       	std	Y+4, r19	; 0x04
    5bea:	2b 83       	std	Y+3, r18	; 0x03
    5bec:	8b 81       	ldd	r24, Y+3	; 0x03
    5bee:	9c 81       	ldd	r25, Y+4	; 0x04
    5bf0:	84 30       	cpi	r24, 0x04	; 4
    5bf2:	91 05       	cpc	r25, r1
    5bf4:	31 f0       	breq	.+12     	; 0x5c02 <HI_getAndCheckPass+0x64>
    5bf6:	2b 81       	ldd	r18, Y+3	; 0x03
    5bf8:	3c 81       	ldd	r19, Y+4	; 0x04
    5bfa:	27 30       	cpi	r18, 0x07	; 7
    5bfc:	31 05       	cpc	r19, r1
    5bfe:	21 f0       	breq	.+8      	; 0x5c08 <HI_getAndCheckPass+0x6a>
    5c00:	1f c0       	rjmp	.+62     	; 0x5c40 <HI_getAndCheckPass+0xa2>
		case SHARED_FAIL:
			/** Show an error message if authentication failed. */
			HI_showControlError();
    5c02:	0e 94 76 2d 	call	0x5aec	; 0x5aec <HI_showControlError>
    5c06:	1c c0       	rjmp	.+56     	; 0x5c40 <HI_getAndCheckPass+0xa2>
			break;
		case SHARED_PASS_DONT_MATCH:
			/** Decrement the number of remaining attempts. */
			passTimes--;
    5c08:	89 81       	ldd	r24, Y+1	; 0x01
    5c0a:	81 50       	subi	r24, 0x01	; 1
    5c0c:	89 83       	std	Y+1, r24	; 0x01

			/** Inform the user of the incorrect password. */
			LCD_displayString("Wrong Pass");
    5c0e:	80 ed       	ldi	r24, 0xD0	; 208
    5c10:	90 e0       	ldi	r25, 0x00	; 0
    5c12:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>
			LCD_moveCursor(1, 0);
    5c16:	81 e0       	ldi	r24, 0x01	; 1
    5c18:	60 e0       	ldi	r22, 0x00	; 0
    5c1a:	0e 94 9f 2a 	call	0x553e	; 0x553e <LCD_moveCursor>
			LCD_displayNumber(passTimes);
    5c1e:	89 81       	ldd	r24, Y+1	; 0x01
    5c20:	88 2f       	mov	r24, r24
    5c22:	90 e0       	ldi	r25, 0x00	; 0
    5c24:	a0 e0       	ldi	r26, 0x00	; 0
    5c26:	b0 e0       	ldi	r27, 0x00	; 0
    5c28:	bc 01       	movw	r22, r24
    5c2a:	cd 01       	movw	r24, r26
    5c2c:	0e 94 0e 2b 	call	0x561c	; 0x561c <LCD_displayNumber>
			LCD_displayString(" Tries Left");
    5c30:	8b ed       	ldi	r24, 0xDB	; 219
    5c32:	90 e0       	ldi	r25, 0x00	; 0
    5c34:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

			/** Delay before the next attempt. */
			vTaskDelay(DELAY_TIME);
    5c38:	84 ef       	ldi	r24, 0xF4	; 244
    5c3a:	91 e0       	ldi	r25, 0x01	; 1
    5c3c:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <vTaskDelay>
			break;
		}

		/** Check if the number of attempts has reached zero. */
		if (passTimes == 0) {
    5c40:	89 81       	ldd	r24, Y+1	; 0x01
    5c42:	88 23       	and	r24, r24
    5c44:	11 f4       	brne	.+4      	; 0x5c4a <HI_getAndCheckPass+0xac>
			/** Lock the system due to too many failed attempts. */
			HI_passTimesOut();
    5c46:	0e 94 24 2d 	call	0x5a48	; 0x5a48 <HI_passTimesOut>
		}

		/** Continue looping until attempts are exhausted or success is achieved. */
	} while (passTimes != 0 && g_receiveValue != SHARED_SUCCESS);
    5c4a:	89 81       	ldd	r24, Y+1	; 0x01
    5c4c:	88 23       	and	r24, r24
    5c4e:	29 f0       	breq	.+10     	; 0x5c5a <HI_getAndCheckPass+0xbc>
    5c50:	80 91 86 07 	lds	r24, 0x0786
    5c54:	83 30       	cpi	r24, 0x03	; 3
    5c56:	09 f0       	breq	.+2      	; 0x5c5a <HI_getAndCheckPass+0xbc>
    5c58:	aa cf       	rjmp	.-172    	; 0x5bae <HI_getAndCheckPass+0x10>

	/** Return true if the password was successfully validated. */
	return (g_receiveValue == SHARED_SUCCESS);
    5c5a:	80 91 86 07 	lds	r24, 0x0786
    5c5e:	1a 82       	std	Y+2, r1	; 0x02
    5c60:	83 30       	cpi	r24, 0x03	; 3
    5c62:	11 f4       	brne	.+4      	; 0x5c68 <HI_getAndCheckPass+0xca>
    5c64:	31 e0       	ldi	r19, 0x01	; 1
    5c66:	3a 83       	std	Y+2, r19	; 0x02
    5c68:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5c6a:	0f 90       	pop	r0
    5c6c:	0f 90       	pop	r0
    5c6e:	0f 90       	pop	r0
    5c70:	0f 90       	pop	r0
    5c72:	cf 91       	pop	r28
    5c74:	df 91       	pop	r29
    5c76:	08 95       	ret

00005c78 <HI_updatePass>:
/**
 * @brief Updates the password after validation.
 *
 * @return uint8 Returns TRUE if the password was updated successfully, otherwise FALSE.
 */
static uint8 HI_updatePass(void) {
    5c78:	df 93       	push	r29
    5c7a:	cf 93       	push	r28
    5c7c:	00 d0       	rcall	.+0      	; 0x5c7e <HI_updatePass+0x6>
    5c7e:	0f 92       	push	r0
    5c80:	cd b7       	in	r28, 0x3d	; 61
    5c82:	de b7       	in	r29, 0x3e	; 62
	/** Prompt the user to enter a new password. */
	LCD_clearScreen();
    5c84:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>
	LCD_displayString("Enter new Pass");
    5c88:	87 ee       	ldi	r24, 0xE7	; 231
    5c8a:	90 e0       	ldi	r25, 0x00	; 0
    5c8c:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

	/** Call the function to enter the new password. */
	HI_enterPassword();
    5c90:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <HI_enterPassword>

	/** Prompt the user to re-enter the new password for confirmation. */
	LCD_clearScreen();
    5c94:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>
	LCD_displayString("ReEnter new Pass");
    5c98:	86 ef       	ldi	r24, 0xF6	; 246
    5c9a:	90 e0       	ldi	r25, 0x00	; 0
    5c9c:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

	/** Call the function to enter the new password again. */
	HI_enterPassword();
    5ca0:	0e 94 85 2d 	call	0x5b0a	; 0x5b0a <HI_enterPassword>

	/** Set the default receive value to indicate a failed attempt. */
	g_receiveValue = SHARED_FAIL;
    5ca4:	84 e0       	ldi	r24, 0x04	; 4
    5ca6:	80 93 86 07 	sts	0x0786, r24

	/** Check if a message is received in the queue. */
	if (xQueueReceive(g_xQueueReceive, &g_receiveValue, DELAY_TIME) == pdPASS) {
    5caa:	80 91 8c 07 	lds	r24, 0x078C
    5cae:	90 91 8d 07 	lds	r25, 0x078D
    5cb2:	26 e8       	ldi	r18, 0x86	; 134
    5cb4:	37 e0       	ldi	r19, 0x07	; 7
    5cb6:	b9 01       	movw	r22, r18
    5cb8:	44 ef       	ldi	r20, 0xF4	; 244
    5cba:	51 e0       	ldi	r21, 0x01	; 1
    5cbc:	20 e0       	ldi	r18, 0x00	; 0
    5cbe:	0e 94 2e 14 	call	0x285c	; 0x285c <xQueueGenericReceive>
		/** Message received successfully. */
	}

	/** Clear the LCD screen for feedback on the password update. */
	LCD_clearScreen();
    5cc2:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>

	/** Handle the received value based on the password update result. */
	switch (g_receiveValue) {
    5cc6:	80 91 86 07 	lds	r24, 0x0786
    5cca:	28 2f       	mov	r18, r24
    5ccc:	30 e0       	ldi	r19, 0x00	; 0
    5cce:	3b 83       	std	Y+3, r19	; 0x03
    5cd0:	2a 83       	std	Y+2, r18	; 0x02
    5cd2:	8a 81       	ldd	r24, Y+2	; 0x02
    5cd4:	9b 81       	ldd	r25, Y+3	; 0x03
    5cd6:	84 30       	cpi	r24, 0x04	; 4
    5cd8:	91 05       	cpc	r25, r1
    5cda:	31 f0       	breq	.+12     	; 0x5ce8 <HI_updatePass+0x70>
    5cdc:	2a 81       	ldd	r18, Y+2	; 0x02
    5cde:	3b 81       	ldd	r19, Y+3	; 0x03
    5ce0:	27 30       	cpi	r18, 0x07	; 7
    5ce2:	31 05       	cpc	r19, r1
    5ce4:	21 f0       	breq	.+8      	; 0x5cee <HI_updatePass+0x76>
    5ce6:	12 c0       	rjmp	.+36     	; 0x5d0c <HI_updatePass+0x94>
	case SHARED_FAIL:
		/** Show an error message if the password update failed. */
		HI_showControlError();
    5ce8:	0e 94 76 2d 	call	0x5aec	; 0x5aec <HI_showControlError>
    5cec:	0f c0       	rjmp	.+30     	; 0x5d0c <HI_updatePass+0x94>
		break;
	case SHARED_PASS_DONT_MATCH:
		/** Inform the user that the passwords do not match. */
		LCD_displayString("Passwords don't");
    5cee:	87 e0       	ldi	r24, 0x07	; 7
    5cf0:	91 e0       	ldi	r25, 0x01	; 1
    5cf2:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>
		LCD_displayStringRowColumn(1, 0, "Match!");
    5cf6:	27 e1       	ldi	r18, 0x17	; 23
    5cf8:	31 e0       	ldi	r19, 0x01	; 1
    5cfa:	81 e0       	ldi	r24, 0x01	; 1
    5cfc:	60 e0       	ldi	r22, 0x00	; 0
    5cfe:	a9 01       	movw	r20, r18
    5d00:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <LCD_displayStringRowColumn>

		/** Delay to allow the user to read the message. */
		vTaskDelay(DELAY_TIME);
    5d04:	84 ef       	ldi	r24, 0xF4	; 244
    5d06:	91 e0       	ldi	r25, 0x01	; 1
    5d08:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <vTaskDelay>
		break;
	}

	/** Return true if the password was successfully updated. */
	return (g_receiveValue == SHARED_SUCCESS);
    5d0c:	80 91 86 07 	lds	r24, 0x0786
    5d10:	19 82       	std	Y+1, r1	; 0x01
    5d12:	83 30       	cpi	r24, 0x03	; 3
    5d14:	11 f4       	brne	.+4      	; 0x5d1a <HI_updatePass+0xa2>
    5d16:	31 e0       	ldi	r19, 0x01	; 1
    5d18:	39 83       	std	Y+1, r19	; 0x01
    5d1a:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d1c:	0f 90       	pop	r0
    5d1e:	0f 90       	pop	r0
    5d20:	0f 90       	pop	r0
    5d22:	cf 91       	pop	r28
    5d24:	df 91       	pop	r29
    5d26:	08 95       	ret

00005d28 <HI_taskInit>:
/**
 * @brief Initializes the Human Interface module.
 *
 * This function initializes the LCD and keypad.
 */
static void HI_taskInit(void) {
    5d28:	df 93       	push	r29
    5d2a:	cf 93       	push	r28
    5d2c:	cd b7       	in	r28, 0x3d	; 61
    5d2e:	de b7       	in	r29, 0x3e	; 62
	/** Initialize the LCD display for use. */
	LCD_init();
    5d30:	0e 94 fc 25 	call	0x4bf8	; 0x4bf8 <LCD_init>

	/** Initialize the keypad for input. */
	KEYPAD_init();
    5d34:	0e 94 37 2b 	call	0x566e	; 0x566e <KEYPAD_init>

	/** Set the keys for the keypad using the predefined key array. */
	KEYPAD_setKeys(keypadKeys);
    5d38:	83 e8       	ldi	r24, 0x83	; 131
    5d3a:	91 e0       	ldi	r25, 0x01	; 1
    5d3c:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <KEYPAD_setKeys>

	/** Display the main title for the door lock system on the LCD. */
	LCD_displayString("Door Lock System");
    5d40:	8e e1       	ldi	r24, 0x1E	; 30
    5d42:	91 e0       	ldi	r25, 0x01	; 1
    5d44:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

	/** Indicate that the system is loading on the second row of the LCD. */
	LCD_displayStringRowColumn(1, 0, "Loading");
    5d48:	2f e2       	ldi	r18, 0x2F	; 47
    5d4a:	31 e0       	ldi	r19, 0x01	; 1
    5d4c:	81 e0       	ldi	r24, 0x01	; 1
    5d4e:	60 e0       	ldi	r22, 0x00	; 0
    5d50:	a9 01       	movw	r20, r18
    5d52:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <LCD_displayStringRowColumn>

	/** Delay for a specified time to allow the loading message to be visible. */
	vTaskDelay(DELAY_TIME);
    5d56:	84 ef       	ldi	r24, 0xF4	; 244
    5d58:	91 e0       	ldi	r25, 0x01	; 1
    5d5a:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <vTaskDelay>
}
    5d5e:	cf 91       	pop	r28
    5d60:	df 91       	pop	r29
    5d62:	08 95       	ret

00005d64 <HI_checkPassExistAndLogIn>:

/**
 * @brief Checks if a password exists and attempts to log in.
 */
static void HI_checkPassExistAndLogIn(void) {
    5d64:	df 93       	push	r29
    5d66:	cf 93       	push	r28
    5d68:	cd b7       	in	r28, 0x3d	; 61
    5d6a:	de b7       	in	r29, 0x3e	; 62
	/** Infinite loop to continuously check for password existence and login. */
	for (;;) {
		/** Prepare to check if the password exists. */
		g_sendValue = SHARED_CHECK_PASS_EXIST;
    5d6c:	85 e0       	ldi	r24, 0x05	; 5
    5d6e:	80 93 85 07 	sts	0x0785, r24

		/** Check if the send queue is empty and send the message if possible. */
		if (xQueueIsQueueEmptyFromISR(g_xQueueSend) &&
    5d72:	80 91 8a 07 	lds	r24, 0x078A
    5d76:	90 91 8b 07 	lds	r25, 0x078B
    5d7a:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xQueueIsQueueEmptyFromISR>
    5d7e:	88 23       	and	r24, r24
    5d80:	61 f0       	breq	.+24     	; 0x5d9a <HI_checkPassExistAndLogIn+0x36>
    5d82:	80 91 8a 07 	lds	r24, 0x078A
    5d86:	90 91 8b 07 	lds	r25, 0x078B
    5d8a:	25 e8       	ldi	r18, 0x85	; 133
    5d8c:	37 e0       	ldi	r19, 0x07	; 7
    5d8e:	b9 01       	movw	r22, r18
    5d90:	44 e1       	ldi	r20, 0x14	; 20
    5d92:	50 e0       	ldi	r21, 0x00	; 0
    5d94:	20 e0       	ldi	r18, 0x00	; 0
    5d96:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <xQueueGenericSend>
		xQueueSend(g_xQueueSend, &g_sendValue, (TickType_t)20) == pdPASS) {
			/** Message sent successfully. */
		}

		/** Wait to receive a response regarding password existence. */
		if (xQueueReceive(g_xQueueReceive, &g_receiveValue, DELAY_TIME) == pdPASS) {
    5d9a:	80 91 8c 07 	lds	r24, 0x078C
    5d9e:	90 91 8d 07 	lds	r25, 0x078D
    5da2:	26 e8       	ldi	r18, 0x86	; 134
    5da4:	37 e0       	ldi	r19, 0x07	; 7
    5da6:	b9 01       	movw	r22, r18
    5da8:	44 ef       	ldi	r20, 0xF4	; 244
    5daa:	51 e0       	ldi	r21, 0x01	; 1
    5dac:	20 e0       	ldi	r18, 0x00	; 0
    5dae:	0e 94 2e 14 	call	0x285c	; 0x285c <xQueueGenericReceive>
    5db2:	81 30       	cpi	r24, 0x01	; 1
    5db4:	d9 f6       	brne	.-74     	; 0x5d6c <HI_checkPassExistAndLogIn+0x8>
			break; /** Exit the loop upon successful receipt. */
		}
	}

	/** If the password exists, attempt to get and validate the password. */
	if (g_receiveValue == SHARED_SUCCESS) {
    5db6:	80 91 86 07 	lds	r24, 0x0786
    5dba:	83 30       	cpi	r24, 0x03	; 3
    5dbc:	29 f4       	brne	.+10     	; 0x5dc8 <HI_checkPassExistAndLogIn+0x64>
		while (HI_getAndCheckPass() == FALSE)
    5dbe:	0e 94 cf 2d 	call	0x5b9e	; 0x5b9e <HI_getAndCheckPass>
    5dc2:	88 23       	and	r24, r24
    5dc4:	e1 f3       	breq	.-8      	; 0x5dbe <HI_checkPassExistAndLogIn+0x5a>
    5dc6:	04 c0       	rjmp	.+8      	; 0x5dd0 <HI_checkPassExistAndLogIn+0x6c>
			; /** Keep trying until the password is correct. */

	} else {
		/** If the password does not exist, attempt to update the password. */
		while (HI_updatePass() == FALSE)
    5dc8:	0e 94 3c 2e 	call	0x5c78	; 0x5c78 <HI_updatePass>
    5dcc:	88 23       	and	r24, r24
    5dce:	e1 f3       	breq	.-8      	; 0x5dc8 <HI_checkPassExistAndLogIn+0x64>
			; /** Keep trying until the password is successfully updated. */
	}
}
    5dd0:	cf 91       	pop	r28
    5dd2:	df 91       	pop	r29
    5dd4:	08 95       	ret

00005dd6 <HI_handleDoor>:
/**
 * @brief Handles the door operation based on user input.
 *
 * If the user wants to open the door, this function will manage the door unlocking process.
 */
static void HI_handleDoor(void) {
    5dd6:	df 93       	push	r29
    5dd8:	cf 93       	push	r28
    5dda:	cd b7       	in	r28, 0x3d	; 61
    5ddc:	de b7       	in	r29, 0x3e	; 62
	/** Display a message indicating the door is unlocking. */
	LCD_displayString("Door Unlocking");
    5dde:	87 e3       	ldi	r24, 0x37	; 55
    5de0:	91 e0       	ldi	r25, 0x01	; 1
    5de2:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

	/** Initialize the receive value to indicate failure initially. */
	g_receiveValue = SHARED_FAIL;
    5de6:	84 e0       	ldi	r24, 0x04	; 4
    5de8:	80 93 86 07 	sts	0x0786, r24

	/** Wait for a message indicating it's okay to proceed. */
	do {
		if (xQueueReceive(g_xQueueReceive, &g_receiveValue, DELAY_TIME) == pdPASS) {
    5dec:	80 91 8c 07 	lds	r24, 0x078C
    5df0:	90 91 8d 07 	lds	r25, 0x078D
    5df4:	26 e8       	ldi	r18, 0x86	; 134
    5df6:	37 e0       	ldi	r19, 0x07	; 7
    5df8:	b9 01       	movw	r22, r18
    5dfa:	44 ef       	ldi	r20, 0xF4	; 244
    5dfc:	51 e0       	ldi	r21, 0x01	; 1
    5dfe:	20 e0       	ldi	r18, 0x00	; 0
    5e00:	0e 94 2e 14 	call	0x285c	; 0x285c <xQueueGenericReceive>
			/** Message received successfully. */
		}
	} while (g_receiveValue != SHARED_WAIT_PEOPLE); /** Loop until the expected 'wait for people' message is received. */
    5e04:	80 91 86 07 	lds	r24, 0x0786
    5e08:	8a 30       	cpi	r24, 0x0A	; 10
    5e0a:	81 f7       	brne	.-32     	; 0x5dec <HI_handleDoor+0x16>

	/** Clear the display and notify users to wait for people to enter. */
	LCD_clearScreen();
    5e0c:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>
	LCD_displayString("Wait For People");
    5e10:	86 e4       	ldi	r24, 0x46	; 70
    5e12:	91 e0       	ldi	r25, 0x01	; 1
    5e14:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>
	LCD_displayStringRowColumn(1, 0, "To Enter");
    5e18:	26 e5       	ldi	r18, 0x56	; 86
    5e1a:	31 e0       	ldi	r19, 0x01	; 1
    5e1c:	81 e0       	ldi	r24, 0x01	; 1
    5e1e:	60 e0       	ldi	r22, 0x00	; 0
    5e20:	a9 01       	movw	r20, r18
    5e22:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <LCD_displayStringRowColumn>

	/** Wait for a message indicating the door is locking. */
	do {
		if (xQueueReceive(g_xQueueReceive, &g_receiveValue, DELAY_TIME) == pdPASS) {
    5e26:	80 91 8c 07 	lds	r24, 0x078C
    5e2a:	90 91 8d 07 	lds	r25, 0x078D
    5e2e:	26 e8       	ldi	r18, 0x86	; 134
    5e30:	37 e0       	ldi	r19, 0x07	; 7
    5e32:	b9 01       	movw	r22, r18
    5e34:	44 ef       	ldi	r20, 0xF4	; 244
    5e36:	51 e0       	ldi	r21, 0x01	; 1
    5e38:	20 e0       	ldi	r18, 0x00	; 0
    5e3a:	0e 94 2e 14 	call	0x285c	; 0x285c <xQueueGenericReceive>
			/** Message received successfully. */
		}
	} while (g_receiveValue != SHARED_LOCKING_DOOR); /** Loop until the 'locking door' message is received. */
    5e3e:	80 91 86 07 	lds	r24, 0x0786
    5e42:	8b 30       	cpi	r24, 0x0B	; 11
    5e44:	81 f7       	brne	.-32     	; 0x5e26 <HI_handleDoor+0x50>

	/** Clear the display and show a message indicating the door is locking. */
	LCD_clearScreen();
    5e46:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <LCD_clearScreen>
	LCD_displayString("Door Locking");
    5e4a:	8f e5       	ldi	r24, 0x5F	; 95
    5e4c:	91 e0       	ldi	r25, 0x01	; 1
    5e4e:	0e 94 76 2a 	call	0x54ec	; 0x54ec <LCD_displayString>

	/** Wait for a message indicating the door is closed. */
	do {
		if (xQueueReceive(g_xQueueReceive, &g_receiveValue, DELAY_TIME) == pdPASS) {
    5e52:	80 91 8c 07 	lds	r24, 0x078C
    5e56:	90 91 8d 07 	lds	r25, 0x078D
    5e5a:	26 e8       	ldi	r18, 0x86	; 134
    5e5c:	37 e0       	ldi	r19, 0x07	; 7
    5e5e:	b9 01       	movw	r22, r18
    5e60:	44 ef       	ldi	r20, 0xF4	; 244
    5e62:	51 e0       	ldi	r21, 0x01	; 1
    5e64:	20 e0       	ldi	r18, 0x00	; 0
    5e66:	0e 94 2e 14 	call	0x285c	; 0x285c <xQueueGenericReceive>
			/** Message received successfully. */
		}
	} while (g_receiveValue != SHARED_DOOR_CLOSED); /** Loop until the 'door closed' message is received. */
    5e6a:	80 91 86 07 	lds	r24, 0x0786
    5e6e:	8c 30       	cpi	r24, 0x0C	; 12
    5e70:	81 f7       	brne	.-32     	; 0x5e52 <HI_handleDoor+0x7c>
}
    5e72:	cf 91       	pop	r28
    5e74:	df 91       	pop	r29
    5e76:	08 95       	ret

00005e78 <CI_usartReceiveIntHandl>:
#include "../queues.h"

SemaphoreHandle_t usartReceiveSemphr;


void CI_usartReceiveIntHandl(void) {
    5e78:	df 93       	push	r29
    5e7a:	cf 93       	push	r28
    5e7c:	0f 92       	push	r0
    5e7e:	cd b7       	in	r28, 0x3d	; 61
    5e80:	de b7       	in	r29, 0x3e	; 62
    uint8 dataReceive;
    USART_receiveCharNonBlocking(&dataReceive);
    5e82:	ce 01       	movw	r24, r28
    5e84:	01 96       	adiw	r24, 0x01	; 1
    5e86:	0e 94 3c 07 	call	0xe78	; 0xe78 <USART_receiveCharNonBlocking>
    if (xQueueSend(g_xQueueReceive, &dataReceive, (TickType_t)20) == pdPASS) {
    5e8a:	80 91 8c 07 	lds	r24, 0x078C
    5e8e:	90 91 8d 07 	lds	r25, 0x078D
    5e92:	9e 01       	movw	r18, r28
    5e94:	2f 5f       	subi	r18, 0xFF	; 255
    5e96:	3f 4f       	sbci	r19, 0xFF	; 255
    5e98:	b9 01       	movw	r22, r18
    5e9a:	44 e1       	ldi	r20, 0x14	; 20
    5e9c:	50 e0       	ldi	r21, 0x00	; 0
    5e9e:	20 e0       	ldi	r18, 0x00	; 0
    5ea0:	0e 94 d9 12 	call	0x25b2	; 0x25b2 <xQueueGenericSend>
         /*Successfully sent the received data to the queue*/
    }
}
    5ea4:	0f 90       	pop	r0
    5ea6:	cf 91       	pop	r28
    5ea8:	df 91       	pop	r29
    5eaa:	08 95       	ret

00005eac <CI_usartTask>:


void CI_usartTask(void *pvParameters) {
    5eac:	df 93       	push	r29
    5eae:	cf 93       	push	r28
    5eb0:	00 d0       	rcall	.+0      	; 0x5eb2 <CI_usartTask+0x6>
    5eb2:	0f 92       	push	r0
    5eb4:	cd b7       	in	r28, 0x3d	; 61
    5eb6:	de b7       	in	r29, 0x3e	; 62
    5eb8:	9b 83       	std	Y+3, r25	; 0x03
    5eba:	8a 83       	std	Y+2, r24	; 0x02
    if (USART_isInit() == FALSE) {
    5ebc:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <USART_isInit>
    5ec0:	88 23       	and	r24, r24
    5ec2:	21 f4       	brne	.+8      	; 0x5ecc <CI_usartTask+0x20>
        USART_init(&g_usart);
    5ec4:	8b e7       	ldi	r24, 0x7B	; 123
    5ec6:	91 e0       	ldi	r25, 0x01	; 1
    5ec8:	0e 94 a3 05 	call	0xb46	; 0xb46 <USART_init>
    }

    USART_setRXCompleteInterruptHandler(CI_usartReceiveIntHandl);
    5ecc:	8c e3       	ldi	r24, 0x3C	; 60
    5ece:	9f e2       	ldi	r25, 0x2F	; 47
    5ed0:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <USART_setRXCompleteInterruptHandler>

    uint8 dataSend;
    for (;;) {
        if (xQueueReceive(g_xQueueSend, &dataSend, portMAX_DELAY) == pdPASS) {
    5ed4:	80 91 8a 07 	lds	r24, 0x078A
    5ed8:	90 91 8b 07 	lds	r25, 0x078B
    5edc:	9e 01       	movw	r18, r28
    5ede:	2f 5f       	subi	r18, 0xFF	; 255
    5ee0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ee2:	b9 01       	movw	r22, r18
    5ee4:	4f ef       	ldi	r20, 0xFF	; 255
    5ee6:	5f ef       	ldi	r21, 0xFF	; 255
    5ee8:	20 e0       	ldi	r18, 0x00	; 0
    5eea:	0e 94 2e 14 	call	0x285c	; 0x285c <xQueueGenericReceive>
    5eee:	81 30       	cpi	r24, 0x01	; 1
    5ef0:	89 f7       	brne	.-30     	; 0x5ed4 <CI_usartTask+0x28>
            while (!USART_sendCharNonBlocking(dataSend))
    5ef2:	89 81       	ldd	r24, Y+1	; 0x01
    5ef4:	0e 94 22 07 	call	0xe44	; 0xe44 <USART_sendCharNonBlocking>
    5ef8:	88 23       	and	r24, r24
    5efa:	d9 f3       	breq	.-10     	; 0x5ef2 <CI_usartTask+0x46>
    5efc:	eb cf       	rjmp	.-42     	; 0x5ed4 <CI_usartTask+0x28>

00005efe <main>:
#include "ControlInterface/controlinterface.h"

QueueHandle_t g_xQueueReceive;  /* Queue for receiving data */
QueueHandle_t g_xQueueSend;     /* Queue for sending data	*/

int main() {
    5efe:	ef 92       	push	r14
    5f00:	ff 92       	push	r15
    5f02:	0f 93       	push	r16
    5f04:	df 93       	push	r29
    5f06:	cf 93       	push	r28
    5f08:	00 d0       	rcall	.+0      	; 0x5f0a <main+0xc>
    5f0a:	cd b7       	in	r28, 0x3d	; 61
    5f0c:	de b7       	in	r29, 0x3e	; 62
    /* Create the receive queue with a maximum of 5 items of size uint8 */
    g_xQueueReceive = xQueueCreate(5, sizeof(uint8));
    5f0e:	85 e0       	ldi	r24, 0x05	; 5
    5f10:	61 e0       	ldi	r22, 0x01	; 1
    5f12:	40 e0       	ldi	r20, 0x00	; 0
    5f14:	0e 94 0d 12 	call	0x241a	; 0x241a <xQueueGenericCreate>
    5f18:	90 93 8d 07 	sts	0x078D, r25
    5f1c:	80 93 8c 07 	sts	0x078C, r24
    if (g_xQueueReceive == NULL) {
    5f20:	80 91 8c 07 	lds	r24, 0x078C
    5f24:	90 91 8d 07 	lds	r25, 0x078D
    5f28:	00 97       	sbiw	r24, 0x00	; 0
    5f2a:	19 f4       	brne	.+6      	; 0x5f32 <main+0x34>
        return 0; /* Failed to create the receive queue */
    5f2c:	1a 82       	std	Y+2, r1	; 0x02
    5f2e:	19 82       	std	Y+1, r1	; 0x01
    5f30:	3d c0       	rjmp	.+122    	; 0x5fac <main+0xae>
    }

    /* Create the send queue with a maximum of 5 items of size uint8 */
    g_xQueueSend = xQueueCreate(5, sizeof(uint8));
    5f32:	85 e0       	ldi	r24, 0x05	; 5
    5f34:	61 e0       	ldi	r22, 0x01	; 1
    5f36:	40 e0       	ldi	r20, 0x00	; 0
    5f38:	0e 94 0d 12 	call	0x241a	; 0x241a <xQueueGenericCreate>
    5f3c:	90 93 8b 07 	sts	0x078B, r25
    5f40:	80 93 8a 07 	sts	0x078A, r24
    if (g_xQueueSend == NULL) {
    5f44:	80 91 8a 07 	lds	r24, 0x078A
    5f48:	90 91 8b 07 	lds	r25, 0x078B
    5f4c:	00 97       	sbiw	r24, 0x00	; 0
    5f4e:	19 f4       	brne	.+6      	; 0x5f56 <main+0x58>
        return 0; /* Failed to create the send queue */
    5f50:	1a 82       	std	Y+2, r1	; 0x02
    5f52:	19 82       	std	Y+1, r1	; 0x01
    5f54:	2b c0       	rjmp	.+86     	; 0x5fac <main+0xae>
    }

    /* Create the Human Interface task */
    if(pdPASS != xTaskCreate(HI_task, "HI", 1000, NULL, 1, NULL)) {
    5f56:	89 ec       	ldi	r24, 0xC9	; 201
    5f58:	9c e2       	ldi	r25, 0x2C	; 44
    5f5a:	2c e6       	ldi	r18, 0x6C	; 108
    5f5c:	31 e0       	ldi	r19, 0x01	; 1
    5f5e:	b9 01       	movw	r22, r18
    5f60:	48 ee       	ldi	r20, 0xE8	; 232
    5f62:	53 e0       	ldi	r21, 0x03	; 3
    5f64:	20 e0       	ldi	r18, 0x00	; 0
    5f66:	30 e0       	ldi	r19, 0x00	; 0
    5f68:	01 e0       	ldi	r16, 0x01	; 1
    5f6a:	ee 24       	eor	r14, r14
    5f6c:	ff 24       	eor	r15, r15
    5f6e:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <xTaskCreate>
    5f72:	81 30       	cpi	r24, 0x01	; 1
    5f74:	19 f0       	breq	.+6      	; 0x5f7c <main+0x7e>
        return 0; /* Failed to create the Human Interface task */
    5f76:	1a 82       	std	Y+2, r1	; 0x02
    5f78:	19 82       	std	Y+1, r1	; 0x01
    5f7a:	18 c0       	rjmp	.+48     	; 0x5fac <main+0xae>
    }

    /* Create the Control Interface USART task */
    if(pdPASS != xTaskCreate(CI_usartTask, "CIS", 80, NULL, 2, NULL)) {
    5f7c:	86 e5       	ldi	r24, 0x56	; 86
    5f7e:	9f e2       	ldi	r25, 0x2F	; 47
    5f80:	2f e6       	ldi	r18, 0x6F	; 111
    5f82:	31 e0       	ldi	r19, 0x01	; 1
    5f84:	b9 01       	movw	r22, r18
    5f86:	40 e5       	ldi	r20, 0x50	; 80
    5f88:	50 e0       	ldi	r21, 0x00	; 0
    5f8a:	20 e0       	ldi	r18, 0x00	; 0
    5f8c:	30 e0       	ldi	r19, 0x00	; 0
    5f8e:	02 e0       	ldi	r16, 0x02	; 2
    5f90:	ee 24       	eor	r14, r14
    5f92:	ff 24       	eor	r15, r15
    5f94:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <xTaskCreate>
    5f98:	81 30       	cpi	r24, 0x01	; 1
    5f9a:	19 f0       	breq	.+6      	; 0x5fa2 <main+0xa4>
        return 0; /* Failed to create the Control Interface task */
    5f9c:	1a 82       	std	Y+2, r1	; 0x02
    5f9e:	19 82       	std	Y+1, r1	; 0x01
    5fa0:	05 c0       	rjmp	.+10     	; 0x5fac <main+0xae>
    }

    /* Enable global interrupts */
    __asm__("SEI");
    5fa2:	78 94       	sei

    /* Start the FreeRTOS scheduler */
    vTaskStartScheduler();
    5fa4:	0e 94 cb 1b 	call	0x3796	; 0x3796 <vTaskStartScheduler>

    /* Return 0 if the scheduler exits (this should not happen) */
    return 0;
    5fa8:	1a 82       	std	Y+2, r1	; 0x02
    5faa:	19 82       	std	Y+1, r1	; 0x01
    5fac:	89 81       	ldd	r24, Y+1	; 0x01
    5fae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5fb0:	0f 90       	pop	r0
    5fb2:	0f 90       	pop	r0
    5fb4:	cf 91       	pop	r28
    5fb6:	df 91       	pop	r29
    5fb8:	0f 91       	pop	r16
    5fba:	ff 90       	pop	r15
    5fbc:	ef 90       	pop	r14
    5fbe:	08 95       	ret

00005fc0 <__udivmodsi4>:
    5fc0:	a1 e2       	ldi	r26, 0x21	; 33
    5fc2:	1a 2e       	mov	r1, r26
    5fc4:	aa 1b       	sub	r26, r26
    5fc6:	bb 1b       	sub	r27, r27
    5fc8:	fd 01       	movw	r30, r26
    5fca:	0d c0       	rjmp	.+26     	; 0x5fe6 <__udivmodsi4_ep>

00005fcc <__udivmodsi4_loop>:
    5fcc:	aa 1f       	adc	r26, r26
    5fce:	bb 1f       	adc	r27, r27
    5fd0:	ee 1f       	adc	r30, r30
    5fd2:	ff 1f       	adc	r31, r31
    5fd4:	a2 17       	cp	r26, r18
    5fd6:	b3 07       	cpc	r27, r19
    5fd8:	e4 07       	cpc	r30, r20
    5fda:	f5 07       	cpc	r31, r21
    5fdc:	20 f0       	brcs	.+8      	; 0x5fe6 <__udivmodsi4_ep>
    5fde:	a2 1b       	sub	r26, r18
    5fe0:	b3 0b       	sbc	r27, r19
    5fe2:	e4 0b       	sbc	r30, r20
    5fe4:	f5 0b       	sbc	r31, r21

00005fe6 <__udivmodsi4_ep>:
    5fe6:	66 1f       	adc	r22, r22
    5fe8:	77 1f       	adc	r23, r23
    5fea:	88 1f       	adc	r24, r24
    5fec:	99 1f       	adc	r25, r25
    5fee:	1a 94       	dec	r1
    5ff0:	69 f7       	brne	.-38     	; 0x5fcc <__udivmodsi4_loop>
    5ff2:	60 95       	com	r22
    5ff4:	70 95       	com	r23
    5ff6:	80 95       	com	r24
    5ff8:	90 95       	com	r25
    5ffa:	9b 01       	movw	r18, r22
    5ffc:	ac 01       	movw	r20, r24
    5ffe:	bd 01       	movw	r22, r26
    6000:	cf 01       	movw	r24, r30
    6002:	08 95       	ret

00006004 <__prologue_saves__>:
    6004:	2f 92       	push	r2
    6006:	3f 92       	push	r3
    6008:	4f 92       	push	r4
    600a:	5f 92       	push	r5
    600c:	6f 92       	push	r6
    600e:	7f 92       	push	r7
    6010:	8f 92       	push	r8
    6012:	9f 92       	push	r9
    6014:	af 92       	push	r10
    6016:	bf 92       	push	r11
    6018:	cf 92       	push	r12
    601a:	df 92       	push	r13
    601c:	ef 92       	push	r14
    601e:	ff 92       	push	r15
    6020:	0f 93       	push	r16
    6022:	1f 93       	push	r17
    6024:	cf 93       	push	r28
    6026:	df 93       	push	r29
    6028:	cd b7       	in	r28, 0x3d	; 61
    602a:	de b7       	in	r29, 0x3e	; 62
    602c:	ca 1b       	sub	r28, r26
    602e:	db 0b       	sbc	r29, r27
    6030:	0f b6       	in	r0, 0x3f	; 63
    6032:	f8 94       	cli
    6034:	de bf       	out	0x3e, r29	; 62
    6036:	0f be       	out	0x3f, r0	; 63
    6038:	cd bf       	out	0x3d, r28	; 61
    603a:	09 94       	ijmp

0000603c <__epilogue_restores__>:
    603c:	2a 88       	ldd	r2, Y+18	; 0x12
    603e:	39 88       	ldd	r3, Y+17	; 0x11
    6040:	48 88       	ldd	r4, Y+16	; 0x10
    6042:	5f 84       	ldd	r5, Y+15	; 0x0f
    6044:	6e 84       	ldd	r6, Y+14	; 0x0e
    6046:	7d 84       	ldd	r7, Y+13	; 0x0d
    6048:	8c 84       	ldd	r8, Y+12	; 0x0c
    604a:	9b 84       	ldd	r9, Y+11	; 0x0b
    604c:	aa 84       	ldd	r10, Y+10	; 0x0a
    604e:	b9 84       	ldd	r11, Y+9	; 0x09
    6050:	c8 84       	ldd	r12, Y+8	; 0x08
    6052:	df 80       	ldd	r13, Y+7	; 0x07
    6054:	ee 80       	ldd	r14, Y+6	; 0x06
    6056:	fd 80       	ldd	r15, Y+5	; 0x05
    6058:	0c 81       	ldd	r16, Y+4	; 0x04
    605a:	1b 81       	ldd	r17, Y+3	; 0x03
    605c:	aa 81       	ldd	r26, Y+2	; 0x02
    605e:	b9 81       	ldd	r27, Y+1	; 0x01
    6060:	ce 0f       	add	r28, r30
    6062:	d1 1d       	adc	r29, r1
    6064:	0f b6       	in	r0, 0x3f	; 63
    6066:	f8 94       	cli
    6068:	de bf       	out	0x3e, r29	; 62
    606a:	0f be       	out	0x3f, r0	; 63
    606c:	cd bf       	out	0x3d, r28	; 61
    606e:	ed 01       	movw	r28, r26
    6070:	08 95       	ret

00006072 <memcpy>:
    6072:	fb 01       	movw	r30, r22
    6074:	dc 01       	movw	r26, r24
    6076:	02 c0       	rjmp	.+4      	; 0x607c <memcpy+0xa>
    6078:	01 90       	ld	r0, Z+
    607a:	0d 92       	st	X+, r0
    607c:	41 50       	subi	r20, 0x01	; 1
    607e:	50 40       	sbci	r21, 0x00	; 0
    6080:	d8 f7       	brcc	.-10     	; 0x6078 <memcpy+0x6>
    6082:	08 95       	ret

00006084 <ltoa>:
    6084:	fa 01       	movw	r30, r20
    6086:	cf 93       	push	r28
    6088:	ff 93       	push	r31
    608a:	ef 93       	push	r30
    608c:	22 30       	cpi	r18, 0x02	; 2
    608e:	44 f1       	brlt	.+80     	; 0x60e0 <ltoa+0x5c>
    6090:	25 32       	cpi	r18, 0x25	; 37
    6092:	34 f5       	brge	.+76     	; 0x60e0 <ltoa+0x5c>
    6094:	c2 2f       	mov	r28, r18
    6096:	e8 94       	clt
    6098:	ca 30       	cpi	r28, 0x0A	; 10
    609a:	49 f4       	brne	.+18     	; 0x60ae <ltoa+0x2a>
    609c:	97 fb       	bst	r25, 7
    609e:	3e f4       	brtc	.+14     	; 0x60ae <ltoa+0x2a>
    60a0:	90 95       	com	r25
    60a2:	80 95       	com	r24
    60a4:	70 95       	com	r23
    60a6:	61 95       	neg	r22
    60a8:	7f 4f       	sbci	r23, 0xFF	; 255
    60aa:	8f 4f       	sbci	r24, 0xFF	; 255
    60ac:	9f 4f       	sbci	r25, 0xFF	; 255
    60ae:	2c 2f       	mov	r18, r28
    60b0:	33 27       	eor	r19, r19
    60b2:	44 27       	eor	r20, r20
    60b4:	55 27       	eor	r21, r21
    60b6:	ff 93       	push	r31
    60b8:	ef 93       	push	r30
    60ba:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <__udivmodsi4>
    60be:	ef 91       	pop	r30
    60c0:	ff 91       	pop	r31
    60c2:	60 5d       	subi	r22, 0xD0	; 208
    60c4:	6a 33       	cpi	r22, 0x3A	; 58
    60c6:	0c f0       	brlt	.+2      	; 0x60ca <ltoa+0x46>
    60c8:	69 5d       	subi	r22, 0xD9	; 217
    60ca:	61 93       	st	Z+, r22
    60cc:	b9 01       	movw	r22, r18
    60ce:	ca 01       	movw	r24, r20
    60d0:	60 50       	subi	r22, 0x00	; 0
    60d2:	70 40       	sbci	r23, 0x00	; 0
    60d4:	80 40       	sbci	r24, 0x00	; 0
    60d6:	90 40       	sbci	r25, 0x00	; 0
    60d8:	51 f7       	brne	.-44     	; 0x60ae <ltoa+0x2a>
    60da:	16 f4       	brtc	.+4      	; 0x60e0 <ltoa+0x5c>
    60dc:	cd e2       	ldi	r28, 0x2D	; 45
    60de:	c1 93       	st	Z+, r28
    60e0:	10 82       	st	Z, r1
    60e2:	8f 91       	pop	r24
    60e4:	9f 91       	pop	r25
    60e6:	cf 91       	pop	r28
    60e8:	0c 94 76 30 	jmp	0x60ec	; 0x60ec <strrev>

000060ec <strrev>:
    60ec:	dc 01       	movw	r26, r24
    60ee:	fc 01       	movw	r30, r24
    60f0:	67 2f       	mov	r22, r23
    60f2:	71 91       	ld	r23, Z+
    60f4:	77 23       	and	r23, r23
    60f6:	e1 f7       	brne	.-8      	; 0x60f0 <strrev+0x4>
    60f8:	32 97       	sbiw	r30, 0x02	; 2
    60fa:	04 c0       	rjmp	.+8      	; 0x6104 <strrev+0x18>
    60fc:	7c 91       	ld	r23, X
    60fe:	6d 93       	st	X+, r22
    6100:	70 83       	st	Z, r23
    6102:	62 91       	ld	r22, -Z
    6104:	ae 17       	cp	r26, r30
    6106:	bf 07       	cpc	r27, r31
    6108:	c8 f3       	brcs	.-14     	; 0x60fc <strrev+0x10>
    610a:	08 95       	ret

0000610c <_exit>:
    610c:	f8 94       	cli

0000610e <__stop_program>:
    610e:	ff cf       	rjmp	.-2      	; 0x610e <__stop_program>
